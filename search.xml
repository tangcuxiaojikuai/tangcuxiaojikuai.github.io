<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2023-羊城杯-wp-crypto</title>
    <url>/post/47440.html</url>
    <content><![CDATA[<p>随手记录一下~</p>
<span id="more"></span>
<h2 id="Danger-RSA"><a href="#Danger-RSA" class="headerlink" title="Danger_RSA"></a>Danger_RSA</h2><p>题目描述:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">看似简单的rsa</span><br></pre></td></tr></table></figure>
<p>题目:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">m = bytes_to_long(flag)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_key</span>(<span class="params">a, nbit</span>):</span><br><span class="line">    <span class="keyword">assert</span> a &gt;= <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        X = getRandomInteger(nbit // a)</span><br><span class="line">        s = getRandomRange(<span class="built_in">pow</span>(<span class="number">2</span>, a ** <span class="number">2</span> - a + <span class="number">4</span>), <span class="built_in">pow</span>(<span class="number">2</span>, a ** <span class="number">2</span> - a + <span class="number">5</span>))</span><br><span class="line">        p = X ** a + s</span><br><span class="line">        <span class="keyword">if</span> isPrime(p):</span><br><span class="line">            <span class="keyword">return</span> (p, s)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p, s = get_key(a, <span class="number">1024</span>)</span><br><span class="line">q, t = get_key(a, <span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line">N = p * q</span><br><span class="line">e = s * t</span><br><span class="line">c = <span class="built_in">pow</span>(m, e, N)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;N =&quot;</span>, N)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;e =&quot;</span>, e)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;c =&quot;</span>, c)</span><br><span class="line"><span class="comment"># N = 20289788565671012003324307131062103060859990244423187333725116068731043744218295859587498278382150779775620675092152011336913225797849717782573829179765649320271927359983554162082141908877255319715400550981462988869084618816967398571437725114356308935833701495015311197958172878812521403732038749414005661189594761246154666465178024563227666440066723650451362032162000998737626370987794816660694178305939474922064726534186386488052827919792122844587807300048430756990391177266977583227470089929347969731703368720788359127837289988944365786283419724178187242169399457608505627145016468888402441344333481249304670223</span></span><br><span class="line"><span class="comment"># e = 11079917583</span></span><br><span class="line"><span class="comment"># c = 13354219204055754230025847310134936965811370208880054443449019813095522768684299807719787421318648141224402269593016895821181312342830493800652737679627324687428327297369122017160142465940412477792023917546122283870042482432790385644640286392037986185997262289003477817675380787176650410819568815448960281666117602590863047680652856789877783422272330706693947399620261349458556870056095723068536573904350085124198592111773470010262148170379730937529246069218004969402885134027857991552224816835834207152308645148250837667184968030600819179396545349582556181916861808402629154688779221034610013350165801919342549766</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题目初看没有什么下手点，但其实get_key函数的这两行暴露了很多信息:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X = getRandomInteger(nbit // a)</span><br><span class="line">s = getRandomRange(<span class="built_in">pow</span>(<span class="number">2</span>, a ** <span class="number">2</span> - a + <span class="number">4</span>), <span class="built_in">pow</span>(<span class="number">2</span>, a ** <span class="number">2</span> - a + <span class="number">5</span>))</span><br></pre></td></tr></table></figure>
<p>也就是说，a可能的范围其实很小，粗略的范围都仅有[2,1024],这个时候再看生成的e，可以发现，e相对来说太小了，甚至可以得到他的全部素因子分解，即：</p>
<script type="math/tex; mode=display">
e = 3*7*7*19*691*5741</script><p>因此我们完全可以用下面这个方式来进一步确定a的取值范围:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> a <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,<span class="number">1024</span>):</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">pow</span>(<span class="number">2</span>, a ** <span class="number">2</span> - a + <span class="number">4</span>)*<span class="built_in">pow</span>(<span class="number">2</span>, a ** <span class="number">2</span> - a + <span class="number">4</span>) &lt;= e <span class="keyword">and</span> <span class="built_in">pow</span>(<span class="number">2</span>, a ** <span class="number">2</span> - a + <span class="number">5</span>)*<span class="built_in">pow</span>(<span class="number">2</span>, a ** <span class="number">2</span> - a + <span class="number">5</span>) &gt;= e):</span><br><span class="line">        <span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure>
<p>可以发现，a其实仅能取4；与此同时可以明白，对于刚才的e的因子分解，仅有两种可能的组合让两次生成的s均落在a规定的范围里：</p>
<script type="math/tex; mode=display">
s=5741*19\;,\;t=691*3*7*7</script><script type="math/tex; mode=display">
s=5741*3*7\;,\;t=691*7*19</script><p>此时再看n的生成过程：</p>
<script type="math/tex; mode=display">
n = (X1^4 + s)*(X2^4 + t)</script><p>s和t相较于X1、X2来说非常小，因此对n开4次方根就可以得到X1*X2，此时，就可以以以下方式分解n：</p>
<script type="math/tex; mode=display">
n = (X1*X2)^4 + t*X1^4 + s*X2^4  + s*t</script><p>将所有量移动到同一侧：</p>
<script type="math/tex; mode=display">
(X1*X2)^4 + t*X1^4 + s*X2^4  + s*t - n = 0</script><p>左右同时乘$\; X1^4$，得:</p>
<script type="math/tex; mode=display">
((X1*X2)^4  + s*t - n)* X1^4 + t*(X1^4)^2 + s*X2^4*X1^4= 0</script><p>此时，令$\;x = X1^4$，就得到下面的一元二次方程：</p>
<script type="math/tex; mode=display">
t*x^2 + ((X1*X2)^4  + s*t - n)* x + s*(X2*X1)^4= 0</script><p>将可能的两组s、t，逐个代入解上述方程，就可以得到n的分解。</p>
<p>得到n的分解后，想要直接求解RSA解密却发现$\;gcd(e,phi_n)\;!=\;1$，发现是因为$\;3|(p-1)$且$\;7|(q-1)$，此时由于题目中并未说明对flag做过额外填充处理，而p、q两个因子均有接近1024比特，正常来说远大于明文比特位，因此可以转化到模p下求解，这是因为：</p>
<script type="math/tex; mode=display">
m^{e} = (m^3)^{7*7*19*691*5741} \equiv c\quad(mod\;p)</script><p>而</p>
<script type="math/tex; mode=display">
\quad gcd(7*7*19*691*5741,(p-1)) = 1</script><p>所以可以将$m^3$当作一个整体，进行RSA解密后在模p下开三次方根即可。</p>
<p><br></p>
<p>exp.ipynb:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> iroot</span><br><span class="line"></span><br><span class="line">N = <span class="number">20289788565671012003324307131062103060859990244423187333725116068731043744218295859587498278382150779775620675092152011336913225797849717782573829179765649320271927359983554162082141908877255319715400550981462988869084618816967398571437725114356308935833701495015311197958172878812521403732038749414005661189594761246154666465178024563227666440066723650451362032162000998737626370987794816660694178305939474922064726534186386488052827919792122844587807300048430756990391177266977583227470089929347969731703368720788359127837289988944365786283419724178187242169399457608505627145016468888402441344333481249304670223</span></span><br><span class="line">e = <span class="number">11079917583</span></span><br><span class="line">c = <span class="number">13354219204055754230025847310134936965811370208880054443449019813095522768684299807719787421318648141224402269593016895821181312342830493800652737679627324687428327297369122017160142465940412477792023917546122283870042482432790385644640286392037986185997262289003477817675380787176650410819568815448960281666117602590863047680652856789877783422272330706693947399620261349458556870056095723068536573904350085124198592111773470010262148170379730937529246069218004969402885134027857991552224816835834207152308645148250837667184968030600819179396545349582556181916861808402629154688779221034610013350165801919342549766</span></span><br><span class="line">elist = [<span class="number">3</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">19</span>,<span class="number">691</span>,<span class="number">5741</span>]</span><br><span class="line"></span><br><span class="line">a = <span class="number">2</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,<span class="number">10</span>):</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">pow</span>(<span class="number">2</span>, i ** <span class="number">2</span> - i + <span class="number">4</span>)*<span class="built_in">pow</span>(<span class="number">2</span>, i ** <span class="number">2</span> - i + <span class="number">4</span>) &lt;= e <span class="keyword">and</span> <span class="built_in">pow</span>(<span class="number">2</span>, i ** <span class="number">2</span> - i + <span class="number">5</span>)*<span class="built_in">pow</span>(<span class="number">2</span>, i ** <span class="number">2</span> - i + <span class="number">5</span>) &gt;= e):</span><br><span class="line">        a = i</span><br><span class="line"></span><br><span class="line">s1 = <span class="number">120561</span> </span><br><span class="line">s2 = <span class="number">91903</span></span><br><span class="line"></span><br><span class="line">ab = iroot(N,<span class="number">4</span>)[<span class="number">0</span>] ** <span class="number">4</span></span><br><span class="line">b = -(N-ab-s1*s2)</span><br><span class="line">a = s2</span><br><span class="line">c1 = s1*ab</span><br><span class="line">x = <span class="built_in">int</span>((-b + iroot(b**<span class="number">2</span>-<span class="number">4</span>*a*c1,<span class="number">2</span>)[<span class="number">0</span>]) // (<span class="number">2</span>*a))</span><br><span class="line">p = x + s1</span><br><span class="line">q = N//p</span><br><span class="line"></span><br><span class="line">d = inverse(e//<span class="number">3</span>,p-<span class="number">1</span>)</span><br><span class="line">m3 = <span class="built_in">int</span>(<span class="built_in">pow</span>(c,d,p))</span><br><span class="line"></span><br><span class="line">PR.&lt;x&gt; = Zmod(p)[]</span><br><span class="line">f = x^<span class="number">3</span> - m3</span><br><span class="line">res = f.roots()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> res:</span><br><span class="line">    temp = long_to_bytes(<span class="built_in">int</span>(i[<span class="number">0</span>]))</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">b&quot;DASCTF&quot;</span> <span class="keyword">in</span> temp):</span><br><span class="line">        <span class="built_in">print</span>(temp)</span><br></pre></td></tr></table></figure>
<p>得到flag：</p>
<font color="red">DASCTF{C0nsTruct!n9_Techn1qUe2_f0r_RSA_Pr1me_EnC2ypt10N}</font>

<p><br></p>
<p>当然，这题还有一些值得思考的地方，如若明文的比特位超过了p，又该怎么办？</p>
<p>首先可以先将与p-1、q-1均不互素的素因子用普通RSA解密剔去，得到</p>
<script type="math/tex; mode=display">
\quad c\equiv m^{3*7*7}\quad (mod\;n)</script><p>然后就可以使用AMM算法，但是这时使用AMM算法又有一点特殊，这是因为虽然$7|q-1$，但是49却不整除于q-1，因此无法一次性在模q下开49次方根，而需要先开七次方根，再对7个开出的根再各开7次方根，最后再与模p下开出的3次方根作中国剩余定理求解：</p>
<p>exp.ipynb:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> bytes_to_long,long_to_bytes,inverse</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">c = <span class="number">3232774922192317186963877855543094060264001327534643963164572334193887491269409927593188017108306298404437170754762182875998691872041391981365074638343520234882604136837212457817534624895485767634112947143897465253262932526424371614372553023510973107043735041993637367122527503031768408492566328264574062328255875477737300307769891808134846813311720049466136337129654155946431766445576339564816809841942907193731423184669912783673012406488607834333191988772032942474663985054409518153017182678863504596312351140412943307416458908324209967299195302214349899874812717459558411734343869783905720910923365168671056618</span></span><br><span class="line">p = <span class="number">5213351003420231819415242686664610206224730148063270274863722096379841592931572096469136339538500817713355302889731144789372844731378975059329731297860686270736540109105854515590165681366189003405833252270606896051264517339339578167231093908235856718285980689179840159807651185918046198419707669304960745217</span></span><br><span class="line">q = <span class="number">3891889986375336330559716098591764128742918441309724777337583126578227827768865619689858547513951476952436981068109005313431255086775128227872912287517417948310766208005723508039484956447166240210962374423348694952997002274647622939970550008327647559433222317977926773242269276334110863262269534189811138319</span></span><br><span class="line">n = p*q</span><br><span class="line">e = <span class="number">3</span>*<span class="number">7</span>*<span class="number">7</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">onemod</span>(<span class="params">e, q</span>):</span><br><span class="line">    p = random.randint(<span class="number">1</span>, q-<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">pow</span>(p, (q-<span class="number">1</span>)//e, q) == <span class="number">1</span>):  <span class="comment"># (r,s)=1</span></span><br><span class="line">        p = random.randint(<span class="number">1</span>, q)</span><br><span class="line">    <span class="keyword">return</span> p</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">AMM_rth</span>(<span class="params">o, r, q</span>):  <span class="comment"># r|(q-1</span></span><br><span class="line">    <span class="keyword">assert</span>((q-<span class="number">1</span>) % r == <span class="number">0</span>)</span><br><span class="line">    p = onemod(r, q)</span><br><span class="line"></span><br><span class="line">    t = <span class="number">0</span></span><br><span class="line">    s = q-<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span>(s % r == <span class="number">0</span>):</span><br><span class="line">        s = s//r</span><br><span class="line">        t += <span class="number">1</span></span><br><span class="line">    k = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span>((s*k+<span class="number">1</span>) % r != <span class="number">0</span>):</span><br><span class="line">        k += <span class="number">1</span></span><br><span class="line">    alp = (s*k+<span class="number">1</span>)//r</span><br><span class="line"></span><br><span class="line">    a = <span class="built_in">pow</span>(p, r**(t-<span class="number">1</span>)*s, q)</span><br><span class="line">    b = <span class="built_in">pow</span>(o, r*a-<span class="number">1</span>, q)</span><br><span class="line">    c = <span class="built_in">pow</span>(p, s, q)</span><br><span class="line">    h = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, t-<span class="number">1</span>):</span><br><span class="line">        d = <span class="built_in">pow</span>(<span class="built_in">int</span>(b), r**(t-<span class="number">1</span>-i), q)</span><br><span class="line">        <span class="keyword">if</span> d == <span class="number">1</span>:</span><br><span class="line">            j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            j = (-math.log(d, a)) % r</span><br><span class="line">        b = (b*(c**(r*j))) % q</span><br><span class="line">        h = (h*c**j) % q</span><br><span class="line">        c = (c*r) % q</span><br><span class="line">    result = (<span class="built_in">pow</span>(o, alp, q)*h)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ALL_Solution</span>(<span class="params">m, q, rt, cq, e</span>):</span><br><span class="line">    mp = []</span><br><span class="line">    <span class="keyword">for</span> pr <span class="keyword">in</span> rt:</span><br><span class="line">        r = (pr*m) % q</span><br><span class="line">        <span class="comment"># assert(pow(r, e, q) == cq)</span></span><br><span class="line">        mp.append(r)</span><br><span class="line">    <span class="keyword">return</span> mp</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calc</span>(<span class="params">mp, mq, e, p, q</span>):</span><br><span class="line">    i = <span class="number">1</span></span><br><span class="line">    j = <span class="number">1</span></span><br><span class="line">    t1 = inverse(q, p)</span><br><span class="line">    t2 = inverse(p, q)</span><br><span class="line">    <span class="keyword">for</span> mp1 <span class="keyword">in</span> mp:</span><br><span class="line">        <span class="keyword">for</span> mq1 <span class="keyword">in</span> mq:</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> j % <span class="number">100000</span> == <span class="number">0</span>:</span><br><span class="line">                <span class="built_in">print</span>(j)</span><br><span class="line">            ans = (mp1*t1*q+mq1*t2*p) % (p*q)</span><br><span class="line">            <span class="keyword">if</span> check(ans):</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check</span>(<span class="params">m</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        a = long_to_bytes(m)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">b&#x27;DASCTF&#x27;</span> <span class="keyword">in</span> a <span class="keyword">or</span> <span class="string">b&#x27;flag&#x27;</span> <span class="keyword">in</span> a:</span><br><span class="line">            <span class="built_in">print</span>(a)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ALL_ROOT2</span>(<span class="params">r, q</span>):  <span class="comment"># use function set() and .add() ensure that the generated elements are not repeated</span></span><br><span class="line">    li = <span class="built_in">set</span>()</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">len</span>(li) &lt; r):</span><br><span class="line">        p = <span class="built_in">pow</span>(random.randint(<span class="number">1</span>, q-<span class="number">1</span>), (q-<span class="number">1</span>)//r, q)</span><br><span class="line">        li.add(p)</span><br><span class="line">    <span class="keyword">return</span> li</span><br><span class="line"></span><br><span class="line">cp = c % p</span><br><span class="line">cq = c % q</span><br><span class="line"></span><br><span class="line">mp = AMM_rth(cp, <span class="number">3</span>, p)</span><br><span class="line">mq = AMM_rth(cq, <span class="number">7</span>, q)</span><br><span class="line"></span><br><span class="line">rt1 = ALL_ROOT2(<span class="number">3</span>, p)</span><br><span class="line">rt2 = ALL_ROOT2(<span class="number">7</span>, q)</span><br><span class="line"></span><br><span class="line">amp = ALL_Solution(mp, p, rt1, cp, <span class="number">3</span>)</span><br><span class="line">amq = ALL_Solution(mq, q, rt2, cq, <span class="number">7</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#得到模q下所有根</span></span><br><span class="line">mqs = []</span><br><span class="line"><span class="keyword">for</span> mq <span class="keyword">in</span> amq:</span><br><span class="line">    mqs.append(mq)</span><br><span class="line">amq = mqs</span><br><span class="line">dq = inverse(<span class="number">3</span>, (q-<span class="number">1</span>))</span><br><span class="line">mmqs = []</span><br><span class="line"><span class="keyword">for</span> mq <span class="keyword">in</span> amq:</span><br><span class="line">    mmq = AMM_rth(mq, <span class="number">7</span>, q)</span><br><span class="line"></span><br><span class="line">    rt3 = ALL_ROOT2(<span class="number">7</span>, q)</span><br><span class="line"></span><br><span class="line">    mamq = ALL_Solution(mmq, q, rt3, mq, <span class="number">7</span>)</span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> mamq:</span><br><span class="line">        mmqs.append(<span class="built_in">int</span>(<span class="built_in">pow</span>(t,dq,q)))</span><br><span class="line">amq = mmqs</span><br><span class="line"></span><br><span class="line"><span class="comment">#得到模p下所有根</span></span><br><span class="line">dp = inverse(<span class="number">49</span>, (p-<span class="number">1</span>))</span><br><span class="line">mps = []</span><br><span class="line"><span class="keyword">for</span> mp <span class="keyword">in</span> amp:</span><br><span class="line">    mps.append(<span class="built_in">int</span>(<span class="built_in">pow</span>(mp, dp, p)))</span><br><span class="line">amp = mps</span><br><span class="line"></span><br><span class="line">calc(amp, amq, e, p, q)</span><br></pre></td></tr></table></figure>
<p>而简便一点，直接解有限域下的方程也是可行的：</p>
<p>exp.ipynb:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> bytes_to_long,long_to_bytes,inverse</span><br><span class="line"><span class="keyword">from</span> sympy.ntheory.modular <span class="keyword">import</span> crt</span><br><span class="line"><span class="comment">#使用如：M = crt(n,c)[0]</span></span><br><span class="line"></span><br><span class="line">c = <span class="number">3232774922192317186963877855543094060264001327534643963164572334193887491269409927593188017108306298404437170754762182875998691872041391981365074638343520234882604136837212457817534624895485767634112947143897465253262932526424371614372553023510973107043735041993637367122527503031768408492566328264574062328255875477737300307769891808134846813311720049466136337129654155946431766445576339564816809841942907193731423184669912783673012406488607834333191988772032942474663985054409518153017182678863504596312351140412943307416458908324209967299195302214349899874812717459558411734343869783905720910923365168671056618</span></span><br><span class="line">p = <span class="number">5213351003420231819415242686664610206224730148063270274863722096379841592931572096469136339538500817713355302889731144789372844731378975059329731297860686270736540109105854515590165681366189003405833252270606896051264517339339578167231093908235856718285980689179840159807651185918046198419707669304960745217</span></span><br><span class="line">q = <span class="number">3891889986375336330559716098591764128742918441309724777337583126578227827768865619689858547513951476952436981068109005313431255086775128227872912287517417948310766208005723508039484956447166240210962374423348694952997002274647622939970550008327647559433222317977926773242269276334110863262269534189811138319</span></span><br><span class="line">n = p*q</span><br><span class="line">e = <span class="number">3</span>*<span class="number">7</span>*<span class="number">7</span></span><br><span class="line"></span><br><span class="line">dp = inverse(<span class="number">49</span>,p-<span class="number">1</span>)</span><br><span class="line">cp = <span class="built_in">pow</span>(c,dp,p)</span><br><span class="line">PR.&lt;x&gt; = Zmod(p)[]</span><br><span class="line">f = x^<span class="number">3</span> - cp</span><br><span class="line">resp = f.roots()</span><br><span class="line"></span><br><span class="line">dq = inverse(<span class="number">3</span>,q-<span class="number">1</span>)</span><br><span class="line">cq = <span class="built_in">pow</span>(c,dq,q)</span><br><span class="line">PR.&lt;x&gt; = Zmod(q)[]</span><br><span class="line">f = x^<span class="number">49</span> - cq</span><br><span class="line">resq = f.roots()</span><br><span class="line"></span><br><span class="line">modlist = [p,q]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> resp:</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> resq:</span><br><span class="line">        c = [<span class="built_in">int</span>(i[<span class="number">0</span>]),<span class="built_in">int</span>(j[<span class="number">0</span>])]</span><br><span class="line">        m = crt(modlist,c)[<span class="number">0</span>]</span><br><span class="line">        temp = long_to_bytes(m)</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">b&quot;DASCTF&quot;</span> <span class="keyword">in</span> temp):</span><br><span class="line">            <span class="built_in">print</span>(temp)</span><br></pre></td></tr></table></figure>
<p>多种方法求解，也是为了能更灵活的思考问题，掌握更多求解方式，让自己一种方法卡住时，可以有路可走。</p>
<p><br></p>
<p><br></p>
<p><br></p>
<h2 id="Easy-3L"><a href="#Easy-3L" class="headerlink" title="Easy_3L"></a>Easy_3L</h2><p>题目描述：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">无</span><br></pre></td></tr></table></figure>
<p>题目：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag</span><br><span class="line"></span><br><span class="line">m = bytes_to_long(flag)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_key</span>():</span><br><span class="line">    p = getPrime(<span class="number">1400</span>)</span><br><span class="line">    f = getRandomNBitInteger(<span class="number">1024</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        q = getPrime(<span class="number">512</span>)</span><br><span class="line">        <span class="keyword">if</span> gcd(f, q) != <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    h = (invert(f, p) * q) % p</span><br><span class="line">    <span class="keyword">return</span> p, h</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encrypt1</span>(<span class="params">m</span>):</span><br><span class="line">    a = getPrime(<span class="number">250</span>)</span><br><span class="line">    b = getRandomNBitInteger(<span class="number">240</span>)</span><br><span class="line">    n = getPrime(<span class="number">512</span>)</span><br><span class="line">    seed = m</span><br><span class="line">    s = [<span class="number">0</span>] * <span class="number">6</span></span><br><span class="line">    s[<span class="number">0</span>] = seed</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">6</span>):</span><br><span class="line">        s[i] = (s[i - <span class="number">1</span>] * a + b) % n</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encrypt2</span>(<span class="params">msg, p, h</span>):</span><br><span class="line">    s = getRandomNBitInteger(<span class="number">512</span>)</span><br><span class="line">    c = (s * h + msg) % p</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s = encrypt1(m)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;S1 =&quot;</span>, s[<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;S2 =&quot;</span>, s[<span class="number">2</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;S4 =&quot;</span>, s[<span class="number">4</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;S5 =&quot;</span>, s[<span class="number">5</span>])</span><br><span class="line"></span><br><span class="line">p, h = get_key()</span><br><span class="line">c = encrypt2(s[<span class="number">3</span>], p, h)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;p =&quot;</span>, p)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;h =&quot;</span>, h)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;c =&quot;</span>, c)</span><br><span class="line"></span><br><span class="line"><span class="comment"># S1 = 28572152986082018877402362001567466234043851789360735202177142484311397443337910028526704343260845684960897697228636991096551426116049875141</span></span><br><span class="line"><span class="comment"># S2 = 1267231041216362976881495706209012999926322160351147349200659893781191687605978675590209327810284956626443266982499935032073788984220619657447889609681888</span></span><br><span class="line"><span class="comment"># S4 = 9739918644806242673966205531575183334306589742344399829232076845951304871478438938119813187502023845332528267974698273405630514228632721928260463654612997</span></span><br><span class="line"><span class="comment"># S5 = 9755668823764800147393276745829186812540710004256163127825800861195296361046987938775181398489372822667854079119037446327498475937494635853074634666112736</span></span><br><span class="line"><span class="comment"># p = 25886434964719448194352673440525701654705794467884891063997131230558866479588298264578120588832128279435501897537203249743883076992668855905005985050222145380285378634993563571078034923112985724204131887907198503097115380966366598622251191576354831935118147880783949022370177789175320661630501595157946150891275992785113199863734714343650596491139321990230671901990010723398037081693145723605154355325074739107535905777351</span></span><br><span class="line"><span class="comment"># h = 2332673914418001018316159191702497430320194762477685969994411366563846498561222483921873160125818295447435796015251682805613716554577537183122368080760105458908517619529332931042168173262127728892648742025494771751133664547888267249802368767396121189473647263861691578834674578112521646941677994097088669110583465311980605508259404858000937372665500663077299603396786862387710064061811000146453852819607311367850587534711</span></span><br><span class="line"><span class="comment"># c = 20329058681057003355767546524327270876901063126285410163862577312957425318547938475645814390088863577141554443432653658287774537679738768993301095388221262144278253212238975358868925761055407920504398004143126310247822585095611305912801250788531962681592054588938446210412897150782558115114462054815460318533279921722893020563472010279486838372516063331845966834180751724227249589463408168677246991839581459878242111459287</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题目的3L显然指的是LLL算法，加密过程分为两层：</p>
<ul>
<li>LCG加密种子flag</li>
<li>NTRU加密LCG的S3</li>
</ul>
<p>那么解题思路也很清晰，先解决NTRU解出S3，进而恢复LCG的种子即可。</p>
<p>本题你会发现要规约出的向量(f,g)数量级好像差的有点多，很难规约出1024比特的f，但是不重要，f是否为原始值对于解密影响并不大，只需要检查S3的数量级正常即可。(正常来说，为使规约后的向量比特相近，应在第二列乘上2^512，使 f 与 (2^512)*g具有相同数量级，但本题中这是解不出来的，因此可以采用爆破手段，会发现有很多短向量f、g均可以用于解密，这也符合NTRU的密钥特性)</p>
<p>解出S3后是个简单的LCG问题，不再赘述。</p>
<p>exp.ipynb：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = <span class="number">25886434964719448194352673440525701654705794467884891063997131230558866479588298264578120588832128279435501897537203249743883076992668855905005985050222145380285378634993563571078034923112985724204131887907198503097115380966366598622251191576354831935118147880783949022370177789175320661630501595157946150891275992785113199863734714343650596491139321990230671901990010723398037081693145723605154355325074739107535905777351</span></span><br><span class="line">h = <span class="number">2332673914418001018316159191702497430320194762477685969994411366563846498561222483921873160125818295447435796015251682805613716554577537183122368080760105458908517619529332931042168173262127728892648742025494771751133664547888267249802368767396121189473647263861691578834674578112521646941677994097088669110583465311980605508259404858000937372665500663077299603396786862387710064061811000146453852819607311367850587534711</span></span><br><span class="line">c = <span class="number">20329058681057003355767546524327270876901063126285410163862577312957425318547938475645814390088863577141554443432653658287774537679738768993301095388221262144278253212238975358868925761055407920504398004143126310247822585095611305912801250788531962681592054588938446210412897150782558115114462054815460318533279921722893020563472010279486838372516063331845966834180751724227249589463408168677246991839581459878242111459287</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dec</span>(<span class="params">S3</span>):</span><br><span class="line">    S1 = <span class="number">28572152986082018877402362001567466234043851789360735202177142484311397443337910028526704343260845684960897697228636991096551426116049875141</span></span><br><span class="line">    S2 = <span class="number">1267231041216362976881495706209012999926322160351147349200659893781191687605978675590209327810284956626443266982499935032073788984220619657447889609681888</span></span><br><span class="line">    S4 = <span class="number">9739918644806242673966205531575183334306589742344399829232076845951304871478438938119813187502023845332528267974698273405630514228632721928260463654612997</span></span><br><span class="line">    S5 = <span class="number">9755668823764800147393276745829186812540710004256163127825800861195296361046987938775181398489372822667854079119037446327498475937494635853074634666112736</span></span><br><span class="line"></span><br><span class="line">    x = [S1, S2, S3, S4, S5]</span><br><span class="line">    t = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(x)):</span><br><span class="line">        t.append(x[i] - x[i-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">    m = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(t)-<span class="number">1</span>):</span><br><span class="line">        m = GCD(t[i+<span class="number">1</span>]*t[i-<span class="number">1</span>] - t[i]*t[i], m)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> sieve_base:</span><br><span class="line">        <span class="keyword">while</span> m % p == <span class="number">0</span>: m //= p</span><br><span class="line">    <span class="keyword">assert</span> isPrime(m)</span><br><span class="line"></span><br><span class="line">    a = (S3 - S2) * inverse(S2 - S1, m)</span><br><span class="line">    b = (S2 - a*S1) % m</span><br><span class="line"></span><br><span class="line">    S1 = (S1-b)*inverse(a, m) % m</span><br><span class="line">    flag = long_to_bytes(S1)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">b&#x27;DASCTF&#x27;</span> <span class="keyword">in</span> flag:</span><br><span class="line">        <span class="built_in">print</span>(flag)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> e <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">1000</span>):</span><br><span class="line">    L = Matrix(ZZ, [[<span class="number">1</span>, (<span class="number">2</span>**e)*h],</span><br><span class="line">                    [<span class="number">0</span>, (<span class="number">2</span>**e)*p]])</span><br><span class="line">    f, g = L.LLL()[<span class="number">0</span>]</span><br><span class="line">    g = g  // (<span class="number">2</span>**e)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        S3 = (f*c) % p % g * inverse(f, g) % g</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">len</span>(<span class="built_in">bin</span>(S3)) == <span class="number">514</span>):</span><br><span class="line">            dec(S3)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>得到flag：</p>
<font color="red">DASCTF{NTRU_L0G_a6e_S1mpLe}</font>

<p><br></p>
<p><br></p>
<p><br></p>
<h2 id="SigninCrypto"><a href="#SigninCrypto" class="headerlink" title="SigninCrypto"></a>SigninCrypto</h2><p>题目描述：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">随机数真随机吗？如随！</span><br></pre></td></tr></table></figure>
<p>题目：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> DES3</span><br><span class="line"><span class="keyword">from</span> flag <span class="keyword">import</span> flag</span><br><span class="line"><span class="keyword">from</span> key <span class="keyword">import</span> key</span><br><span class="line"><span class="keyword">from</span> iv <span class="keyword">import</span> iv</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> secrets</span><br><span class="line"></span><br><span class="line">K1= key</span><br><span class="line">hint1 = os.urandom(<span class="number">2</span>) * <span class="number">8</span></span><br><span class="line">xor =bytes_to_long(hint1)^bytes_to_long(K1)</span><br><span class="line"><span class="built_in">print</span>(xor)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Rand</span>():</span><br><span class="line">    rseed = secrets.randbits(<span class="number">1024</span>)</span><br><span class="line">    List1 = []</span><br><span class="line">    List2 = []</span><br><span class="line">    seed(rseed)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">624</span>):</span><br><span class="line">        rand16 = getrandbits(<span class="number">16</span>)</span><br><span class="line">        List1.append(rand16)</span><br><span class="line">    seed(rseed)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">312</span>):</span><br><span class="line">        rand64 = getrandbits(<span class="number">64</span>)</span><br><span class="line">        List2.append(rand64)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;task.txt&quot;</span>, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> file:</span><br><span class="line">        <span class="keyword">for</span> rand16 <span class="keyword">in</span> List1:</span><br><span class="line">            file.write(<span class="built_in">hex</span>(rand16)+ <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> rand64 <span class="keyword">in</span> List2:</span><br><span class="line">            file.write(<span class="built_in">hex</span>((rand64 &amp; <span class="number">0xffff</span>) | ((rand64 &gt;&gt; <span class="number">32</span>) &amp; <span class="number">0xffff</span>) &lt;&lt; <span class="number">16</span>) + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">Rand()</span><br><span class="line"></span><br><span class="line">K2 = long_to_bytes(getrandbits(<span class="number">64</span>))</span><br><span class="line">K3 = flag[:<span class="number">8</span>]</span><br><span class="line"></span><br><span class="line">KEY = K1 + K2 + K3</span><br><span class="line"></span><br><span class="line">IV=iv</span><br><span class="line"></span><br><span class="line">IV1=IV[:<span class="built_in">len</span>(IV)//<span class="number">2</span>]</span><br><span class="line">IV2=IV[<span class="built_in">len</span>(IV)//<span class="number">2</span>:]</span><br><span class="line"></span><br><span class="line">digest1 = hashlib.sha512(IV1).digest().<span class="built_in">hex</span>()</span><br><span class="line">digest2 = hashlib.sha512(IV2).digest().<span class="built_in">hex</span>()</span><br><span class="line"></span><br><span class="line">digest=digest1+digest2</span><br><span class="line">hint2=(bytes_to_long(IV)&lt;&lt;<span class="number">32</span>)^bytes_to_long(os.urandom(<span class="number">8</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(bytes_to_long((digest.encode()))))</span><br><span class="line"><span class="built_in">print</span>(hint2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mode = DES3.MODE_CBC</span><br><span class="line">des3 = DES3.new(KEY, mode, IV)</span><br><span class="line"></span><br><span class="line">pad_len = <span class="number">8</span> - <span class="built_in">len</span>(flag) % <span class="number">8</span></span><br><span class="line">padding = <span class="built_in">bytes</span>([pad_len]) * pad_len</span><br><span class="line">flag += padding</span><br><span class="line"></span><br><span class="line">cipher = des3.encrypt(flag)</span><br><span class="line"></span><br><span class="line">ciphertext=cipher.<span class="built_in">hex</span>()</span><br><span class="line"><span class="built_in">print</span>(ciphertext)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 334648638865560142973669981316964458403</span></span><br><span class="line"><span class="comment"># 0x62343937373634656339396239663236643437363738396663393438316230353665353733303939613830616662663633326463626431643139323130616333363363326631363235313661656632636265396134336361623833636165373964343533666537663934646239396462323666316236396232303539336438336234393737363465633939623966323664343736373839666339343831623035366535373330393961383061666266363332646362643164313932313061633336336332663136323531366165663263626539613433636162383363616537396434353366653766393464623939646232366631623639623230353933643833</span></span><br><span class="line"><span class="comment"># 22078953819177294945130027344</span></span><br><span class="line"><span class="comment"># a6546bd93bced0a8533a5039545a54d1fee647007df106612ba643ffae850e201e711f6e193f15d2124ab23b250bd6e1</span></span><br></pre></td></tr></table></figure>
<p>可以发现，题目最终用3DES对flag进行了加密，因此目标就是还原3DES的key与iv即可。</p>
<p>其中，两个量分别分为了以下几部分：</p>
<ul>
<li>KEY = K1 + K2 + K3 ,每个部分大小8字节</li>
<li>IV=iv，每个部分大小4字节</li>
</ul>
<p>按照如下方式逐步还原每个部分：</p>
<p><strong>K1</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">K1= key</span><br><span class="line">hint1 = os.urandom(2) * 8</span><br><span class="line">xor =bytes_to_long(hint1)^bytes_to_long(K1)</span><br><span class="line">print(xor)</span><br></pre></td></tr></table></figure>
<p>hint1为16字节量，而K1为8字节量，因此xor的高位即为hint1的高位，又因为hint1由重复字节构成，hint1高位与低位相等。得到完整hint1后与xor异或即得K1</p>
<p><strong>K2</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">Rand</span>():</span><br><span class="line">    rseed = secrets.randbits(<span class="number">1024</span>)</span><br><span class="line">    List1 = []</span><br><span class="line">    List2 = []</span><br><span class="line">    seed(rseed)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">624</span>):</span><br><span class="line">        rand16 = getrandbits(<span class="number">16</span>)</span><br><span class="line">        List1.append(rand16)</span><br><span class="line">    seed(rseed)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">312</span>):</span><br><span class="line">        rand64 = getrandbits(<span class="number">64</span>)</span><br><span class="line">        List2.append(rand64)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;task.txt&quot;</span>, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> file:</span><br><span class="line">        <span class="keyword">for</span> rand16 <span class="keyword">in</span> List1:</span><br><span class="line">            file.write(<span class="built_in">hex</span>(rand16)+ <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> rand64 <span class="keyword">in</span> List2:</span><br><span class="line">            file.write(<span class="built_in">hex</span>((rand64 &amp; <span class="number">0xffff</span>) | ((rand64 &gt;&gt; <span class="number">32</span>) &amp; <span class="number">0xffff</span>) &lt;&lt; <span class="number">16</span>) + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">Rand()</span><br><span class="line"></span><br><span class="line">K2 = long_to_bytes(getrandbits(<span class="number">64</span>))</span><br></pre></td></tr></table></figure>
<p>考察的是MT19937伪随机数生成，利用randcrack模块，提交624个32bit数，即可对之后的随机数进行精准预测。而注意到生成List1、List2之间重新调整了一次随机数种子，因此List1、List2是使用同一随机数种子生成的。</p>
<p>而注意到，List1仅有$624<em>16$bit，List2却有$324</em>64 = 624*32$bit，因此List2生成的位数是足够的，而最终task.txt文本中却只给了List2的部分字节，不需要深究原理也能明白：List1生成的字节恰好就是List2生成的随机数中缺失的字节。因此只需要每种补充方式均尝试一下即可得到K2。</p>
<p><strong>K3</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">K3 = flag[:<span class="number">8</span>]</span><br></pre></td></tr></table></figure>
<p>很显然，因为flag一般以DASCTF{开头，因此只需要爆破一个可见字符即可得到正确K3。</p>
<p><strong>IV1及IV2</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">IV1=IV[:<span class="built_in">len</span>(IV)//<span class="number">2</span>]</span><br><span class="line">IV2=IV[<span class="built_in">len</span>(IV)//<span class="number">2</span>:]</span><br><span class="line"></span><br><span class="line">digest1 = hashlib.sha512(IV1).digest().<span class="built_in">hex</span>()</span><br><span class="line">digest2 = hashlib.sha512(IV2).digest().<span class="built_in">hex</span>()</span><br><span class="line"></span><br><span class="line">digest=digest1+digest2</span><br><span class="line">hint2=(bytes_to_long(IV)&lt;&lt;<span class="number">32</span>)^bytes_to_long(os.urandom(<span class="number">8</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(bytes_to_long((digest.encode()))))</span><br><span class="line"><span class="built_in">print</span>(hint2)</span><br></pre></td></tr></table></figure>
<p>首先明确IV一共8个字节，因此hint2的高位即为IV1，此时题目的几个哈希值貌似给了一个暗示：爆破求解IV2.可是需要爆破的量有4个字节，虽然不能说很大，却也需要很长时间。此时就需要注意到，digest=digest1+digest2这一行，并不是数值的相加，而是字符串的连接，而当你将digest解码后，你会发现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">digest1 = digest2</span><br></pre></td></tr></table></figure>
<p>没错，太幽默了，所以IV2与IV1相同(基本无需考虑哈希碰撞)</p>
<p>此时所有量都得到了还原，解密3DES即可：</p>
<p>exp.py：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> DES3</span><br><span class="line"><span class="keyword">from</span> randcrack <span class="keyword">import</span> RandCrack</span><br><span class="line"></span><br><span class="line">rc = RandCrack()</span><br><span class="line"></span><br><span class="line">cipher = <span class="built_in">int</span>(<span class="string">&quot;a6546bd93bced0a8533a5039545a54d1fee647007df106612ba643ffae850e201e711f6e193f15d2124ab23b250bd6e1&quot;</span>,<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#获取iv</span></span><br><span class="line">hint2 = <span class="number">22078953819177294945130027344</span></span><br><span class="line">IV1 = long_to_bytes(hint2 &gt;&gt; <span class="number">64</span>)</span><br><span class="line">IV2 = IV1</span><br><span class="line"></span><br><span class="line"><span class="comment">#获取K2</span></span><br><span class="line">list1 = []</span><br><span class="line">list2 = []</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;task.txt&quot;</span>, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">624</span>):</span><br><span class="line">        list1.append(<span class="built_in">int</span>(f.readline(),<span class="number">16</span>))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">312</span>):</span><br><span class="line">        list2.append(<span class="built_in">int</span>(f.readline(),<span class="number">16</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">312</span>):</span><br><span class="line">    t1 = (list2[i] &amp; <span class="number">0xffff</span>)</span><br><span class="line">    t2 = ((list2[i] &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xffff</span>)</span><br><span class="line">    rc.submit( (list1[<span class="number">2</span>*i]&lt;&lt;<span class="number">16</span>) | (list2[i] &amp; <span class="number">0xffff</span>))</span><br><span class="line">    rc.submit( (list1[<span class="number">2</span>*i+<span class="number">1</span>]&lt;&lt;<span class="number">16</span>) | ((list2[i] &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xffff</span>))</span><br><span class="line">K2 = long_to_bytes(rc.predict_getrandbits(<span class="number">64</span>),<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#爆破k3</span></span><br><span class="line">xor = <span class="number">334648638865560142973669981316964458403</span></span><br><span class="line">K1 = (xor ^ (xor&gt;&gt;<span class="number">64</span>)) &amp; <span class="number">0xffffffffffffffff</span></span><br><span class="line">K1 = long_to_bytes(K1)</span><br><span class="line"></span><br><span class="line">temp = bytes_to_long(<span class="string">b&quot;DASCTF&#123;&quot;</span>) &lt;&lt; <span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>**<span class="number">8</span>):</span><br><span class="line">    K3 = long_to_bytes(temp + j)</span><br><span class="line">    KEY = K1 + K2 + K3</span><br><span class="line">    IV = IV1 + IV2</span><br><span class="line"></span><br><span class="line">    mode = DES3.MODE_CBC</span><br><span class="line">    des3 = DES3.new(KEY, mode, IV)</span><br><span class="line">    flag = <span class="built_in">str</span>(des3.decrypt(long_to_bytes(cipher)))</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">&quot;DASCTF&quot;</span> <span class="keyword">in</span> flag):</span><br><span class="line">        <span class="built_in">print</span>(flag)</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
<p>得到flag：</p>
<font color="red">DASCTF{8e5ee461-f4e1-4af2-8632-c9d62f4dc073}</font>

<p><br></p>
<p><br></p>
<p><br></p>
<h2 id="esyRSA"><a href="#esyRSA" class="headerlink" title="esyRSA"></a>esyRSA</h2><p>题目描述：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">好像这个RSA有点怪啊！私钥给你了！我的e呢？</span><br></pre></td></tr></table></figure>
<p>题目：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> invert</span><br><span class="line"><span class="keyword">from</span> md5 <span class="keyword">import</span> md5</span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> p, q</span><br><span class="line"></span><br><span class="line">e = ?????</span><br><span class="line">n = p*q</span><br><span class="line">phi = (p-<span class="number">1</span>)*(q-<span class="number">1</span>)</span><br><span class="line">d = invert(e, phi)</span><br><span class="line">ans = gcd(e,phi)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> n, e, d</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;Flag: DASCTF&#123;%s&#125;&quot;</span> %md5(<span class="built_in">str</span>(p + q)).hexdigest()</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">n = 8064259277274639864655809758868795854117113170423331934498023294296505063511386001711751916634810056911517464467899780578338013011453082479880809823762824723657495915284790349150975180933698827382368698861967973964030509129133021116919437755292590841218316278732797712538885232908975173746394816520256585937380642592772746398646558097588687958541171131704233319344980232942965050635113860017117519166348100569115174644678997805783380130114530824798808098237628247236574959152847903491509751809336988273823686988619679739640305091291330211169194377552925908412183162787327977125388852329089751737463948165202565859373</span></span><br><span class="line"><span class="string">d = 14218766449983537783699024084862960813708451888387858392014856544340557703876299258990323621963898510226357248200187173211121827541826897886277531706124228848229095880229718049075745233893843373402201077890407507625110061976931591596708901741146750809962128820611844426759462132623616118530705745098783140913</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<p>无力吐槽。。。这题附件锅了，n是两个重复的大整数拼起来的，因此要先取一半当作正确的n。之后的做法就多了，d过大可以考虑wiener或构造格，但是题目给了e为五位数的暗示，因此也只需要爆破一下e，当作已知e、d分解n即可。</p>
<p>exp.py:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"></span><br><span class="line">n = <span class="string">&quot;8064259277274639864655809758868795854117113170423331934498023294296505063511386001711751916634810056911517464467899780578338013011453082479880809823762824723657495915284790349150975180933698827382368698861967973964030509129133021116919437755292590841218316278732797712538885232908975173746394816520256585937380642592772746398646558097588687958541171131704233319344980232942965050635113860017117519166348100569115174644678997805783380130114530824798808098237628247236574959152847903491509751809336988273823686988619679739640305091291330211169194377552925908412183162787327977125388852329089751737463948165202565859373&quot;</span></span><br><span class="line">n = <span class="number">80642592772746398646558097588687958541171131704233319344980232942965050635113860017117519166348100569115174644678997805783380130114530824798808098237628247236574959152847903491509751809336988273823686988619679739640305091291330211169194377552925908412183162787327977125388852329089751737463948165202565859373</span></span><br><span class="line">d = <span class="number">14218766449983537783699024084862960813708451888387858392014856544340557703876299258990323621963898510226357248200187173211121827541826897886277531706124228848229095880229718049075745233893843373402201077890407507625110061976931591596708901741146750809962128820611844426759462132623616118530705745098783140913</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> e <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10000</span>,<span class="number">100000</span>):</span><br><span class="line">    t = e*d - <span class="number">1</span></span><br><span class="line">    s = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> t % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        s += <span class="number">1</span></span><br><span class="line">        t //= <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    found = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, s):</span><br><span class="line">        c1 = <span class="built_in">pow</span>(<span class="number">2</span>, <span class="built_in">pow</span>(<span class="number">2</span>, i-<span class="number">1</span>, n)*t, n)</span><br><span class="line">        c2 = <span class="built_in">pow</span>(<span class="number">2</span>, <span class="built_in">pow</span>(<span class="number">2</span>, i, n)*t, n)</span><br><span class="line">        <span class="keyword">if</span> c1 != <span class="number">1</span> <span class="keyword">and</span> c1 != (-<span class="number">1</span> % n) <span class="keyword">and</span> c2 == <span class="number">1</span>:</span><br><span class="line">            p = GCD(c1 - <span class="number">1</span>, n)</span><br><span class="line">            q = n // p</span><br><span class="line">            <span class="built_in">print</span> (<span class="string">&quot;Flag: DASCTF&#123;%s&#125;&quot;</span> %hashlib.md5(<span class="built_in">str</span>(p + q).encode()).hexdigest())</span><br><span class="line">            exit()   </span><br></pre></td></tr></table></figure>
<p>得到flag：</p>
<font color="red">DASCTF{4ae33bea90f030bfddb7ac4d9222ef8f}</font>

<p>(<del>为什么主办方没有发现附件需要更新</del>？/(ㄒoㄒ)/~~)</p>
<p><br></p>
<p><br></p>
<p><br></p>
<h2 id="MCeorpkpleer"><a href="#MCeorpkpleer" class="headerlink" title="MCeorpkpleer"></a>MCeorpkpleer</h2><p>题目描述：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">这数据都不全要怎么计算呢</span><br></pre></td></tr></table></figure>
<p>题目：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pubkey</span>(<span class="params"><span class="built_in">list</span>, m, w</span>):</span><br><span class="line">    pubkey_list = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(e_bin)):</span><br><span class="line">        pubkey_list.append(w * <span class="built_in">list</span>[i] % m)</span><br><span class="line">    <span class="keyword">return</span> pubkey_list</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">e_cry</span>(<span class="params">e, pubkey</span>):</span><br><span class="line">    pubkey_list = pubkey</span><br><span class="line">    encode = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(e)):</span><br><span class="line">        encode += pubkey_list[i] * <span class="built_in">int</span>(e[i]) % m</span><br><span class="line">    <span class="keyword">return</span> encode</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p = getPrime(<span class="number">1024</span>)</span><br><span class="line">q = getPrime(<span class="number">1024</span>)</span><br><span class="line">n = p * q</span><br><span class="line">e = getPrime(<span class="number">64</span>)</span><br><span class="line">m = bytes_to_long(flag)</span><br><span class="line">c = <span class="built_in">pow</span>(m, e, n)</span><br><span class="line"></span><br><span class="line">e_bin = (<span class="built_in">bin</span>(e))[<span class="number">2</span>:]</span><br><span class="line"><span class="built_in">list</span> = [<span class="built_in">pow</span>(<span class="number">3</span>, i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(e_bin))]</span><br><span class="line">m = getPrime(<span class="built_in">len</span>(<span class="built_in">bin</span>(<span class="built_in">sum</span>(<span class="built_in">list</span>))) - <span class="number">1</span>)</span><br><span class="line">w = getPrime(<span class="number">64</span>)</span><br><span class="line">pubkey = pubkey(<span class="built_in">list</span>, m, w)</span><br><span class="line">en_e = e_cry(e_bin, pubkey)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;p = &#123;&#125;\n&#x27;</span></span><br><span class="line">      <span class="string">&#x27;n = &#123;&#125;\n&#x27;</span></span><br><span class="line">      <span class="string">&#x27;c = &#123;&#125;\n&#x27;</span></span><br><span class="line">      <span class="string">&#x27;pubkey = &#123;&#125;\n&#x27;</span></span><br><span class="line">      <span class="string">&#x27;en_e = &#123;&#125;&#x27;</span>.<span class="built_in">format</span>((p &gt;&gt; <span class="number">435</span>) &lt;&lt; <span class="number">435</span>, n, c, pubkey, en_e))</span><br></pre></td></tr></table></figure>
<p>观察题目，e_cry用于背包加密的就是e的二进制串本身，因此直接格基规约出e，再用coppersmith解已知p高位问题即可。</p>
<p>exp.ipynb：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#step1 已知p高位，恢复p、q</span></span><br><span class="line">p4 = <span class="number">139540788452365306201344680691061363403552933527922544113532931871057569249632300961012384092481349965600565669315386312075890938848151802133991344036696488204791984307057923179655351110456639347861739783538289295071556484465877192913103980697449775104351723521120185802327587352171892429135110880845830815744</span></span><br><span class="line">n = <span class="number">22687275367292715121023165106670108853938361902298846206862771935407158965874027802803638281495587478289987884478175402963651345721058971675312390474130344896656045501040131613951749912121302307319667377206302623735461295814304029815569792081676250351680394603150988291840152045153821466137945680377288968814340125983972875343193067740301088120701811835603840224481300390881804176310419837493233326574694092344562954466888826931087463507145512465506577802975542167456635224555763956520133324723112741833090389521889638959417580386320644108693480886579608925996338215190459826993010122431767343984393826487197759618771</span></span><br><span class="line">pbits = <span class="number">1024</span></span><br><span class="line">kbits= <span class="number">435</span></span><br><span class="line">PR.&lt;x&gt; = PolynomialRing(Zmod(n))</span><br><span class="line">f = x + p4</span><br><span class="line">roots = f.small_roots(X=<span class="number">2</span>^kbits,beta=<span class="number">0.4</span>)</span><br><span class="line"><span class="keyword">if</span> roots:</span><br><span class="line">    p= p4 + <span class="built_in">int</span>(roots[<span class="number">0</span>])</span><br><span class="line">    q = n//p</span><br><span class="line"></span><br><span class="line"><span class="comment">#step2 格基规约恢复e</span></span><br><span class="line">b = [<span class="number">18143710780782459577</span>, <span class="number">54431132342347378731</span>, <span class="number">163293397027042136193</span>, <span class="number">489880191081126408579</span>, <span class="number">1469640573243379225737</span>, <span class="number">4408921719730137677211</span>, <span class="number">13226765159190413031633</span>, <span class="number">39680295477571239094899</span>, <span class="number">119040886432713717284697</span>, <span class="number">357122659298141151854091</span>, <span class="number">1071367977894423455562273</span>, <span class="number">3214103933683270366686819</span>, <span class="number">9642311801049811100060457</span>, <span class="number">28926935403149433300181371</span>, <span class="number">86780806209448299900544113</span>, <span class="number">260342418628344899701632339</span>, <span class="number">781027255885034699104897017</span>, <span class="number">2343081767655104097314691051</span>, <span class="number">7029245302965312291944073153</span>, <span class="number">21087735908895936875832219459</span>, <span class="number">63263207726687810627496658377</span>, <span class="number">189789623180063431882489975131</span>, <span class="number">569368869540190295647469925393</span>, <span class="number">1708106608620570886942409776179</span>, <span class="number">601827224419797931380408071500</span>, <span class="number">1805481673259393794141224214500</span>, <span class="number">893952418336266652976851386463</span>, <span class="number">2681857255008799958930554159389</span>, <span class="number">3523079163584485147344841221130</span>, <span class="number">1524252287869625983140881149316</span>, <span class="number">50264262166963219975822190911</span>, <span class="number">150792786500889659927466572733</span>, <span class="number">452378359502668979782399718199</span>, <span class="number">1357135078508006939347199154597</span>, <span class="number">4071405235524020818041597463791</span>, <span class="number">3169230503688232995231149877299</span>, <span class="number">462706308180869526799807117823</span>, <span class="number">1388118924542608580399421353469</span>, <span class="number">4164356773627825741198264060407</span>, <span class="number">3448085117999647764701149667147</span>, <span class="number">1299270151115113835209806487367</span>, <span class="number">3897810453345341505629419462101</span>, <span class="number">2648446157152195057994615872229</span>, <span class="number">3422845870014670444537026359650</span>, <span class="number">1223552407160181874717436564876</span>, <span class="number">3670657221480545624152309694628</span>, <span class="number">1966986461557807413563286569810</span>, <span class="number">1378466783231507511243038452393</span>, <span class="number">4135400349694522533729115357179</span>, <span class="number">3361215846199738142293703557463</span>, <span class="number">1038662335715384967987468158315</span>, <span class="number">3115987007146154903962404474945</span>, <span class="number">302975818554635252993570910761</span>, <span class="number">908927455663905758980712732283</span>, <span class="number">2726782366991717276942138196849</span>, <span class="number">3657854499533237101379593333510</span>, <span class="number">1928578295715881845245137486456</span>, <span class="number">1263242285705730806288591202331</span>, <span class="number">3789726857117192418865773606993</span>, <span class="number">2324195368467747797703678306905</span>, <span class="number">2450093503961328663664213663678</span>, <span class="number">2827787910442071261545819733997</span>, <span class="number">3960871129884299055190637944954</span>, <span class="number">2837628186769067706678271320788</span>]</span><br><span class="line">c = <span class="number">31087054322877663244023458448558</span></span><br><span class="line"></span><br><span class="line">n = <span class="built_in">len</span>(b)</span><br><span class="line">L = Matrix(ZZ, n+<span class="number">1</span>, n+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    L[i,i] = <span class="number">1</span></span><br><span class="line">    L[i,-<span class="number">1</span>] = b[i]</span><br><span class="line">L[-<span class="number">1</span>,-<span class="number">1</span>] = -c</span><br><span class="line"></span><br><span class="line">res = L.LLL()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>):</span><br><span class="line">    M = res.row(i).<span class="built_in">list</span>()</span><br><span class="line">    flag = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">for</span> m <span class="keyword">in</span> M:</span><br><span class="line">        <span class="keyword">if</span> m != <span class="number">0</span> <span class="keyword">and</span> m != <span class="number">1</span>:</span><br><span class="line">            flag = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> flag:</span><br><span class="line">        e = M</span><br><span class="line"></span><br><span class="line"><span class="comment">#step3 RSA</span></span><br><span class="line">c = <span class="number">156879727064293983713540449709354153986555741467040286464656817265584766312996642691830194777204718013294370729900795379967954637233360644687807499775502507899321601376211142933572536311131955278039722631021587570212889988642265055045777870448827343999745781892044969377246509539272350727171791700388478710290244365826497917791913803035343900620641430005143841479362493138179077146820182826098057144121231954895739989984846588790277051812053349488382941698352320246217038444944941841831556417341663611407424355426767987304941762716818718024107781873815837487744195004393262412593608463400216124753724777502286239464</span></span><br><span class="line">n = p*q</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(e)):</span><br><span class="line">    e[i] = <span class="built_in">str</span>(e[i])</span><br><span class="line">e = <span class="string">&quot;&quot;</span>.join(e)[:-<span class="number">1</span>]</span><br><span class="line">e = <span class="built_in">int</span>(e,<span class="number">2</span>)</span><br><span class="line">d = inverse(e,(p-<span class="number">1</span>)*(q-<span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(<span class="built_in">int</span>(<span class="built_in">pow</span>(c,d,n))))</span><br></pre></td></tr></table></figure>
<p>得到flag：</p>
<font color="red">DASCTF{T81I_tPPS_6r7g_xlPi_OO3M_6vyV_Rkba}</font>

<p><br></p>
<p><br></p>
<p><br></p>
<h2 id="XOR贯穿始终"><a href="#XOR贯穿始终" class="headerlink" title="XOR贯穿始终"></a>XOR贯穿始终</h2><p>题目描述：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一切都是有意义的，拿下它吧。</span><br></pre></td></tr></table></figure>
<p>题目：</p>
<p>message.txt：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">自由和谐和谐富强公正友善爱国公正法治法治文明和谐自由法治自由法治平等公正友善公正公正民主法治自由公正敬业和谐富强公正友善爱国和谐平等平等友善敬业法治敬业和谐富强法治平等平等友善敬业公正公正公正友善敬业法治平等平等诚信自由公正自由平等友善敬业公正友善法治和谐和谐</span><br></pre></td></tr></table></figure>
<p>task.py：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> gcd</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> getPrime</span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> enflag</span><br><span class="line"></span><br><span class="line">p = getPrime(<span class="number">512</span>)</span><br><span class="line">q = getPrime(<span class="number">512</span>)</span><br><span class="line">n = q * p</span><br><span class="line">phi = (p - <span class="number">1</span>) * (q - <span class="number">1</span>)</span><br><span class="line">e = getPrime(<span class="number">17</span>)</span><br><span class="line"><span class="keyword">assert</span> gcd(e, phi) == <span class="number">1</span></span><br><span class="line"><span class="comment"># 以上信息生成了私钥文件,但文件被损坏了你能提取有用信息吗</span></span><br><span class="line"></span><br><span class="line">c = <span class="built_in">pow</span>(enflag, e, n)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;c = &#x27;</span> + <span class="built_in">str</span>(c))</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">c = 91817924748361493215143897386603397612753451291462468066632608541316135642691873237492166541761504834463859351830616117238028454453831120079998631107520871612398404926417683282285787231775479511469825932022611941912754602165499500350038397852503264709127650106856760043956604644700201911063515109074933378818</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<p>pri.pem：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-----BEGIN PRIVATE KEY-----</span><br><span class="line">MIICdwIBADANBgkqhkiG9w0BAQEFAASCAmEwggJdAgEAAoGBALmtMy+2uH1ZtbIL</span><br><span class="line">SuiAukFthyQRH5mp7UmLyzZQkdg9zEP9/5tgffikQ7ytx5kHySHnazgAO1sOzmYE</span><br><span class="line">N4Axlev6uafiP8B1Eij97v5VkYJ1I9e3mtBNheTbXKoT8op+ASQ1fQaF4A8UzLuW</span><br><span class="line">eZeZI8JTH/SH+bolAK3kiZXDFdkTAgMBAAECgYEAl067LaC7Cvs2A5cMPhfYsESv</span><br><span class="line">IgcKN1CwW4Sd3u8dSphhgu7TgyzIuvwxbuo2g1BC6WwKhaI6vGN+csfw6nh98GEn</span><br><span class="line">/p3D0huNroAYvf/DRRB9UnHdttX7wB+Mv3P0RBDWHgBiCDVvHFuFUV78cIs0tnbn</span><br><span class="line">jxjU07aPV2XRC3AfA2ECQQDqWUNPVg3i6vTyHCL7EGkbeUheYpAAfcKCQrxjc5+5</span><br><span class="line">X6A+XtgHAA1JHwykPlCpHUOmlA85DJF1ejuoImzlgRLJAkEAytTCnQF+MN2r1gaA</span><br><span class="line">UETZyj5qMYT7Th8zKEVVVJjDawLnuX4usJ2FyRnjCkk86U75QSJhw5mMc0QnG25u</span><br><span class="line">Gz3++w==</span><br><span class="line">-----END PRIVATE KEY-----</span><br></pre></td></tr></table></figure>
<p>第一层，解开社会主义核心价值观编码得到：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C0ngr4tulati0n5_y0u_fou^d_m3</span><br></pre></td></tr></table></figure>
<p>第二层，恢复破损RSA私钥文件，base64解码后得到：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">b&#x27;30820277020100300d06092a864886f70d0101010500048202613082025d02010002818100b9ad332fb6b87d59b5b20b4ae880ba416d8724111f99a9ed498bcb365091d83dcc43fdff9b607df8a443bcadc79907c921e76b38003b5b0ece660437803195ebfab9a7e23fc0751228fdeefe5591827523d7b79ad04d85e4db5caa13f28a7e0124357d0685e00f14ccbb9679979923c2531ff487f9ba2500ade48995c315d913020301000102818100974ebb2da0bb0afb3603970c3e17d8b044af22070a3750b05b849ddeef1d4a986182eed3832cc8bafc316eea36835042e96c0a85a23abc637e72c7f0ea787df06127fe9dc3d21b8dae8018bdffc345107d5271ddb6d5fbc01f8cbf73f44410d61e006208356f1c5b85515efc708b34b676e78f18d4d3b68f5765d10b701f0361024100ea59434f560de2eaf4f21c22fb10691b79485e6290007dc28242bc63739fb95fa03e5ed807000d491f0ca43e50a91d43a6940f390c91757a3ba8226ce58112c9024100cad4c29d017e30ddabd606805044d9ca3e6a3184fb4e1f332845555498c36b02e7b97e2eb09d85c919e30a493ce94ef9412261c3998c7344271b6e6e1b3dfefb&#x27;</span><br></pre></td></tr></table></figure>
<p>按照RSA私钥格式还原，可以得到以下信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">n 028181 00b9ad332fb6b87d59b5b20b4ae880ba416d8724111f99a9ed498bcb365091d83dcc43fdff9b607df8a443bcadc79907c921e76b38003b5b0ece660437803195ebfab9a7e23fc0751228fdeefe5591827523d7b79ad04d85e4db5caa13f28a7e0124357d0685e00f14ccbb9679979923c2531ff487f9ba2500ade48995c315d913</span><br><span class="line">e 0203 010001</span><br><span class="line">d 028181 00974ebb2da0bb0afb3603970c3e17d8b044af22070a3750b05b849ddeef1d4a986182eed3832cc8bafc316eea36835042e96c0a85a23abc637e72c7f0ea787df06127fe9dc3d21b8dae8018bdffc345107d5271ddb6d5fbc01f8cbf73f44410d61e006208356f1c5b85515efc708b34b676e78f18d4d3b68f5765d10b701f0361</span><br><span class="line">p 0241 00ea59434f560de2eaf4f21c22fb10691b79485e6290007dc28242bc63739fb95fa03e5ed807000d491f0ca43e50a91d43a6940f390c91757a3ba8226ce58112c9</span><br><span class="line">q 0241 00cad4c29d017e30ddabd606805044d9ca3e6a3184fb4e1f332845555498c36b02e7b97e2eb09d85c919e30a493ce94ef9412261c3998c7344271b6e6e1b3dfefb&quot;</span><br></pre></td></tr></table></figure>
<p>可以看到，私钥中的dp、dq以及inv(q,p)损坏了，但是剩下的值已经足够用于RSA解密，因此正常解密即可得到：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DASCTF&#123;0e287wQ\x08R\x17\x00FGXYFZ\x07V\x03kIUCn\x02VDg\x01f\x0cN</span><br></pre></td></tr></table></figure>
<p>发现题目描述XOR还没用上，将第一步社会主义核心价值观解密得到的串用于异或即可。</p>
<p>得到flag：</p>
<font color="red">DASCTF{0e2874af5e422482378640e61d919e9a}</font>

<p><br></p>
<p><br></p>
<p><br></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总体难度确实不大，但是怎么说呢，题目有点坑，自己能力也还存在不足，下次加油吧。</p>
]]></content>
      <categories>
        <category>wp-crypto</category>
      </categories>
  </entry>
  <entry>
    <title>2023-CNSS-Summer-wp-crypto</title>
    <url>/post/795314c1.html</url>
    <content><![CDATA[<p>要给自己学校的招新赛出题了，于是混进CNSS招新赛前的夏令营找找出题灵感，不得不说，很多题目都出的很不错，难度与知识点控制的很好，于是在此记录一下。</p>
<span id="more"></span>
<h2 id="Crypto-Guideline"><a href="#Crypto-Guideline" class="headerlink" title="Crypto Guideline"></a>Crypto Guideline</h2><p>签到题，标志着crypto方向题目的开始，直接提交flag即可。</p>
<p>flag:</p>
<font size="4" color="red">cnss{Welcome to the world of cryptography!}</font>

<p><br></p>
<p><br></p>
<p><br></p>
<h2 id="cyclic-group"><a href="#cyclic-group" class="headerlink" title="cyclic group"></a>cyclic group</h2><p>题目描述：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">可以找到我藏在循环群中的flag吗？</span><br></pre></td></tr></table></figure>
<p>题目内容：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag  <span class="comment">## secret is a local file, flag is unknown to you</span></span><br><span class="line"></span><br><span class="line">p = getPrime(<span class="number">1024</span>)</span><br><span class="line">m = bytes_to_long(flag)</span><br><span class="line">e = getPrime(<span class="number">512</span>)</span><br><span class="line">c = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(e):</span><br><span class="line">    c *= m   </span><br><span class="line">    c %= p</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;p =&#x27;</span>, p)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;e =&#x27;</span>, e)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;c =&#x27;</span>, c)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">p = 134994058501022133829793113756450648798182080773931273262418798773562440624857106163310596590759607340807163876539520282102901165977612358002331391089851066812663281502398201018663717659213732276911585751665516661301930410244101046617666467321456930120075263141242119953757880295718825254018040413826880843763</span></span><br><span class="line"><span class="string">e = 12927587515508549311645504126259938927362775210786958053823827936884288861306268493761629822045846148118653977616493302703588300283111036739875491883808759</span></span><br><span class="line"><span class="string">c = 46583597391505868783218970830156160405763802889228578452060606957717500160663392513770581781157233604314178955789908254475724009921579917780127649365498088467948777432657442293331639740286781008682662602974865442032279819833194544535317410041738966384493317240586005380761492762248899523164168679218802048162</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<p>可以看到，实际上就是：</p>
<script type="math/tex; mode=display">
m^e\equiv c\quad (mod\;p)</script><p>因此直接幂乘e关于p-1的逆元即可。而本题的题目名字cyclic group指代的是循环群，在这里即是在说，由于模数p为素数，那么m的阶就为p-1，因此可以直接求指数关于其阶的逆元求解题目。</p>
<p><br></p>
<p>exp.py：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = <span class="number">134994058501022133829793113756450648798182080773931273262418798773562440624857106163310596590759607340807163876539520282102901165977612358002331391089851066812663281502398201018663717659213732276911585751665516661301930410244101046617666467321456930120075263141242119953757880295718825254018040413826880843763</span></span><br><span class="line">e = <span class="number">12927587515508549311645504126259938927362775210786958053823827936884288861306268493761629822045846148118653977616493302703588300283111036739875491883808759</span></span><br><span class="line">c = <span class="number">46583597391505868783218970830156160405763802889228578452060606957717500160663392513770581781157233604314178955789908254475724009921579917780127649365498088467948777432657442293331639740286781008682662602974865442032279819833194544535317410041738966384493317240586005380761492762248899523164168679218802048162</span></span><br><span class="line"></span><br><span class="line">d = inverse(e,p-<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(<span class="built_in">pow</span>(c,d,p)))</span><br></pre></td></tr></table></figure>
<p>flag:</p>
<font size="4" color="red">cnss{Unbelievable! You know the key of cyclic group!}</font>

<p><br></p>
<p><br></p>
<p><br></p>
<h2 id="cnss娘的代码Ⅰ"><a href="#cnss娘的代码Ⅰ" class="headerlink" title="cnss娘的代码Ⅰ"></a>cnss娘的代码Ⅰ</h2><p>题目描述：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cnss娘写了一段感觉意义不明的代码，你能帮她找到flag吗？</span><br></pre></td></tr></table></figure>
<p>题目：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> * </span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag  </span><br><span class="line"></span><br><span class="line">m = bytes_to_long(flag)</span><br><span class="line">key = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">    key.append(getPrime(<span class="number">128</span>))</span><br><span class="line">    </span><br><span class="line">secret = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">    secret.append(m % key[i])</span><br><span class="line">    </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;key =&#x27;</span>, key)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;secret =&#x27;</span>, secret)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">key = [179283057970236760812385016853348861313, 243730152305882610684268424505624182831, 276375013783217805474364273321195364813, 338363147025326331069698214354955107607]</span></span><br><span class="line"><span class="string">secret = [42312333420922777926503668120694248887, 188911830445106862831548334980052602782, 202272400826094059912187609891368651300, 16939666639933430404336668949000187621]</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>
<p>简洁明了地考察中国剩余定理。</p>
<p><br></p>
<p>exp.py：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> * </span><br><span class="line"><span class="keyword">from</span> sympy.ntheory.modular <span class="keyword">import</span> crt</span><br><span class="line"><span class="comment">#使用如：M = crt(n,c)[0]</span></span><br><span class="line">key = [<span class="number">179283057970236760812385016853348861313</span>, <span class="number">243730152305882610684268424505624182831</span>, <span class="number">276375013783217805474364273321195364813</span>, <span class="number">338363147025326331069698214354955107607</span>]</span><br><span class="line">secret = [<span class="number">42312333420922777926503668120694248887</span>, <span class="number">188911830445106862831548334980052602782</span>, <span class="number">202272400826094059912187609891368651300</span>, <span class="number">16939666639933430404336668949000187621</span>]</span><br><span class="line"></span><br><span class="line">M = crt(key,secret)[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(M))</span><br></pre></td></tr></table></figure>
<p>flag:</p>
<font size="4" color="red">cnss{Wow!Chinese remainder theorem is so interseting!}</font>

<p><br></p>
<p><br></p>
<p><br></p>
<h2 id="RSA-Ⅰ"><a href="#RSA-Ⅰ" class="headerlink" title="RSA Ⅰ"></a>RSA Ⅰ</h2><p>题目描述：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Can you factorize n ?</span><br></pre></td></tr></table></figure>
<p>题目：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag</span><br><span class="line"></span><br><span class="line">m = bytes_to_long(flag)</span><br><span class="line">p = getPrime(<span class="number">512</span>)</span><br><span class="line">q = getPrime(<span class="number">512</span>)</span><br><span class="line">n = p*q</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">e=<span class="number">65537</span></span><br><span class="line">c = <span class="built_in">pow</span>(m,e,n)</span><br><span class="line">mask = getPrime(<span class="number">512</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;c = <span class="subst">&#123;c&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;n = <span class="subst">&#123;n&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;mask = <span class="subst">&#123;mask&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(p|mask)</span><br><span class="line"><span class="built_in">print</span>(p&amp;mask)</span><br><span class="line"></span><br><span class="line"><span class="comment">#c = 64949799997326584007544788513993497249594769744995858720976935000014197232306799968807213667255871030075230919683627404813038995304033226711042639925325815395252041199650244620814678407788637241064396318107929964286966081900052163098825412222835465966640369222321472659135622216530966800717417560715221275591</span></span><br><span class="line"><span class="comment">#n = 106750680418525866311589462967145265327203310954735134383588573660691518247034803380198999333962213971657327515092895034635965957228036264848532931376595751503164297061094511187060069380048933807326213369464059701069965785612620370291933800122445966488267918733547599024267999872488061941892122230382138042783</span></span><br><span class="line"><span class="comment">#mask = 12270330408774238331968219216635392599519489634111741706590917012819298856158311310855782884352875794146685141255943386189197362902992928716839082520848927</span></span><br><span class="line"><span class="comment">#13112112110892990771168306272793201342028151601627796725313855804865001339738164412798270175076178951452110894792943424133718769511979832250960465757056799</span></span><br><span class="line"><span class="comment">#11731832079629748669705816329667815638461774924918417348984676937048335348013101619038697983623814812736529127108466295988845879378764866277739393693264401</span></span><br></pre></td></tr></table></figure>
<p>题目给了n的一个素因子p与mask的&amp;及|位运算结果，那么对于每一位，可以简单枚举一下所有可能性：</p>
<ul>
<li>&amp;运算为1，则p该位为1</li>
<li>&amp;运算为0，|运算为1，则当mask该位为1时，p该位为0；当mask该位为0时，p该位为1</li>
<li>&amp;运算为0，|运算为0，则p该位为0</li>
</ul>
<p>因此可以还原p的所有比特位，进而解密RSA。</p>
<p><br></p>
<p>exp.py：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">c = <span class="number">64949799997326584007544788513993497249594769744995858720976935000014197232306799968807213667255871030075230919683627404813038995304033226711042639925325815395252041199650244620814678407788637241064396318107929964286966081900052163098825412222835465966640369222321472659135622216530966800717417560715221275591</span></span><br><span class="line">n = <span class="number">106750680418525866311589462967145265327203310954735134383588573660691518247034803380198999333962213971657327515092895034635965957228036264848532931376595751503164297061094511187060069380048933807326213369464059701069965785612620370291933800122445966488267918733547599024267999872488061941892122230382138042783</span></span><br><span class="line">mask = <span class="number">12270330408774238331968219216635392599519489634111741706590917012819298856158311310855782884352875794146685141255943386189197362902992928716839082520848927</span></span><br><span class="line">gift1 = <span class="number">13112112110892990771168306272793201342028151601627796725313855804865001339738164412798270175076178951452110894792943424133718769511979832250960465757056799</span></span><br><span class="line">gift2 = <span class="number">11731832079629748669705816329667815638461774924918417348984676937048335348013101619038697983623814812736529127108466295988845879378764866277739393693264401</span></span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line"></span><br><span class="line">strmask = <span class="built_in">bin</span>(mask)[<span class="number">2</span>:]</span><br><span class="line">strgift1 = <span class="built_in">bin</span>(gift1)[<span class="number">2</span>:]</span><br><span class="line">strgift2 = <span class="built_in">bin</span>(gift2)[<span class="number">2</span>:]</span><br><span class="line"></span><br><span class="line">strp = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(strmask)):</span><br><span class="line">    <span class="keyword">if</span>(strgift2[i] == <span class="string">&quot;1&quot;</span>):</span><br><span class="line">        strp.append(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span>(strgift1[i] == <span class="string">&quot;1&quot;</span> <span class="keyword">and</span> strmask[i] == <span class="string">&quot;0&quot;</span>):</span><br><span class="line">            strp.append(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">        <span class="keyword">elif</span>(strgift1[i] == <span class="string">&quot;1&quot;</span> <span class="keyword">and</span> strmask[i] == <span class="string">&quot;1&quot;</span>):</span><br><span class="line">            strp.append(<span class="string">&quot;0&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            strp.append(<span class="string">&quot;0&quot;</span>)</span><br><span class="line"></span><br><span class="line">p = <span class="built_in">int</span>(<span class="string">&quot;&quot;</span>.join(strp),<span class="number">2</span>)</span><br><span class="line">q= n//p       </span><br><span class="line">phi = (p-<span class="number">1</span>)*(q-<span class="number">1</span>)</span><br><span class="line">d = inverse(e,phi)</span><br><span class="line">m = <span class="built_in">pow</span>(c,d,n)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m))</span><br></pre></td></tr></table></figure>
<p>flag:</p>
<font size="4" color="red">cnss{1t_s33ms_bit_is_useful}</font>

<p><br></p>
<p><br></p>
<p><br></p>
<h2 id="cnss娘的代码-Ⅱ"><a href="#cnss娘的代码-Ⅱ" class="headerlink" title="cnss娘的代码 Ⅱ"></a>cnss娘的代码 Ⅱ</h2><p>题目描述：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cnss娘最近在研究一类数论中的难题，你可以帮助她吗？</span><br><span class="line">Hint: SageMath的使用可以让你事半功倍</span><br></pre></td></tr></table></figure>
<p>题目：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag  </span><br><span class="line"></span><br><span class="line">p = <span class="number">149223181221309438217142971731290162048502071683234438807455153639165894737664410172266260056805353255967638568356843140306590887937</span></span><br><span class="line">m = bytes_to_long(flag)</span><br><span class="line">g = <span class="number">7</span></span><br><span class="line">h = <span class="built_in">pow</span>(g, m, p)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;h =&#x27;</span>, h)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">106414500627466044750537699496116452216938505790285966641538755230718107434518035561502262320845803494959251547594598724676292650073</span></span><br></pre></td></tr></table></figure>
<p>直接用sage求解离散对数即可。</p>
<p><br></p>
<p>exp.ipynb：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = <span class="number">149223181221309438217142971731290162048502071683234438807455153639165894737664410172266260056805353255967638568356843140306590887937</span></span><br><span class="line">g = <span class="number">7</span></span><br><span class="line">h = <span class="number">106414500627466044750537699496116452216938505790285966641538755230718107434518035561502262320845803494959251547594598724676292650073</span></span><br><span class="line"></span><br><span class="line">m=discrete_log(mod(h,p),mod(g,p))</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m))</span><br></pre></td></tr></table></figure>
<p>flag:</p>
<font size="4" color="red">cnss{Congratulation! You crack the DLP problem!}</font>

<p><br></p>
<p><br></p>
<p><br></p>
<h2 id="cnss娘的代码-Ⅲ"><a href="#cnss娘的代码-Ⅲ" class="headerlink" title="cnss娘的代码 Ⅲ"></a>cnss娘的代码 Ⅲ</h2><p>题目描述：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cnss娘最近在学习线性代数，你可以帮她解出这道题吗？</span><br><span class="line">Hint:Sage 中自带有 Matrix 和 Vector 类。</span><br></pre></td></tr></table></figure>
<p>题目：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag  </span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> <span class="built_in">len</span>(flag) == <span class="number">40</span></span><br><span class="line">p = <span class="number">9536720961414799253</span></span><br><span class="line">u = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">40</span>, <span class="number">5</span>):</span><br><span class="line">    u.append(bytes_to_long(flag[i:i+<span class="number">5</span>]))</span><br><span class="line">u = vector(u)</span><br><span class="line">A = random_matrix(Zmod(p), <span class="number">8</span>)</span><br><span class="line">v = u * A</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;A =&#x27;</span>, A)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;v =&#x27;</span>, v)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">A = [7907672172473958392 4938237561047760432 5072996306459844921  800347085054263333 2241217299487989740 5452520396763079026 7354205761061650589 5632270298193588206]</span></span><br><span class="line"><span class="string">[6856262700627435223 7218982369550725117 3069216736555490147 9043167152368671477 6651431740452419751 2904199636400840775 1984801523985180355 9424612078019686546]</span></span><br><span class="line"><span class="string">[ 190015986177831045  594687507332748466 2546708346651205091 3864956414971412519 2586812319675472372 2541554633306459284 2840981234492698127  400426130440806923]</span></span><br><span class="line"><span class="string">[ 354930743948767363  374079227033274174 7821379197355217415 4073976921774664952 8974661879090783904 8725597754431417139 1723115467249027682  914056616366301410]</span></span><br><span class="line"><span class="string">[9032929938905307703  569436029465728354 3230536280479973685 9499318835507740454  460664783708095350 3815328100857956310 6866516203996475375 9142528333783640721]</span></span><br><span class="line"><span class="string">[6647724854667560614 1564543033588842443  980081446425820918 4482664640152609224 9361385831487208956 5729265277086036438 8521779175294512538 7872078731489374461]</span></span><br><span class="line"><span class="string">[2426759667632064565 2564361116290067541 5109836057988930695 3948680632682199428 8561341181219447072 5099840518920477627 9347277712921710222 4364598388067284951]</span></span><br><span class="line"><span class="string">[2143804620259054744 4318231909289693782 6284698432978577252 5529804751795288609 7903556036971407808 3730126758887833322 8782120630459581951 9050476736532525999]</span></span><br><span class="line"><span class="string">v = (4088048241727106122, 258857328202723850, 7303598013681209756, 3446975206276714926, 176458751236949790, 8151363680348349027, 8771366063042882128, 9003511237633705064)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<p>直接在sage中求解逆矩阵即可</p>
<p>exp.ipynb：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = <span class="number">9536720961414799253</span></span><br><span class="line">A = [[<span class="number">7907672172473958392</span>,<span class="number">4938237561047760432</span>,<span class="number">5072996306459844921</span>,<span class="number">800347085054263333</span>,<span class="number">2241217299487989740</span>,<span class="number">5452520396763079026</span>,<span class="number">7354205761061650589</span>,<span class="number">5632270298193588206</span>],</span><br><span class="line">[<span class="number">6856262700627435223</span>,<span class="number">7218982369550725117</span>,<span class="number">3069216736555490147</span>,<span class="number">9043167152368671477</span>,<span class="number">6651431740452419751</span>,<span class="number">2904199636400840775</span>,<span class="number">1984801523985180355</span>,<span class="number">9424612078019686546</span>],</span><br><span class="line">[<span class="number">190015986177831045</span>,<span class="number">594687507332748466</span>,<span class="number">2546708346651205091</span>,<span class="number">3864956414971412519</span>,<span class="number">2586812319675472372</span>,<span class="number">2541554633306459284</span>,<span class="number">2840981234492698127</span>,<span class="number">400426130440806923</span>],</span><br><span class="line">[<span class="number">354930743948767363</span>,<span class="number">374079227033274174</span>,<span class="number">7821379197355217415</span>,<span class="number">4073976921774664952</span>,<span class="number">8974661879090783904</span>,<span class="number">8725597754431417139</span>,<span class="number">1723115467249027682</span>,<span class="number">914056616366301410</span>],</span><br><span class="line">[<span class="number">9032929938905307703</span>,<span class="number">569436029465728354</span>,<span class="number">3230536280479973685</span>,<span class="number">9499318835507740454</span>,<span class="number">460664783708095350</span>,<span class="number">3815328100857956310</span>,<span class="number">6866516203996475375</span>,<span class="number">9142528333783640721</span>],</span><br><span class="line">[<span class="number">6647724854667560614</span>,<span class="number">1564543033588842443</span>,<span class="number">980081446425820918</span>,<span class="number">4482664640152609224</span>,<span class="number">9361385831487208956</span>,<span class="number">5729265277086036438</span>,<span class="number">8521779175294512538</span>,<span class="number">7872078731489374461</span>],</span><br><span class="line">[<span class="number">2426759667632064565</span>,<span class="number">2564361116290067541</span>,<span class="number">5109836057988930695</span>,<span class="number">3948680632682199428</span>,<span class="number">8561341181219447072</span>,<span class="number">5099840518920477627</span>,<span class="number">9347277712921710222</span>,<span class="number">4364598388067284951</span>],</span><br><span class="line">[<span class="number">2143804620259054744</span>,<span class="number">4318231909289693782</span>,<span class="number">6284698432978577252</span>,<span class="number">5529804751795288609</span>,<span class="number">7903556036971407808</span>,<span class="number">3730126758887833322</span>,<span class="number">8782120630459581951</span>,<span class="number">9050476736532525999</span>]]</span><br><span class="line"></span><br><span class="line">ans = [<span class="number">4088048241727106122</span>, <span class="number">258857328202723850</span>, <span class="number">7303598013681209756</span>, <span class="number">3446975206276714926</span>, <span class="number">176458751236949790</span>, <span class="number">8151363680348349027</span>, <span class="number">8771366063042882128</span>, <span class="number">9003511237633705064</span>]</span><br><span class="line">A = matrix(A)</span><br><span class="line">ans = matrix(ans)</span><br><span class="line"></span><br><span class="line">flag = ans * A.inverse()</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br><span class="line"></span><br><span class="line"><span class="comment">#得到flag后转化为字符串</span></span><br><span class="line">flag = [<span class="number">256128467098287645152364579619033136532012336082411188262170716121111141373910417997647279385874168289963422098883372524388175789168151018039664118938</span>/<span class="number">201110710500527103391704345109970877861492963385688540350899980246056954432876844511421798766202341953924005687593642435623584608348351172354206968203</span>,-<span class="number">275157020682273200260243873388370073035487413746791277567209773631463468440360425377838149581773104213153845176881963804588249058534505227929576082442</span>/<span class="number">201110710500527103391704345109970877861492963385688540350899980246056954432876844511421798766202341953924005687593642435623584608348351172354206968203</span>,<span class="number">205418055261423253440834873996888852743735400527184165431288083430874722579052114104669136088527642186595043026543683492544648632576976821633919688987</span>/<span class="number">67036903500175701130568115036656959287164321128562846783633326748685651477625614837140599588734113984641335229197880811874528202782783724118068989401</span>,<span class="number">18887682222057954947813918789359532063827948125435329591909175563625225112660734620218938715145807440112704581336669611824654566923603748916776016972</span>/<span class="number">67036903500175701130568115036656959287164321128562846783633326748685651477625614837140599588734113984641335229197880811874528202782783724118068989401</span>,-<span class="number">25792447761509638420556125881168126603544490324749544374648563355312526747005861915100426458158515036632551136815312658182069136958880193280291853604</span>/<span class="number">201110710500527103391704345109970877861492963385688540350899980246056954432876844511421798766202341953924005687593642435623584608348351172354206968203</span>,<span class="number">263743295233022646271965564265774549530140797857736570979958721892220519418537528753856004044323800915867363751008926223858363297878551362225736657993</span>/<span class="number">201110710500527103391704345109970877861492963385688540350899980246056954432876844511421798766202341953924005687593642435623584608348351172354206968203</span>,-<span class="number">839256526384408301445325525932265486477039492555936647496320730347707472223889935476141937534810747723549651396954028900430020396698162916210131940419</span>/<span class="number">201110710500527103391704345109970877861492963385688540350899980246056954432876844511421798766202341953924005687593642435623584608348351172354206968203</span>,<span class="number">165200370960939593750718733159922760922513289005013438437371715048231002848101266223391623531454692435044072426966916629687643829467166749676754679429</span>/<span class="number">67036903500175701130568115036656959287164321128562846783633326748685651477625614837140599588734113984641335229197880811874528202782783724118068989401</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> flag:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(long_to_bytes(<span class="built_in">int</span>(i % p)))[<span class="number">2</span>:-<span class="number">1</span>],end = <span class="string">&quot;&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>flag:</p>
<font size="4" color="red">cnss{Line8ar alg3ebra 1s 50 i0mportant!}</font>

<p><br></p>
<p><br></p>
<p><br></p>
<h2 id="HomoBlock"><a href="#HomoBlock" class="headerlink" title="HomoBlock"></a>HomoBlock</h2><p>题目描述：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">你是一个，一个一个一个Homo啊啊啊啊啊啊啊</span><br></pre></td></tr></table></figure>
<p>题目：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> bytes_to_long, getRandomNBitInteger</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> getrandbits</span><br><span class="line"><span class="keyword">from</span> os <span class="keyword">import</span> urandom</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> flag.startswith(<span class="string">b&#x27;cnss&#123;I_a&#x27;</span>) <span class="keyword">and</span> flag.endswith(<span class="string">b&#x27;&#125;&#x27;</span>)</span><br><span class="line"><span class="keyword">assert</span> <span class="built_in">len</span>(flag)%<span class="number">8</span>==<span class="number">0</span></span><br><span class="line">MASK1 = getRandomNBitInteger(<span class="number">32</span>)|(<span class="number">0xffffffff00000000</span>)</span><br><span class="line">MASK2 = getRandomNBitInteger(<span class="number">32</span>)&lt;&lt;<span class="number">32</span></span><br><span class="line">ROUND = <span class="number">5</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">genKey</span>():</span><br><span class="line">    tmp = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(ROUND):</span><br><span class="line">        tmp.append(getRandomNBitInteger(<span class="number">64</span>))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">NotHomoFunction</span>(<span class="params">x,iv,key</span>):</span><br><span class="line">    <span class="keyword">return</span> ((x&lt;&lt;iv)&amp;MASK1)^((x&gt;&gt;iv)|MASK2)^key</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encrypt</span>(<span class="params">message,iv,key</span>):</span><br><span class="line">    cipher = bytes_to_long(message)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(ROUND):</span><br><span class="line">        cipher = NotHomoFunction(cipher,iv,key)</span><br><span class="line">    <span class="keyword">return</span> cipher</span><br><span class="line"></span><br><span class="line">cipher = []</span><br><span class="line">iv = <span class="number">32</span></span><br><span class="line">key = getRandomNBitInteger(<span class="number">64</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(flag),<span class="number">8</span>):</span><br><span class="line">    cipher.append(encrypt(flag[i:i+<span class="number">8</span>],iv,key))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(cipher)</span><br><span class="line"><span class="built_in">print</span>(iv)</span><br><span class="line"><span class="built_in">print</span>(MASK2)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot; </span></span><br><span class="line"><span class="string">[4840951631397558164, 5492303526413306583, 6271460196030786735, 6127905759336302986, 601209385465514967]</span></span><br><span class="line"><span class="string">32</span></span><br><span class="line"><span class="string">16500653344889503744</span></span><br></pre></td></tr></table></figure>
<p>观察加密方式，发现具有以下特点:</p>
<ul>
<li>明文按长度为8分组，分别加密</li>
<li>每一轮交换上一轮得到结果的高低32位，然后异或 MASK2 ，异或key。</li>
</ul>
<p>可以发现，这样交换4次后就会恢复初值，所以实际交换5次后，就能得到初始值异或 MASK2 并异或key的结果。又因为明文的第一部分已经给出，所以可以根据这个明文恢复key，后续逐步恢复即可。</p>
<p><br></p>
<p>exp.py：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">flag = <span class="string">b&#x27;cnss&#123;I_a&#x27;</span></span><br><span class="line">f0 = bytes_to_long(flag)</span><br><span class="line">p = [<span class="number">4840951631397558164</span>, <span class="number">5492303526413306583</span>, <span class="number">6271460196030786735</span>, <span class="number">6127905759336302986</span>, <span class="number">601209385465514967</span>]</span><br><span class="line">MASK2 = <span class="number">16500653344889503744</span></span><br><span class="line">f1 = p[<span class="number">0</span>]</span><br><span class="line">hf0, lf0 = (f0 &gt;&gt; <span class="number">32</span>, f0 % (<span class="number">2</span> ** <span class="number">32</span>))</span><br><span class="line">hf1, lf1 = (f1 &gt;&gt; <span class="number">32</span>, f1 % (<span class="number">2</span> ** <span class="number">32</span>))</span><br><span class="line">hk = hf1 ^ lf0 ^ (MASK2 &gt;&gt; <span class="number">32</span>)</span><br><span class="line">lk = lf1 ^ hf0</span><br><span class="line">key = (hk &lt;&lt; <span class="number">32</span>) + lk</span><br><span class="line"></span><br><span class="line">flag = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> p:</span><br><span class="line">	l, h = ((i ^ MASK2 ^ key) &gt;&gt; <span class="number">32</span>, (i ^ MASK2 ^ key) % (<span class="number">2</span> ** <span class="number">32</span>))</span><br><span class="line">	flag += long_to_bytes((h &lt;&lt; <span class="number">32</span>) | l).decode()</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure>
<p>flag:</p>
<font size="4" color="red">cnss{I_am_n0t_HHHHHHoooommmmmmmoooo0000}</font>

<p><br></p>
<p><br></p>
<p><br></p>
<h2 id="ezLFSR"><a href="#ezLFSR" class="headerlink" title="ezLFSR"></a>ezLFSR</h2><p>题目描述：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">do you know LFSR?</span><br><span class="line">Hint1:考点： LFSR流密码</span><br><span class="line">Hint2:可以使用 z3solver 。</span><br></pre></td></tr></table></figure>
<p>题目：</p>
<p>task.py：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> mask,seed</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LFSR</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, seed, mask, length</span>):</span><br><span class="line">        self.length_mask = <span class="number">2</span> ** length - <span class="number">1</span></span><br><span class="line">        self.mask = mask &amp; self.length_mask</span><br><span class="line">        self.state = seed &amp; self.length_mask</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">next</span>(<span class="params">self</span>):</span><br><span class="line">        next_state = (self.state &lt;&lt; <span class="number">1</span>) &amp; self.length_mask</span><br><span class="line">        i = self.state &amp; self.mask &amp; self.length_mask</span><br><span class="line">        output = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i != <span class="number">0</span>:</span><br><span class="line">            output ^= (i &amp; <span class="number">1</span>)</span><br><span class="line">            i = i &gt;&gt; <span class="number">1</span></span><br><span class="line">        next_state ^= output</span><br><span class="line">        self.state = next_state</span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getrandbit</span>(<span class="params">self, nbit</span>):</span><br><span class="line">        output = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(nbit):</span><br><span class="line">            output = (output &lt;&lt; <span class="number">1</span>) ^ self.<span class="built_in">next</span>()</span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encrypt</span>(<span class="params">cipher, ipath, opath</span>):</span><br><span class="line">    ifile=<span class="built_in">open</span>(ipath,<span class="string">&#x27;rb&#x27;</span>)</span><br><span class="line">    ofile=<span class="built_in">open</span>(opath,<span class="string">&#x27;wb&#x27;</span>)</span><br><span class="line">    plaintext=ifile.read()</span><br><span class="line">    <span class="keyword">for</span> ch <span class="keyword">in</span> plaintext:</span><br><span class="line">        c=ch^cipher.getrandbit(<span class="number">8</span>)</span><br><span class="line">        ofile.write(long_to_bytes(c))</span><br><span class="line">    ifile.close()</span><br><span class="line">    ofile.close()</span><br><span class="line"></span><br><span class="line">lfsr = LFSR(seed, mask, <span class="number">16</span>)</span><br><span class="line">encrypt(lfsr,<span class="string">&#x27;flag.txt&#x27;</span>,<span class="string">&#x27;cipher.enc&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;seed = <span class="subst">&#123;seed&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># seed = 37285</span></span><br></pre></td></tr></table></figure>
<p>cipher.enc：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">E3306EA1B67E13D02B59A0DEA270AD8C3AF0110FBF60C07740A699A5918E7DC5</span><br></pre></td></tr></table></figure>
<p>注意到mask也仅取了低16位，那么爆破的范围也仅有65536，因此直接爆破出符合要求的明文串即可。</p>
<p><br></p>
<p>exp.py：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LFSR</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, seed, mask, length</span>):</span><br><span class="line">        self.length_mask = <span class="number">2</span> ** length - <span class="number">1</span></span><br><span class="line">        self.mask = mask &amp; self.length_mask</span><br><span class="line">        self.state = seed &amp; self.length_mask</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">next</span>(<span class="params">self</span>):</span><br><span class="line">        next_state = (self.state &lt;&lt; <span class="number">1</span>) &amp; self.length_mask</span><br><span class="line">        i = self.state &amp; self.mask &amp; self.length_mask</span><br><span class="line">        output = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i != <span class="number">0</span>:</span><br><span class="line">            output ^= (i &amp; <span class="number">1</span>)</span><br><span class="line">            i = i &gt;&gt; <span class="number">1</span></span><br><span class="line">        next_state ^= output</span><br><span class="line">        self.state = next_state</span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getrandbit</span>(<span class="params">self, nbit</span>):</span><br><span class="line">        output = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(nbit):</span><br><span class="line">            output = (output &lt;&lt; <span class="number">1</span>) ^ self.<span class="built_in">next</span>()</span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line"></span><br><span class="line">seed = <span class="number">37285</span></span><br><span class="line">hex_string = <span class="string">&quot;E3306EA1B67E13D02B59A0DEA270AD8C3AF0110FBF60C07740A699A5918E7DC5&quot;</span></span><br><span class="line"><span class="comment"># 每两个字符一组拆分</span></span><br><span class="line">split_hex = [hex_string[i:i+<span class="number">2</span>] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(hex_string), <span class="number">2</span>)]</span><br><span class="line"></span><br><span class="line">c = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> split_hex:</span><br><span class="line">    c.append(<span class="built_in">int</span>(i,<span class="number">16</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>**<span class="number">16</span>):</span><br><span class="line">    mask = i</span><br><span class="line">    lfsr = LFSR(seed, mask, <span class="number">16</span>)</span><br><span class="line">    clist = []</span><br><span class="line">    <span class="keyword">for</span> ch <span class="keyword">in</span> c:</span><br><span class="line">        temp=ch^lfsr.getrandbit(<span class="number">8</span>)</span><br><span class="line">        clist.append(<span class="built_in">chr</span>(temp))</span><br><span class="line">    str1 = <span class="string">&quot;&quot;</span>.join(clist)</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">&quot;cnss&quot;</span> <span class="keyword">in</span> str1):</span><br><span class="line">        <span class="built_in">print</span>(str1)</span><br></pre></td></tr></table></figure>
<p>运行时间大概需要不到1分钟。</p>
<p>flag:</p>
<font size="4" color="red">cnss{Y0u_can_brust_0r_F1nd_seed}</font>

<p>从flag串以及hint可以看出，本题应该是可以通过LFSR的方式恢复明文的，但是数量级太小，没必要。</p>
<p><br></p>
<p><br></p>
<p><br></p>
<h2 id="RSA-Ⅱ"><a href="#RSA-Ⅱ" class="headerlink" title="RSA Ⅱ"></a>RSA Ⅱ</h2><p>题目描述：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">It&#x27;s more difficult than RSA Ⅰ,right? Can you factorize n ?</span><br><span class="line">Hint:查找有关RSA攻击的资料是一个很重要的技能。</span><br></pre></td></tr></table></figure>
<p>并提供了一篇论文链接：<a href="https://eprint.iacr.org/2020/1506.pdf">1506.pdf (iacr.org)</a></p>
<p>题目：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag</span><br><span class="line"></span><br><span class="line">m = bytes_to_long(flag)</span><br><span class="line">p = getPrime(<span class="number">512</span>)</span><br><span class="line">q = getPrime(<span class="number">512</span>)</span><br><span class="line"></span><br><span class="line">n = p*q</span><br><span class="line">mask1 = <span class="number">8802124635072632944677646490123224379036416333544329119490072003355821545476873187055484863111312282268555945525261726909784693138184611507738758202965723</span></span><br><span class="line">mask2 = <span class="number">10267484648659998697412163107809730542736732193409802323765378917769614002176050843098384409535095473863894691160595931186139418791709781214996751031082601</span></span><br><span class="line"></span><br><span class="line">e=<span class="number">65537</span></span><br><span class="line">c = <span class="built_in">pow</span>(m,e,n)</span><br><span class="line">mask1 = getPrime(<span class="number">512</span>)</span><br><span class="line">mask2 = getPrime(<span class="number">512</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;c = <span class="subst">&#123;c&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;n = <span class="subst">&#123;n&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;mask1 = <span class="subst">&#123;mask1&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;mask2 = <span class="subst">&#123;mask2&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;h1 = <span class="subst">&#123;p&amp;mask1&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;h2 = <span class="subst">&#123;q&amp;mask2&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">c = 21645208345867622053024283678631971385301103104312441336174301067402923208233033116071987870811290403578077414872467955871236843078200772311176723821275372545792521252126496488134168455430882670865862282658077115199048181151105823370547063726203692258934054391552916645628374539820099986794258298843501009240</span></span><br><span class="line"><span class="string">n = 87282921750815275717132715603847471604654006135344540742956637574882193904171665195367477260090328888053170090015909620539666069545618781812315864580009968838414539707616636379202667918204792277927294032362873240288573251987386601263377458038218959813925307265939433229169884527274177006792047369788293125409</span></span><br><span class="line"><span class="string">mask1 = 8802124635072632944677646490123224379036416333544329119490072003355821545476873187055484863111312282268555945525261726909784693138184611507738758202965723</span></span><br><span class="line"><span class="string">mask2 = 10267484648659998697412163107809730542736732193409802323765378917769614002176050843098384409535095473863894691160595931186139418791709781214996751031082601</span></span><br><span class="line"><span class="string">h1 = 6706231204421711988537353586716977912583550778985616494052350868539347641557164021930575245010900470979740623857738159245103694128834121517146255441177729</span></span><br><span class="line"><span class="string">h2 = 6704397956705493482354535847135592349486638396996488745737387153856868045426992197309829534096366784379171117205125136777653995357887539312554042026362473</span></span><br></pre></td></tr></table></figure>
<p>相较于RSA1，这一次不能根据位运算结果完全确定出p、q的比特位了，不过仍然可以利用以下线索还原：</p>
<ul>
<li>&amp;运算为1，则p该位必为1</li>
<li>&amp;运算为0，mask该位为1，则p该位必为0</li>
</ul>
<p>而当&amp;运算为0，mask也为0时，p的该比特位就存在两种结果，无法完全确定。可是这题不仅给了p，还给了q的位运算结果，因此我们可以利用下面这一点信息，从高位向低位进行深度优先搜索，显著降低复杂度：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、将p、q当前确定的二进制位后方全部填充0，直至填满512位，此时p、q乘积应小于n。</span><br><span class="line">2、将p、q当前确定的二进制位后方全部填充1，直至填满512位，此时p、q乘积应大于n。</span><br></pre></td></tr></table></figure>
<p>如此就能在极短时间内还原出p、q。</p>
<p><br></p>
<p>exp.py：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">c = <span class="number">21645208345867622053024283678631971385301103104312441336174301067402923208233033116071987870811290403578077414872467955871236843078200772311176723821275372545792521252126496488134168455430882670865862282658077115199048181151105823370547063726203692258934054391552916645628374539820099986794258298843501009240</span></span><br><span class="line">n = <span class="number">87282921750815275717132715603847471604654006135344540742956637574882193904171665195367477260090328888053170090015909620539666069545618781812315864580009968838414539707616636379202667918204792277927294032362873240288573251987386601263377458038218959813925307265939433229169884527274177006792047369788293125409</span></span><br><span class="line">mask1 = <span class="number">8802124635072632944677646490123224379036416333544329119490072003355821545476873187055484863111312282268555945525261726909784693138184611507738758202965723</span></span><br><span class="line">mask2 = <span class="number">10267484648659998697412163107809730542736732193409802323765378917769614002176050843098384409535095473863894691160595931186139418791709781214996751031082601</span></span><br><span class="line">h1 = <span class="number">6706231204421711988537353586716977912583550778985616494052350868539347641557164021930575245010900470979740623857738159245103694128834121517146255441177729</span></span><br><span class="line">h2 = <span class="number">6704397956705493482354535847135592349486638396996488745737387153856868045426992197309829534096366784379171117205125136777653995357887539312554042026362473</span></span><br><span class="line">mask1 = <span class="built_in">str</span>(<span class="built_in">bin</span>(mask1)[<span class="number">2</span>:])</span><br><span class="line">mask2 = <span class="built_in">str</span>(<span class="built_in">bin</span>(mask2)[<span class="number">2</span>:])</span><br><span class="line">h1 = <span class="built_in">str</span>(<span class="built_in">bin</span>(h1)[<span class="number">2</span>:])</span><br><span class="line">h2 = <span class="built_in">str</span>(<span class="built_in">bin</span>(h2)[<span class="number">2</span>:])</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">p,q</span>):</span><br><span class="line">    l = <span class="built_in">len</span>(p)</span><br><span class="line">    tmp0 = p + (<span class="number">512</span>-l)*<span class="string">&quot;0&quot;</span></span><br><span class="line">    tmp1 = p + (<span class="number">512</span>-l)*<span class="string">&quot;1&quot;</span></span><br><span class="line">    tmq0 = q + (<span class="number">512</span>-l)*<span class="string">&quot;0&quot;</span></span><br><span class="line">    tmq1 = q + (<span class="number">512</span>-l)*<span class="string">&quot;1&quot;</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">int</span>(tmp0,<span class="number">2</span>)*<span class="built_in">int</span>(tmq0,<span class="number">2</span>) &gt; n):</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">    <span class="keyword">elif</span>(<span class="built_in">int</span>(tmp1,<span class="number">2</span>)*<span class="built_in">int</span>(tmq1,<span class="number">2</span>) &lt; n):</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(l == <span class="number">512</span>):</span><br><span class="line">        <span class="comment">#print(tmp0)</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">int</span>(tmp0,<span class="number">2</span>))</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">int</span>(tmq0,<span class="number">2</span>))</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span>((mask1[l] == <span class="string">&quot;1&quot;</span> <span class="keyword">and</span> h1[l] == <span class="string">&quot;1&quot;</span>) <span class="keyword">and</span> (mask2[l] == <span class="string">&quot;1&quot;</span> <span class="keyword">and</span> h2[l] == <span class="string">&quot;1&quot;</span>)):</span><br><span class="line">            find(p+<span class="string">&quot;1&quot;</span>,q+<span class="string">&quot;1&quot;</span>)</span><br><span class="line">        <span class="keyword">elif</span>((mask1[l] == <span class="string">&quot;1&quot;</span> <span class="keyword">and</span> h1[l] == <span class="string">&quot;1&quot;</span>) <span class="keyword">and</span> (mask2[l] == <span class="string">&quot;1&quot;</span> <span class="keyword">and</span> h2[l] == <span class="string">&quot;0&quot;</span>)):</span><br><span class="line">            find(p+<span class="string">&quot;1&quot;</span>,q+<span class="string">&quot;0&quot;</span>)</span><br><span class="line">        <span class="keyword">elif</span>((mask1[l] == <span class="string">&quot;1&quot;</span> <span class="keyword">and</span> h1[l] == <span class="string">&quot;1&quot;</span>) <span class="keyword">and</span> (mask2[l] == <span class="string">&quot;0&quot;</span> <span class="keyword">and</span> h2[l] == <span class="string">&quot;0&quot;</span>)):</span><br><span class="line">            find(p+<span class="string">&quot;1&quot;</span>,q+<span class="string">&quot;0&quot;</span>)</span><br><span class="line">            find(p+<span class="string">&quot;1&quot;</span>,q+<span class="string">&quot;1&quot;</span>)</span><br><span class="line">        <span class="keyword">elif</span>((mask1[l] == <span class="string">&quot;1&quot;</span> <span class="keyword">and</span> h1[l] == <span class="string">&quot;0&quot;</span>) <span class="keyword">and</span> (mask2[l] == <span class="string">&quot;1&quot;</span> <span class="keyword">and</span> h2[l] == <span class="string">&quot;1&quot;</span>)):</span><br><span class="line">            find(p+<span class="string">&quot;0&quot;</span>,q+<span class="string">&quot;1&quot;</span>)</span><br><span class="line">        <span class="keyword">elif</span>((mask1[l] == <span class="string">&quot;1&quot;</span> <span class="keyword">and</span> h1[l] == <span class="string">&quot;0&quot;</span>) <span class="keyword">and</span> (mask2[l] == <span class="string">&quot;1&quot;</span> <span class="keyword">and</span> h2[l] == <span class="string">&quot;0&quot;</span>)):</span><br><span class="line">            find(p+<span class="string">&quot;0&quot;</span>,q+<span class="string">&quot;0&quot;</span>)</span><br><span class="line">        <span class="keyword">elif</span>((mask1[l] == <span class="string">&quot;1&quot;</span> <span class="keyword">and</span> h1[l] == <span class="string">&quot;0&quot;</span>) <span class="keyword">and</span> (mask2[l] == <span class="string">&quot;0&quot;</span> <span class="keyword">and</span> h2[l] == <span class="string">&quot;0&quot;</span>)):</span><br><span class="line">            find(p+<span class="string">&quot;0&quot;</span>,q+<span class="string">&quot;1&quot;</span>)</span><br><span class="line">            find(p+<span class="string">&quot;0&quot;</span>,q+<span class="string">&quot;0&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">elif</span>((mask1[l] == <span class="string">&quot;0&quot;</span> <span class="keyword">and</span> h1[l] == <span class="string">&quot;0&quot;</span>) <span class="keyword">and</span> (mask2[l] == <span class="string">&quot;1&quot;</span> <span class="keyword">and</span> h2[l] == <span class="string">&quot;1&quot;</span>)):</span><br><span class="line">            find(p+<span class="string">&quot;0&quot;</span>,q+<span class="string">&quot;1&quot;</span>)</span><br><span class="line">            find(p+<span class="string">&quot;1&quot;</span>,q+<span class="string">&quot;1&quot;</span>)</span><br><span class="line">        <span class="keyword">elif</span>((mask1[l] == <span class="string">&quot;0&quot;</span> <span class="keyword">and</span> h1[l] == <span class="string">&quot;0&quot;</span>) <span class="keyword">and</span> (mask2[l] == <span class="string">&quot;1&quot;</span> <span class="keyword">and</span> h2[l] == <span class="string">&quot;0&quot;</span>)):</span><br><span class="line">            find(p+<span class="string">&quot;0&quot;</span>,q+<span class="string">&quot;0&quot;</span>)</span><br><span class="line">            find(p+<span class="string">&quot;1&quot;</span>,q+<span class="string">&quot;0&quot;</span>)</span><br><span class="line">        <span class="keyword">elif</span>((mask1[l] == <span class="string">&quot;0&quot;</span> <span class="keyword">and</span> h1[l] == <span class="string">&quot;0&quot;</span>) <span class="keyword">and</span> (mask2[l] == <span class="string">&quot;0&quot;</span> <span class="keyword">and</span> h2[l] == <span class="string">&quot;0&quot;</span>)):</span><br><span class="line">            find(p+<span class="string">&quot;0&quot;</span>,q+<span class="string">&quot;0&quot;</span>)</span><br><span class="line">            find(p+<span class="string">&quot;0&quot;</span>,q+<span class="string">&quot;1&quot;</span>)</span><br><span class="line">            find(p+<span class="string">&quot;1&quot;</span>,q+<span class="string">&quot;0&quot;</span>)</span><br><span class="line">            find(p+<span class="string">&quot;1&quot;</span>,q+<span class="string">&quot;1&quot;</span>)</span><br><span class="line"></span><br><span class="line">tempp = <span class="string">&quot;&quot;</span></span><br><span class="line">tempq = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#find(tempp,tempq)</span></span><br><span class="line">P = <span class="number">10172774442863868719013872884099170294615753094066736187886125116462340120031133533430755779832487215255546434139069419394249074006281284289077492708469893</span></span><br><span class="line">Q = <span class="number">8580050824978592226795441601299432164577158891190171233964440597982925469924083252289609500726234367555160732119333211934059529993446003001925910065317613</span></span><br><span class="line">phi = (P-<span class="number">1</span>)*(Q-<span class="number">1</span>)</span><br><span class="line">d = inverse(e,phi)</span><br><span class="line">m = <span class="built_in">pow</span>(c,d,n)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m))</span><br></pre></td></tr></table></figure>
<p>flag:</p>
<font size="4" color="red">cnss{A1g0r1thm_1s_5o_hard_for_Me!}</font>

<p><br></p>
<p><br></p>
<p><br></p>
<h2 id="BabyLattice"><a href="#BabyLattice" class="headerlink" title="BabyLattice"></a>BabyLattice</h2><p>题目描述：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Do you know SVP and LLL?</span><br><span class="line">Hint:在解决本题的过程中你会接触到格(Lattice)的一些基本概念,以及LLL算法。</span><br></pre></td></tr></table></figure>
<p>题目：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> <span class="built_in">len</span>(flag) == <span class="number">32</span></span><br><span class="line">flagArg = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">32</span>,<span class="number">8</span>):</span><br><span class="line">    flag_tmp = bytes_to_long(flag[i:i+<span class="number">8</span>])</span><br><span class="line">    <span class="keyword">assert</span> flag_tmp &lt; <span class="number">2</span>**<span class="number">64</span></span><br><span class="line">    flagArg.append(flag_tmp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Equation</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,arg</span>):</span><br><span class="line">        <span class="keyword">assert</span> <span class="built_in">len</span>(arg)==<span class="number">4</span></span><br><span class="line">        self.arg = arg</span><br><span class="line">        self.modulus = getRandomInteger(<span class="number">512</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">output</span>(<span class="params">self</span>):</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;the modulus is <span class="subst">&#123;self.modulus&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">            tmp = getRandomInteger(<span class="number">512</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;The number of the <span class="subst">&#123;i&#125;</span> round is <span class="subst">&#123;tmp&#125;</span>&#x27;</span>)</span><br><span class="line">            ans+=self.arg[i]*tmp</span><br><span class="line">        ans = ans%self.modulus</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;The result is <span class="subst">&#123;ans&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">EzLineModulus = Equation(flagArg)</span><br><span class="line">EzLineModulus.output()</span><br><span class="line"></span><br><span class="line"><span class="comment">#the modulus is 4653980939589101565044285021945025573290906789132633751963110127801187748089540230208429714310516635848025358481189017398970169440484136391436220837417791</span></span><br><span class="line"><span class="comment">#The number of the 0 round is 7163515288721018524391838724005494502072524058809935946689587023614778895762400663698973734684519790842142248155478226513293289043832391054661263177469005</span></span><br><span class="line"><span class="comment">#The number of the 1 round is 13155134533945105613277690072743652931283618211062662861216511364398097684219572559463369279253337759860439150691008846033587645344197431244106331100681641</span></span><br><span class="line"><span class="comment">#The number of the 2 round is 8450640520436960190933104494093081291057363628588171820766164606066614201483259024304043681871965360847257453187101669512010469318096007617859083021766564</span></span><br><span class="line"><span class="comment">#The number of the 3 round is 798383352075970107818638521362593273862636131165588181505120596765884650403289567593307005746576184176902675297124272602141002375036927828390204063589274</span></span><br><span class="line"><span class="comment">#The result is 58831711102590059067743519228568722360433408071362335858674496753241059990433991177195518029785828762522018556332340356592798263267784406825183284767956</span></span><br></pre></td></tr></table></figure>
<p>招新赛前的夏令营就出Lattice的题目了。。确实狠</p>
<p>不过确实是最基础的Lattice题目了，大致思路就是列出线性关系式，转化为矩阵形式，并保证较短向量都在等式右侧，即可对构造出来的格进行规约得到短向量。</p>
<p><br></p>
<p>exp.ipynb：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">n = <span class="number">4653980939589101565044285021945025573290906789132633751963110127801187748089540230208429714310516635848025358481189017398970169440484136391436220837417791</span></span><br><span class="line">a1 = <span class="number">7163515288721018524391838724005494502072524058809935946689587023614778895762400663698973734684519790842142248155478226513293289043832391054661263177469005</span></span><br><span class="line">a2 = <span class="number">13155134533945105613277690072743652931283618211062662861216511364398097684219572559463369279253337759860439150691008846033587645344197431244106331100681641</span></span><br><span class="line">a3 = <span class="number">8450640520436960190933104494093081291057363628588171820766164606066614201483259024304043681871965360847257453187101669512010469318096007617859083021766564</span></span><br><span class="line">a4 = <span class="number">798383352075970107818638521362593273862636131165588181505120596765884650403289567593307005746576184176902675297124272602141002375036927828390204063589274</span></span><br><span class="line">ans = <span class="number">58831711102590059067743519228568722360433408071362335858674496753241059990433991177195518029785828762522018556332340356592798263267784406825183284767956</span></span><br><span class="line">inv = inverse(a1,n)</span><br><span class="line">L = Matrix(ZZ, [[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,-ans*inv],</span><br><span class="line">                [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>,a2*inv],</span><br><span class="line">                [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>,a3*inv],</span><br><span class="line">                [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>,a4*inv],</span><br><span class="line">                [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,n]])</span><br><span class="line"></span><br><span class="line">v = L.LLL()[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>(long_to_bytes(<span class="built_in">abs</span>(v[<span class="number">4</span>])))[<span class="number">2</span>:-<span class="number">1</span>],end = <span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(v)-<span class="number">1</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(long_to_bytes(<span class="built_in">abs</span>(v[i])))[<span class="number">2</span>:-<span class="number">1</span>],end = <span class="string">&quot;&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>flag:</p>
<font size="4" color="red">cnss{W0w!Y0u_know_WhatisL4ttice}</font>

<p>（有关格的问题本篇不会展开讲，因为它需要对一些基本原理的了解，想要明白此类问题需要先自行查阅一些格相关的基本概念）</p>
<p><br></p>
<p><br></p>
<p><br></p>
<h2 id="ezSignature"><a href="#ezSignature" class="headerlink" title="ezSignature"></a>ezSignature</h2><p>题目描述：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">这样使用数字签名是否安全呢？</span><br><span class="line">nc 43.156.14.141 6943</span><br><span class="line"></span><br><span class="line">Hint1:推荐使用pwntools进行交互。</span><br><span class="line">Hint2:建议先了解 DSA 数字签名流程。</span><br></pre></td></tr></table></figure>
<p>题目：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> sha256</span><br><span class="line"><span class="keyword">import</span> socketserver</span><br><span class="line"><span class="keyword">import</span> signal</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag</span><br><span class="line"><span class="keyword">from</span> Crypto.PublicKey <span class="keyword">import</span> DSA</span><br><span class="line"></span><br><span class="line">table = string.ascii_letters + string.digits</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DigitalSignatureAlgorithm</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, key</span>):</span><br><span class="line">        self.p = key.p</span><br><span class="line">        self.q = key.q</span><br><span class="line">        self.g = key.g</span><br><span class="line">        self.y = key.y</span><br><span class="line">        self.x = key.x</span><br><span class="line">        self.k = randint(<span class="number">1</span>, self.q - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sign</span>(<span class="params">self, m</span>):</span><br><span class="line">        k = self.k</span><br><span class="line">        h = bytes_to_long(sha256(m).digest())</span><br><span class="line">        r = <span class="built_in">pow</span>(self.g, k, self.p) % self.q</span><br><span class="line">        s = inverse(k, self.q) * (h + self.x * r) % self.q</span><br><span class="line">        <span class="keyword">return</span> r, s</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">verify</span>(<span class="params">self, m, signature</span>):</span><br><span class="line">        r, s = signature</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">not</span> (<span class="number">1</span> &lt;= r &lt;= self.q - <span class="number">1</span>)) <span class="keyword">or</span> (<span class="keyword">not</span> (<span class="number">1</span> &lt;= s &lt;= self.q - <span class="number">1</span>)):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        z = bytes_to_long(sha256(m).digest())</span><br><span class="line">        w = inverse(s, self.q)</span><br><span class="line">        u1 = (z * w) % self.q</span><br><span class="line">        u2 = (r * w) % self.q</span><br><span class="line">        v = (<span class="built_in">pow</span>(self.g, u1, self.p) * <span class="built_in">pow</span>(self.y, u2, self.p)) % self.p % self.q</span><br><span class="line">        <span class="keyword">return</span> r == v</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">myDSA = DigitalSignatureAlgorithm(DSA.generate(<span class="number">1024</span>))</span><br><span class="line">MENU = <span class="string">br&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">[1] Sign.</span></span><br><span class="line"><span class="string">[2] Verify.</span></span><br><span class="line"><span class="string">[3] Get_public_key.</span></span><br><span class="line"><span class="string">[4] Exit.</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Task</span>(socketserver.BaseRequestHandler):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_recvall</span>(<span class="params">self</span>):</span><br><span class="line">        BUFF_SIZE = <span class="number">2048</span></span><br><span class="line">        data = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            part = self.request.recv(BUFF_SIZE)</span><br><span class="line">            data += part</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(part) &lt; BUFF_SIZE:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> data.strip()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">send</span>(<span class="params">self, msg, newline=<span class="literal">True</span></span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">if</span> newline:</span><br><span class="line">                msg += <span class="string">b&#x27;\n&#x27;</span></span><br><span class="line">            self.request.sendall(msg)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">recv</span>(<span class="params">self, prompt=<span class="string">b&#x27;[-] &#x27;</span></span>):</span><br><span class="line">        self.send(prompt, newline=<span class="literal">False</span>)</span><br><span class="line">        <span class="keyword">return</span> self._recvall()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">proof_of_work</span>(<span class="params">self</span>):</span><br><span class="line">        proof = (<span class="string">&#x27;&#x27;</span>.join([choice(table) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">12</span>)])).encode()</span><br><span class="line">        sha = sha256(proof).hexdigest().encode()</span><br><span class="line">        self.send(<span class="string">b&quot;[+] sha256(XXXX+&quot;</span> + proof[<span class="number">4</span>:] + <span class="string">b&quot;) == &quot;</span> + sha)</span><br><span class="line">        XXXX = self.recv(prompt=<span class="string">b&#x27;[+] Plz Tell Me XXXX :&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(XXXX) != <span class="number">4</span> <span class="keyword">or</span> sha256(XXXX + proof[<span class="number">4</span>:]).hexdigest().encode() != sha:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sign</span>(<span class="params">self</span>):</span><br><span class="line">        m1 = <span class="string">b&#x27;I want to tell you a secret&#x27;</span></span><br><span class="line">        m2 = <span class="string">b&#x27;Can you find it?&#x27;</span></span><br><span class="line">        signature1 = myDSA.sign(m1)</span><br><span class="line">        signature2 = myDSA.sign(m2)</span><br><span class="line">        self.send(<span class="string">b&#x27;Your signature1 is:&#x27;</span> + <span class="built_in">str</span>(signature1).encode())</span><br><span class="line">        self.send(<span class="string">b&#x27;Your signature2 is:&#x27;</span> + <span class="built_in">str</span>(signature2).encode())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">verify</span>(<span class="params">self</span>):</span><br><span class="line">        m = self.recv(<span class="string">b&#x27;message:&#x27;</span>)</span><br><span class="line">        r = <span class="built_in">int</span>(self.recv(<span class="string">b&#x27;r:&#x27;</span>))</span><br><span class="line">        s = <span class="built_in">int</span>(self.recv(<span class="string">b&#x27;s:&#x27;</span>))</span><br><span class="line">        signature = (r, s)</span><br><span class="line">        <span class="keyword">if</span> m == <span class="string">b&quot;I&#x27;m Admin.I want flag.&quot;</span>:</span><br><span class="line">            <span class="keyword">if</span> myDSA.verify(m, signature):</span><br><span class="line">                self.send(<span class="string">b&#x27;Hello there.This is what you want.&#x27;</span>)</span><br><span class="line">                self.send(flag)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.send(<span class="string">b&#x27;Who are U?Get out!&#x27;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.send(<span class="string">b&#x27;Who are U?Get out!&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_public_key</span>(<span class="params">self</span>):</span><br><span class="line">        self.send(<span class="string">b&#x27;p = &#x27;</span> + <span class="built_in">str</span>(myDSA.p).encode())</span><br><span class="line">        self.send(<span class="string">b&#x27;q = &#x27;</span> + <span class="built_in">str</span>(myDSA.q).encode())</span><br><span class="line">        self.send(<span class="string">b&#x27;g = &#x27;</span> + <span class="built_in">str</span>(myDSA.g).encode())</span><br><span class="line">        self.send(<span class="string">b&#x27;y = &#x27;</span> + <span class="built_in">str</span>(myDSA.y).encode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">handle</span>(<span class="params">self</span>):</span><br><span class="line">        signal.alarm(<span class="number">30</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.proof_of_work():</span><br><span class="line">            self.send(<span class="string">b&#x27;You must pass the P0W!!!&#x27;</span>)</span><br><span class="line">            self.request.close()</span><br><span class="line">        <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">            self.send(MENU)</span><br><span class="line">            option = <span class="built_in">int</span>(self.recv(prompt=<span class="string">b&#x27;Give me your option:&#x27;</span>))</span><br><span class="line">            <span class="keyword">if</span> option == <span class="number">1</span>:</span><br><span class="line">                self.sign()</span><br><span class="line">            <span class="keyword">elif</span> option == <span class="number">2</span>:</span><br><span class="line">                self.verify()</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">elif</span> option == <span class="number">3</span>:</span><br><span class="line">                self.get_public_key()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        self.request.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadedServer</span>(socketserver.ThreadingMixIn, socketserver.TCPServer):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    HOST, PORT = <span class="string">&#x27;0.0.0.0&#x27;</span>, <span class="number">10001</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;HOST:POST &quot;</span> + HOST + <span class="string">&quot;:&quot;</span> + <span class="built_in">str</span>(PORT))</span><br><span class="line">    server = ThreadedServer((HOST, PORT), Task)</span><br><span class="line">    server.allow_reuse_address = <span class="literal">True</span></span><br><span class="line">    server.serve_forever()</span><br></pre></td></tr></table></figure>
<p>一道靶机交互题，代码较长，但是其实大部分是交互相关的函数，细读发现是很正常的DSA，需要用给定明文通过他的验签操作。（如果不熟悉DSA签名流程，一定要自行查阅了解一下）</p>
<p>检查代码发现漏洞出在sign，由于交互开始时，随机密钥k就不会再变动，因此两个明文共用了k用作签名，因此直接使用共享k攻击即可，具体原理也很简单，自行搜索共享k攻击即可。进阶的还有对线性k、指数k等相关攻击方式。</p>
<p>exp.py：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> sha256</span><br><span class="line"></span><br><span class="line">p = <span class="number">172961942888113119438093761564402163853274437530074061334853565231663662473345365517029153614577994838261528197758562341350007269014020447862968046418219322983982857376325091297503076457294884011022491521807290579653731078712552375942815577480924479760060089879761373677236785972440188569442167867715538948131</span></span><br><span class="line">q = <span class="number">1238294525750070611176801188652181858159488474961</span></span><br><span class="line">g = <span class="number">75657702601417227921344829575623735976532473731371029415534443940309702116075857552168402559956825576158353466597825895213717785384352099702983338787137184850387592826820271959589796127014544636714131043162304391677607332131259874984936943058742638800688694139378157588974460944304847089533750902878536046649</span></span><br><span class="line">y = <span class="number">7749296960818920297640684628219596188301310658741359444363507697372166821952159177715756651776536866582220227892407461198512231438360662343916445812054004711764127526569139925464723782772657462476688091598602960531766048824996984183046388253897618420503521674510979988799110962834514762035965219607971731464</span></span><br><span class="line"></span><br><span class="line">r1,s1 = (<span class="number">952312130113235199710494038379463278196320139331</span>, <span class="number">246708316787437486170638565016913560785356026546</span>)</span><br><span class="line">r2,s2 = (<span class="number">952312130113235199710494038379463278196320139331</span>, <span class="number">604408984593559575502554675534691666132540008638</span>)</span><br><span class="line"></span><br><span class="line">m1 = <span class="string">b&#x27;I want to tell you a secret&#x27;</span></span><br><span class="line">m2 = <span class="string">b&#x27;Can you find it?&#x27;</span></span><br><span class="line">h1 = bytes_to_long(sha256(m1).digest())</span><br><span class="line">h2 = bytes_to_long(sha256(m2).digest())</span><br><span class="line"></span><br><span class="line">k = (h1-h2)*inverse(s1-s2,q)</span><br><span class="line">x = (k*s1 - h1)*inverse(r1,q) % q</span><br><span class="line"></span><br><span class="line">m = <span class="string">b&quot;I&#x27;m Admin.I want flag.&quot;</span></span><br><span class="line">h = bytes_to_long(sha256(m).digest())</span><br><span class="line">r = <span class="built_in">pow</span>(g, k, p) % q</span><br><span class="line">s = inverse(k, q) * (h + x * r) % q</span><br><span class="line"><span class="built_in">print</span>(r)</span><br><span class="line"><span class="built_in">print</span>(s)</span><br></pre></td></tr></table></figure>
<p>(这题没有完整脚本，拿着这个r，s去交互就可以了；因为比较懒，当时直接用xshell连接上后手动过的sha256爆破，手动提交的r，s。。所以就没有完整pwntools交互脚本)</p>
<p>flag:</p>
<font size="4" color="red">cnss{1ts_Dr4nger0us_t0_u5eThe_Same_K}</font>

<p><br></p>
<p><br></p>
<p><br></p>
<h2 id="StrangeCurve"><a href="#StrangeCurve" class="headerlink" title="StrangeCurve"></a>StrangeCurve</h2><p>题目描述：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The Cruve is SOO0000 Strange!</span><br></pre></td></tr></table></figure>
<p>题目：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">rom Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> flag[:<span class="number">5</span>]==<span class="string">&#x27;cnss&#123;&#x27;</span> <span class="keyword">and</span> flag[-<span class="number">1</span>] == <span class="string">&#x27;&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line">flag_k = bytes_to_long(flag[<span class="number">5</span>:-<span class="number">1</span>].encode())</span><br><span class="line"></span><br><span class="line">p = <span class="number">1096126227998177188652856107362412783873814431647</span></span><br><span class="line">a = <span class="number">0</span></span><br><span class="line">b = <span class="number">5</span></span><br><span class="line">E = EllipticCurve(GF(p), [a, b])</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> E.order() == p </span><br><span class="line">base_point = E(<span class="number">626099523290649705896889901241128842906228328604</span>,<span class="number">886038875771695334071307095455656761758842526929</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> base_point <span class="keyword">in</span> E</span><br><span class="line"><span class="keyword">assert</span> flag_k &lt; p </span><br><span class="line"></span><br><span class="line">Q = flag_k*base_point</span><br><span class="line"><span class="built_in">print</span>(Q)</span><br><span class="line"></span><br><span class="line"><span class="comment"># (240653647745552223089451307742208085297121769374 : 1041806436100548540817642210994295951394712587396 : 1)</span></span><br></pre></td></tr></table></figure>
<p>椭圆曲线加密，下面这行是重要信息：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assert</span> E.order() == p </span><br></pre></td></tr></table></figure>
<p>因此可以确定是Smart’s attack。</p>
<p><br></p>
<p>exp.ipynb：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">SmartAttack</span>(<span class="params">P,Q,p</span>):</span><br><span class="line">    E = P.curve()</span><br><span class="line">    Eqp = EllipticCurve(Qp(p, <span class="number">2</span>), [ ZZ(t) + randint(<span class="number">0</span>,p)*p <span class="keyword">for</span> t <span class="keyword">in</span> E.a_invariants() ])</span><br><span class="line"></span><br><span class="line">    P_Qps = Eqp.lift_x(ZZ(P.xy()[<span class="number">0</span>]), <span class="built_in">all</span>=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">for</span> P_Qp <span class="keyword">in</span> P_Qps:</span><br><span class="line">        <span class="keyword">if</span> GF(p)(P_Qp.xy()[<span class="number">1</span>]) == P.xy()[<span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    Q_Qps = Eqp.lift_x(ZZ(Q.xy()[<span class="number">0</span>]), <span class="built_in">all</span>=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">for</span> Q_Qp <span class="keyword">in</span> Q_Qps:</span><br><span class="line">        <span class="keyword">if</span> GF(p)(Q_Qp.xy()[<span class="number">1</span>]) == Q.xy()[<span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    p_times_P = p*P_Qp</span><br><span class="line">    p_times_Q = p*Q_Qp</span><br><span class="line"></span><br><span class="line">    x_P,y_P = p_times_P.xy()</span><br><span class="line">    x_Q,y_Q = p_times_Q.xy()</span><br><span class="line"></span><br><span class="line">    phi_P = -(x_P/y_P)</span><br><span class="line">    phi_Q = -(x_Q/y_Q)</span><br><span class="line">    k = phi_Q/phi_P</span><br><span class="line">    <span class="keyword">return</span> ZZ(k)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p = <span class="number">1096126227998177188652856107362412783873814431647</span></span><br><span class="line">a = <span class="number">0</span></span><br><span class="line">b = <span class="number">5</span></span><br><span class="line">E = EllipticCurve(GF(p), [a, b])</span><br><span class="line"></span><br><span class="line">P = E(<span class="number">626099523290649705896889901241128842906228328604</span>,<span class="number">886038875771695334071307095455656761758842526929</span>)</span><br><span class="line">Q = E(<span class="number">240653647745552223089451307742208085297121769374</span>,<span class="number">1041806436100548540817642210994295951394712587396</span>)</span><br><span class="line"></span><br><span class="line">n = SmartAttack(P, Q, p)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;cnss&#123;&quot;</span> + <span class="built_in">str</span>(long_to_bytes(n))[<span class="number">2</span>:-<span class="number">1</span>] + <span class="string">&quot;&#125;&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>flag:</p>
<font size="4" color="red">cnss{DLPise45y_if5pecia1}</font>

<p><br></p>
<p><br></p>
<p><br></p>
<h2 id="一🔪一个牛头人"><a href="#一🔪一个牛头人" class="headerlink" title="一🔪一个牛头人"></a>一🔪一个牛头人</h2><p>题目描述：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">学了NTRU,就要NTR u(❌)</span><br></pre></td></tr></table></figure>
<p>题目：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> shuffle, getrandbits</span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line">Zx = PolynomialRing(ZZ, <span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">x = Zx.gen()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">convolution</span>(<span class="params">f, g, R</span>):</span><br><span class="line">    <span class="keyword">return</span> (f * g) % R</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">balancedmod</span>(<span class="params">f, q, R</span>):</span><br><span class="line">    g = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: ((x + q//<span class="number">2</span>) % q) - q//<span class="number">2</span>, f.<span class="built_in">list</span>()))</span><br><span class="line">    <span class="keyword">return</span> Zx(g) % R</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">random_poly</span>(<span class="params">n, d1, d2</span>):</span><br><span class="line">    <span class="keyword">assert</span> d1 + d2 &lt;= n</span><br><span class="line">    result = d1 * [<span class="number">1</span>] + d2 * [-<span class="number">1</span>] + (n - d1 - d2) * [<span class="number">0</span>]</span><br><span class="line">    shuffle(result)</span><br><span class="line">    <span class="keyword">return</span> Zx(result)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">invert_poly_mod_prime</span>(<span class="params">f, R, p</span>):</span><br><span class="line">    T = Zx.change_ring(Integers(p)).quotient(R)</span><br><span class="line">    <span class="keyword">return</span> Zx(lift(<span class="number">1</span> / T(f)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">invert_poly_mod_powerof2</span>(<span class="params">f, R, q</span>):  <span class="comment"># Hensel Lemma </span></span><br><span class="line">    g = invert_poly_mod_prime(f, R, <span class="number">2</span>)</span><br><span class="line">    e = log(q, <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, e):</span><br><span class="line">        g = ((<span class="number">2</span> * g - f * g ** <span class="number">2</span>) % R) % q</span><br><span class="line">    <span class="keyword">return</span> g</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NTRUCipher</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, N, p, q, d</span>):</span><br><span class="line">        self.N = N</span><br><span class="line">        self.p = p</span><br><span class="line">        self.q = q</span><br><span class="line">        self.d = d</span><br><span class="line">        self.R = x ** N - <span class="number">1</span></span><br><span class="line">        <span class="comment"># key generation</span></span><br><span class="line">        self.g = random_poly(self.N, d, d)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                self.f = random_poly(self.N, d + <span class="number">1</span>, d)</span><br><span class="line">                self.fp = invert_poly_mod_prime(self.f, self.R, self.p)</span><br><span class="line">                self.fq = invert_poly_mod_powerof2(self.f, self.R, self.q)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">        self.h = balancedmod(self.p * convolution(self.fq, self.g, self.R), self.q, self.R)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getPubKey</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.h</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">encrypt</span>(<span class="params">self, m</span>):</span><br><span class="line">        r = random_poly(self.N, self.d, self.d)</span><br><span class="line">        <span class="keyword">return</span> balancedmod(convolution(self.h, r, self.R) + m, self.q, self.R)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">decrypt</span>(<span class="params">self, c</span>):</span><br><span class="line">        a = balancedmod(convolution(c, self.f, self.R), self.q, self.R)</span><br><span class="line">        <span class="keyword">return</span> balancedmod(convolution(a, self.fp, self.R), self.p, self.R)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">encode</span>(<span class="params">self, val</span>):</span><br><span class="line">        poly = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.N):</span><br><span class="line">            poly += ((val % self.p) - self.p // <span class="number">2</span>) * (x ** i)</span><br><span class="line">            val //= self.p</span><br><span class="line">        <span class="keyword">return</span> poly</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">decode</span>(<span class="params">self, poly</span>):</span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        ll = poly.<span class="built_in">list</span>()</span><br><span class="line">        <span class="keyword">for</span> idx, val <span class="keyword">in</span> <span class="built_in">enumerate</span>(ll):</span><br><span class="line">            result += (val + self.p // <span class="number">2</span>) * (self.p ** idx)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">poly_from_list</span>(<span class="params">self, l: <span class="built_in">list</span></span>):</span><br><span class="line">        <span class="keyword">return</span> Zx(l)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    N = <span class="number">160</span></span><br><span class="line">    d = <span class="number">30</span></span><br><span class="line">    p = <span class="number">3</span></span><br><span class="line">    q = <span class="number">65536</span></span><br><span class="line"></span><br><span class="line">    cipher = NTRUCipher(N, p, q, d) </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;[PubKey]---------&quot;</span>)</span><br><span class="line">    h = cipher.getPubKey()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;h = <span class="subst">&#123;h&#125;</span>&#x27;</span>)</span><br><span class="line">    msg = bytes_to_long(flag)</span><br><span class="line">    encode_msg = cipher.encode(msg)</span><br><span class="line">    c = cipher.encrypt(encode_msg)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;[Cipher]---------&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;c = <span class="subst">&#123;c&#125;</span>&#x27;</span>)</span><br><span class="line">    mm = cipher.decrypt(c)</span><br><span class="line">    decode_msg = cipher.decode(mm)</span><br><span class="line">    <span class="keyword">assert</span> decode_msg == msg</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">[PubKey]---------</span></span><br><span class="line"><span class="string">h = -11891*x^159 + 16347*x^158 - 32137*x^157 + 14988*x^156 + 16657*x^155 - 25785*x^154 - 21976*x^153 - 31745*x^152 - 4232*x^151 + 29569*x^150 + 27140*x^149 + 19617*x^148 - 16656*x^147 + 8925*x^146 + 8728*x^145 - 8802*x^144 - 10794*x^143 - 28159*x^142 - 6454*x^141 - 10259*x^140 - 19169*x^139 - 14357*x^138 + 3501*x^137 + 9885*x^136 - 7441*x^135 + 18268*x^134 - 27183*x^133 + 26085*x^132 + 19147*x^131 + 17153*x^130 - 22887*x^129 + 32476*x^128 - 21698*x^127 + 19138*x^126 + 11585*x^125 + 22755*x^124 - 5920*x^123 + 7581*x^122 + 25973*x^121 + 13787*x^120 - 22762*x^119 + 29207*x^118 - 17916*x^117 - 11502*x^116 + 18275*x^115 + 318*x^114 - 6890*x^113 - 22751*x^112 - 27677*x^111 - 11114*x^110 + 8623*x^109 - 15725*x^108 - 6835*x^107 - 8288*x^106 - 5235*x^105 - 28697*x^104 + 10696*x^103 + 17117*x^102 + 24696*x^101 - 7801*x^100 - 31874*x^99 - 17668*x^98 - 11204*x^97 + 19147*x^96 + 24644*x^95 - 29380*x^94 - 26237*x^93 - 27390*x^92 + 19982*x^91 + 4074*x^90 - 17248*x^89 - 11027*x^88 - 32690*x^87 + 5124*x^86 - 20823*x^85 - 11779*x^84 + 13781*x^83 + 29356*x^82 - 9740*x^81 - 31484*x^80 - 540*x^79 + 32360*x^78 + 24795*x^77 - 8864*x^76 + 17363*x^75 + 9670*x^74 + 32268*x^73 + 17961*x^72 + 6388*x^71 + 580*x^70 + 128*x^69 + 339*x^68 + 3412*x^67 - 4519*x^66 - 25056*x^65 + 6096*x^64 + 18720*x^63 - 5338*x^62 + 16910*x^61 + 3353*x^60 + 15433*x^59 - 28053*x^58 - 18883*x^57 + 7688*x^56 - 31198*x^55 + 9950*x^54 - 9388*x^53 + 21235*x^52 + 2847*x^51 + 24383*x^50 + 19431*x^49 + 21244*x^48 - 8498*x^47 - 28998*x^46 + 962*x^45 + 20579*x^44 + 28002*x^43 - 6040*x^42 + 4241*x^41 + 11655*x^40 - 32419*x^39 + 21531*x^38 + 7348*x^37 - 5503*x^36 + 29820*x^35 + 28896*x^34 + 8754*x^33 + 17978*x^32 + 7552*x^31 + 27240*x^30 - 29515*x^29 - 20322*x^28 + 2201*x^27 + 8857*x^26 - 50*x^25 - 3780*x^24 - 12138*x^23 + 10893*x^22 + 23133*x^21 + 6142*x^20 - 23798*x^19 - 15236*x^18 + 32564*x^17 + 25683*x^16 - 24010*x^15 - 4355*x^14 + 22552*x^13 - 27155*x^12 + 27649*x^11 + 17781*x^10 + 7115*x^9 + 27465*x^8 - 4369*x^7 + 24882*x^6 - 11675*x^5 - 612*x^4 + 12361*x^3 + 20120*x^2 + 6190*x - 10843</span></span><br><span class="line"><span class="string">[Cipher]---------</span></span><br><span class="line"><span class="string">c = -26801*x^159 - 25103*x^158 + 29811*x^157 - 12251*x^156 - 13386*x^155 - 28030*x^154 - 16511*x^153 + 23761*x^152 + 28329*x^151 - 16406*x^150 + 30931*x^149 + 5326*x^148 + 19877*x^147 - 23165*x^146 - 31540*x^145 - 7923*x^144 + 5880*x^143 - 27078*x^142 - 25436*x^141 - 17162*x^140 + 1471*x^139 + 14486*x^138 + 7702*x^137 - 29890*x^136 + 29315*x^135 + 558*x^134 - 22429*x^133 - 361*x^132 + 19049*x^131 - 30437*x^130 - 32610*x^129 - 3024*x^128 - 4313*x^127 + 29174*x^126 - 2837*x^125 - 2812*x^124 + 13450*x^123 - 15001*x^122 - 25791*x^121 - 8702*x^120 - 4968*x^119 - 15340*x^118 + 31744*x^117 - 32478*x^116 + 19737*x^115 - 12629*x^114 - 27847*x^113 + 27322*x^112 - 31375*x^111 + 14777*x^110 + 29825*x^109 - 25883*x^108 - 13335*x^107 + 32517*x^106 + 14871*x^105 - 7287*x^104 + 13398*x^103 - 32710*x^102 + 20805*x^101 + 29734*x^100 - 14579*x^99 + 17483*x^98 - 16864*x^97 - 26745*x^96 + 3254*x^95 + 7280*x^94 - 29046*x^93 - 7531*x^92 - 8791*x^91 + 15033*x^90 - 1125*x^89 - 14713*x^88 - 12273*x^87 + 8616*x^86 + 2486*x^85 + 31810*x^84 + 27795*x^83 - 21731*x^82 + 21743*x^81 - 27595*x^80 - 3592*x^79 - 27206*x^78 - 32156*x^77 + 32124*x^76 - 11212*x^75 - 6662*x^74 - 23103*x^73 - 3660*x^72 - 31043*x^71 - 17131*x^70 + 24544*x^69 - 32326*x^68 - 31047*x^67 + 19814*x^66 + 10874*x^65 - 8449*x^64 + 11744*x^63 + 2245*x^62 - 967*x^61 + 9120*x^60 + 8983*x^59 - 24573*x^58 + 24885*x^57 + 15649*x^56 - 18970*x^55 + 7354*x^54 - 12282*x^53 - 22474*x^52 + 4395*x^51 + 8428*x^50 - 32592*x^49 + 25980*x^48 - 4599*x^47 + 16310*x^46 + 18559*x^45 + 22897*x^44 + 19080*x^43 - 26065*x^42 - 9*x^41 + 29202*x^40 + 2121*x^39 - 5004*x^38 + 5299*x^37 - 28301*x^36 - 13519*x^35 + 24241*x^34 + 529*x^33 - 20574*x^32 - 27391*x^31 + 31976*x^30 + 22824*x^29 - 31410*x^28 - 20976*x^27 + 21661*x^26 - 15132*x^25 + 1905*x^24 - 30870*x^23 + 18109*x^22 - 17373*x^21 + 5342*x^20 - 22447*x^19 + 1893*x^18 - 17545*x^17 + 30097*x^16 - 21731*x^15 + 17390*x^14 + 10991*x^13 - 5384*x^12 + 15960*x^11 + 24268*x^10 - 29867*x^9 + 22532*x^8 + 10133*x^7 - 26576*x^6 - 5742*x^5 - 16252*x^4 + 13019*x^3 - 25984*x^2 + 14004*x + 22500</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<p>一个普通的NTRU多项式密码，也是与格有关的，其具体原理可以参考：(甚至详细阐述了每个函数的作用)</p>
<p><a href="http://blog.k1rit0.eu.org/2021/03/28/Translation-of-LatticeHacks/">Translation of LatticeHacks · K1rit0’s Blog</a> </p>
<p><br></p>
<p>exp.ipynb：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">n = <span class="number">160</span></span><br><span class="line">d = <span class="number">30</span></span><br><span class="line">p = <span class="number">3</span></span><br><span class="line">q = <span class="number">65536</span></span><br><span class="line">PR = PolynomialRing(ZZ, name = <span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">x = PR.gen()</span><br><span class="line">R = PR.quotient_ring(x ^ n - <span class="number">1</span>, names = <span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">y = R.gen()</span><br><span class="line"></span><br><span class="line">pubkey = -<span class="number">11891</span>*x^<span class="number">159</span> + <span class="number">16347</span>*x^<span class="number">158</span> - <span class="number">32137</span>*x^<span class="number">157</span> + <span class="number">14988</span>*x^<span class="number">156</span> + <span class="number">16657</span>*x^<span class="number">155</span> - <span class="number">25785</span>*x^<span class="number">154</span> - <span class="number">21976</span>*x^<span class="number">153</span> - <span class="number">31745</span>*x^<span class="number">152</span> - <span class="number">4232</span>*x^<span class="number">151</span> + <span class="number">29569</span>*x^<span class="number">150</span> + <span class="number">27140</span>*x^<span class="number">149</span> + <span class="number">19617</span>*x^<span class="number">148</span> - <span class="number">16656</span>*x^<span class="number">147</span> + <span class="number">8925</span>*x^<span class="number">146</span> + <span class="number">8728</span>*x^<span class="number">145</span> - <span class="number">8802</span>*x^<span class="number">144</span> - <span class="number">10794</span>*x^<span class="number">143</span> - <span class="number">28159</span>*x^<span class="number">142</span> - <span class="number">6454</span>*x^<span class="number">141</span> - <span class="number">10259</span>*x^<span class="number">140</span> - <span class="number">19169</span>*x^<span class="number">139</span> - <span class="number">14357</span>*x^<span class="number">138</span> + <span class="number">3501</span>*x^<span class="number">137</span> + <span class="number">9885</span>*x^<span class="number">136</span> - <span class="number">7441</span>*x^<span class="number">135</span> + <span class="number">18268</span>*x^<span class="number">134</span> - <span class="number">27183</span>*x^<span class="number">133</span> + <span class="number">26085</span>*x^<span class="number">132</span> + <span class="number">19147</span>*x^<span class="number">131</span> + <span class="number">17153</span>*x^<span class="number">130</span> - <span class="number">22887</span>*x^<span class="number">129</span> + <span class="number">32476</span>*x^<span class="number">128</span> - <span class="number">21698</span>*x^<span class="number">127</span> + <span class="number">19138</span>*x^<span class="number">126</span> + <span class="number">11585</span>*x^<span class="number">125</span> + <span class="number">22755</span>*x^<span class="number">124</span> - <span class="number">5920</span>*x^<span class="number">123</span> + <span class="number">7581</span>*x^<span class="number">122</span> + <span class="number">25973</span>*x^<span class="number">121</span> + <span class="number">13787</span>*x^<span class="number">120</span> - <span class="number">22762</span>*x^<span class="number">119</span> + <span class="number">29207</span>*x^<span class="number">118</span> - <span class="number">17916</span>*x^<span class="number">117</span> - <span class="number">11502</span>*x^<span class="number">116</span> + <span class="number">18275</span>*x^<span class="number">115</span> + <span class="number">318</span>*x^<span class="number">114</span> - <span class="number">6890</span>*x^<span class="number">113</span> - <span class="number">22751</span>*x^<span class="number">112</span> - <span class="number">27677</span>*x^<span class="number">111</span> - <span class="number">11114</span>*x^<span class="number">110</span> + <span class="number">8623</span>*x^<span class="number">109</span> - <span class="number">15725</span>*x^<span class="number">108</span> - <span class="number">6835</span>*x^<span class="number">107</span> - <span class="number">8288</span>*x^<span class="number">106</span> - <span class="number">5235</span>*x^<span class="number">105</span> - <span class="number">28697</span>*x^<span class="number">104</span> + <span class="number">10696</span>*x^<span class="number">103</span> + <span class="number">17117</span>*x^<span class="number">102</span> + <span class="number">24696</span>*x^<span class="number">101</span> - <span class="number">7801</span>*x^<span class="number">100</span> - <span class="number">31874</span>*x^<span class="number">99</span> - <span class="number">17668</span>*x^<span class="number">98</span> - <span class="number">11204</span>*x^<span class="number">97</span> + <span class="number">19147</span>*x^<span class="number">96</span> + <span class="number">24644</span>*x^<span class="number">95</span> - <span class="number">29380</span>*x^<span class="number">94</span> - <span class="number">26237</span>*x^<span class="number">93</span> - <span class="number">27390</span>*x^<span class="number">92</span> + <span class="number">19982</span>*x^<span class="number">91</span> + <span class="number">4074</span>*x^<span class="number">90</span> - <span class="number">17248</span>*x^<span class="number">89</span> - <span class="number">11027</span>*x^<span class="number">88</span> - <span class="number">32690</span>*x^<span class="number">87</span> + <span class="number">5124</span>*x^<span class="number">86</span> - <span class="number">20823</span>*x^<span class="number">85</span> - <span class="number">11779</span>*x^<span class="number">84</span> + <span class="number">13781</span>*x^<span class="number">83</span> + <span class="number">29356</span>*x^<span class="number">82</span> - <span class="number">9740</span>*x^<span class="number">81</span> - <span class="number">31484</span>*x^<span class="number">80</span> - <span class="number">540</span>*x^<span class="number">79</span> + <span class="number">32360</span>*x^<span class="number">78</span> + <span class="number">24795</span>*x^<span class="number">77</span> - <span class="number">8864</span>*x^<span class="number">76</span> + <span class="number">17363</span>*x^<span class="number">75</span> + <span class="number">9670</span>*x^<span class="number">74</span> + <span class="number">32268</span>*x^<span class="number">73</span> + <span class="number">17961</span>*x^<span class="number">72</span> + <span class="number">6388</span>*x^<span class="number">71</span> + <span class="number">580</span>*x^<span class="number">70</span> + <span class="number">128</span>*x^<span class="number">69</span> + <span class="number">339</span>*x^<span class="number">68</span> + <span class="number">3412</span>*x^<span class="number">67</span> - <span class="number">4519</span>*x^<span class="number">66</span> - <span class="number">25056</span>*x^<span class="number">65</span> + <span class="number">6096</span>*x^<span class="number">64</span> + <span class="number">18720</span>*x^<span class="number">63</span> - <span class="number">5338</span>*x^<span class="number">62</span> + <span class="number">16910</span>*x^<span class="number">61</span> + <span class="number">3353</span>*x^<span class="number">60</span> + <span class="number">15433</span>*x^<span class="number">59</span> - <span class="number">28053</span>*x^<span class="number">58</span> - <span class="number">18883</span>*x^<span class="number">57</span> + <span class="number">7688</span>*x^<span class="number">56</span> - <span class="number">31198</span>*x^<span class="number">55</span> + <span class="number">9950</span>*x^<span class="number">54</span> - <span class="number">9388</span>*x^<span class="number">53</span> + <span class="number">21235</span>*x^<span class="number">52</span> + <span class="number">2847</span>*x^<span class="number">51</span> + <span class="number">24383</span>*x^<span class="number">50</span> + <span class="number">19431</span>*x^<span class="number">49</span> + <span class="number">21244</span>*x^<span class="number">48</span> - <span class="number">8498</span>*x^<span class="number">47</span> - <span class="number">28998</span>*x^<span class="number">46</span> + <span class="number">962</span>*x^<span class="number">45</span> + <span class="number">20579</span>*x^<span class="number">44</span> + <span class="number">28002</span>*x^<span class="number">43</span> - <span class="number">6040</span>*x^<span class="number">42</span> + <span class="number">4241</span>*x^<span class="number">41</span> + <span class="number">11655</span>*x^<span class="number">40</span> - <span class="number">32419</span>*x^<span class="number">39</span> + <span class="number">21531</span>*x^<span class="number">38</span> + <span class="number">7348</span>*x^<span class="number">37</span> - <span class="number">5503</span>*x^<span class="number">36</span> + <span class="number">29820</span>*x^<span class="number">35</span> + <span class="number">28896</span>*x^<span class="number">34</span> + <span class="number">8754</span>*x^<span class="number">33</span> + <span class="number">17978</span>*x^<span class="number">32</span> + <span class="number">7552</span>*x^<span class="number">31</span> + <span class="number">27240</span>*x^<span class="number">30</span> - <span class="number">29515</span>*x^<span class="number">29</span> - <span class="number">20322</span>*x^<span class="number">28</span> + <span class="number">2201</span>*x^<span class="number">27</span> + <span class="number">8857</span>*x^<span class="number">26</span> - <span class="number">50</span>*x^<span class="number">25</span> - <span class="number">3780</span>*x^<span class="number">24</span> - <span class="number">12138</span>*x^<span class="number">23</span> + <span class="number">10893</span>*x^<span class="number">22</span> + <span class="number">23133</span>*x^<span class="number">21</span> + <span class="number">6142</span>*x^<span class="number">20</span> - <span class="number">23798</span>*x^<span class="number">19</span> - <span class="number">15236</span>*x^<span class="number">18</span> + <span class="number">32564</span>*x^<span class="number">17</span> + <span class="number">25683</span>*x^<span class="number">16</span> - <span class="number">24010</span>*x^<span class="number">15</span> - <span class="number">4355</span>*x^<span class="number">14</span> + <span class="number">22552</span>*x^<span class="number">13</span> - <span class="number">27155</span>*x^<span class="number">12</span> + <span class="number">27649</span>*x^<span class="number">11</span> + <span class="number">17781</span>*x^<span class="number">10</span> + <span class="number">7115</span>*x^<span class="number">9</span> + <span class="number">27465</span>*x^<span class="number">8</span> - <span class="number">4369</span>*x^<span class="number">7</span> + <span class="number">24882</span>*x^<span class="number">6</span> - <span class="number">11675</span>*x^<span class="number">5</span> - <span class="number">612</span>*x^<span class="number">4</span> + <span class="number">12361</span>*x^<span class="number">3</span> + <span class="number">20120</span>*x^<span class="number">2</span> + <span class="number">6190</span>*x - <span class="number">10843</span></span><br><span class="line">pubkey = R(pubkey)</span><br><span class="line">c = -<span class="number">26801</span>*x^<span class="number">159</span> - <span class="number">25103</span>*x^<span class="number">158</span> + <span class="number">29811</span>*x^<span class="number">157</span> - <span class="number">12251</span>*x^<span class="number">156</span> - <span class="number">13386</span>*x^<span class="number">155</span> - <span class="number">28030</span>*x^<span class="number">154</span> - <span class="number">16511</span>*x^<span class="number">153</span> + <span class="number">23761</span>*x^<span class="number">152</span> + <span class="number">28329</span>*x^<span class="number">151</span> - <span class="number">16406</span>*x^<span class="number">150</span> + <span class="number">30931</span>*x^<span class="number">149</span> + <span class="number">5326</span>*x^<span class="number">148</span> + <span class="number">19877</span>*x^<span class="number">147</span> - <span class="number">23165</span>*x^<span class="number">146</span> - <span class="number">31540</span>*x^<span class="number">145</span> - <span class="number">7923</span>*x^<span class="number">144</span> + <span class="number">5880</span>*x^<span class="number">143</span> - <span class="number">27078</span>*x^<span class="number">142</span> - <span class="number">25436</span>*x^<span class="number">141</span> - <span class="number">17162</span>*x^<span class="number">140</span> + <span class="number">1471</span>*x^<span class="number">139</span> + <span class="number">14486</span>*x^<span class="number">138</span> + <span class="number">7702</span>*x^<span class="number">137</span> - <span class="number">29890</span>*x^<span class="number">136</span> + <span class="number">29315</span>*x^<span class="number">135</span> + <span class="number">558</span>*x^<span class="number">134</span> - <span class="number">22429</span>*x^<span class="number">133</span> - <span class="number">361</span>*x^<span class="number">132</span> + <span class="number">19049</span>*x^<span class="number">131</span> - <span class="number">30437</span>*x^<span class="number">130</span> - <span class="number">32610</span>*x^<span class="number">129</span> - <span class="number">3024</span>*x^<span class="number">128</span> - <span class="number">4313</span>*x^<span class="number">127</span> + <span class="number">29174</span>*x^<span class="number">126</span> - <span class="number">2837</span>*x^<span class="number">125</span> - <span class="number">2812</span>*x^<span class="number">124</span> + <span class="number">13450</span>*x^<span class="number">123</span> - <span class="number">15001</span>*x^<span class="number">122</span> - <span class="number">25791</span>*x^<span class="number">121</span> - <span class="number">8702</span>*x^<span class="number">120</span> - <span class="number">4968</span>*x^<span class="number">119</span> - <span class="number">15340</span>*x^<span class="number">118</span> + <span class="number">31744</span>*x^<span class="number">117</span> - <span class="number">32478</span>*x^<span class="number">116</span> + <span class="number">19737</span>*x^<span class="number">115</span> - <span class="number">12629</span>*x^<span class="number">114</span> - <span class="number">27847</span>*x^<span class="number">113</span> + <span class="number">27322</span>*x^<span class="number">112</span> - <span class="number">31375</span>*x^<span class="number">111</span> + <span class="number">14777</span>*x^<span class="number">110</span> + <span class="number">29825</span>*x^<span class="number">109</span> - <span class="number">25883</span>*x^<span class="number">108</span> - <span class="number">13335</span>*x^<span class="number">107</span> + <span class="number">32517</span>*x^<span class="number">106</span> + <span class="number">14871</span>*x^<span class="number">105</span> - <span class="number">7287</span>*x^<span class="number">104</span> + <span class="number">13398</span>*x^<span class="number">103</span> - <span class="number">32710</span>*x^<span class="number">102</span> + <span class="number">20805</span>*x^<span class="number">101</span> + <span class="number">29734</span>*x^<span class="number">100</span> - <span class="number">14579</span>*x^<span class="number">99</span> + <span class="number">17483</span>*x^<span class="number">98</span> - <span class="number">16864</span>*x^<span class="number">97</span> - <span class="number">26745</span>*x^<span class="number">96</span> + <span class="number">3254</span>*x^<span class="number">95</span> + <span class="number">7280</span>*x^<span class="number">94</span> - <span class="number">29046</span>*x^<span class="number">93</span> - <span class="number">7531</span>*x^<span class="number">92</span> - <span class="number">8791</span>*x^<span class="number">91</span> + <span class="number">15033</span>*x^<span class="number">90</span> - <span class="number">1125</span>*x^<span class="number">89</span> - <span class="number">14713</span>*x^<span class="number">88</span> - <span class="number">12273</span>*x^<span class="number">87</span> + <span class="number">8616</span>*x^<span class="number">86</span> + <span class="number">2486</span>*x^<span class="number">85</span> + <span class="number">31810</span>*x^<span class="number">84</span> + <span class="number">27795</span>*x^<span class="number">83</span> - <span class="number">21731</span>*x^<span class="number">82</span> + <span class="number">21743</span>*x^<span class="number">81</span> - <span class="number">27595</span>*x^<span class="number">80</span> - <span class="number">3592</span>*x^<span class="number">79</span> - <span class="number">27206</span>*x^<span class="number">78</span> - <span class="number">32156</span>*x^<span class="number">77</span> + <span class="number">32124</span>*x^<span class="number">76</span> - <span class="number">11212</span>*x^<span class="number">75</span> - <span class="number">6662</span>*x^<span class="number">74</span> - <span class="number">23103</span>*x^<span class="number">73</span> - <span class="number">3660</span>*x^<span class="number">72</span> - <span class="number">31043</span>*x^<span class="number">71</span> - <span class="number">17131</span>*x^<span class="number">70</span> + <span class="number">24544</span>*x^<span class="number">69</span> - <span class="number">32326</span>*x^<span class="number">68</span> - <span class="number">31047</span>*x^<span class="number">67</span> + <span class="number">19814</span>*x^<span class="number">66</span> + <span class="number">10874</span>*x^<span class="number">65</span> - <span class="number">8449</span>*x^<span class="number">64</span> + <span class="number">11744</span>*x^<span class="number">63</span> + <span class="number">2245</span>*x^<span class="number">62</span> - <span class="number">967</span>*x^<span class="number">61</span> + <span class="number">9120</span>*x^<span class="number">60</span> + <span class="number">8983</span>*x^<span class="number">59</span> - <span class="number">24573</span>*x^<span class="number">58</span> + <span class="number">24885</span>*x^<span class="number">57</span> + <span class="number">15649</span>*x^<span class="number">56</span> - <span class="number">18970</span>*x^<span class="number">55</span> + <span class="number">7354</span>*x^<span class="number">54</span> - <span class="number">12282</span>*x^<span class="number">53</span> - <span class="number">22474</span>*x^<span class="number">52</span> + <span class="number">4395</span>*x^<span class="number">51</span> + <span class="number">8428</span>*x^<span class="number">50</span> - <span class="number">32592</span>*x^<span class="number">49</span> + <span class="number">25980</span>*x^<span class="number">48</span> - <span class="number">4599</span>*x^<span class="number">47</span> + <span class="number">16310</span>*x^<span class="number">46</span> + <span class="number">18559</span>*x^<span class="number">45</span> + <span class="number">22897</span>*x^<span class="number">44</span> + <span class="number">19080</span>*x^<span class="number">43</span> - <span class="number">26065</span>*x^<span class="number">42</span> - <span class="number">9</span>*x^<span class="number">41</span> + <span class="number">29202</span>*x^<span class="number">40</span> + <span class="number">2121</span>*x^<span class="number">39</span> - <span class="number">5004</span>*x^<span class="number">38</span> + <span class="number">5299</span>*x^<span class="number">37</span> - <span class="number">28301</span>*x^<span class="number">36</span> - <span class="number">13519</span>*x^<span class="number">35</span> + <span class="number">24241</span>*x^<span class="number">34</span> + <span class="number">529</span>*x^<span class="number">33</span> - <span class="number">20574</span>*x^<span class="number">32</span> - <span class="number">27391</span>*x^<span class="number">31</span> + <span class="number">31976</span>*x^<span class="number">30</span> + <span class="number">22824</span>*x^<span class="number">29</span> - <span class="number">31410</span>*x^<span class="number">28</span> - <span class="number">20976</span>*x^<span class="number">27</span> + <span class="number">21661</span>*x^<span class="number">26</span> - <span class="number">15132</span>*x^<span class="number">25</span> + <span class="number">1905</span>*x^<span class="number">24</span> - <span class="number">30870</span>*x^<span class="number">23</span> + <span class="number">18109</span>*x^<span class="number">22</span> - <span class="number">17373</span>*x^<span class="number">21</span> + <span class="number">5342</span>*x^<span class="number">20</span> - <span class="number">22447</span>*x^<span class="number">19</span> + <span class="number">1893</span>*x^<span class="number">18</span> - <span class="number">17545</span>*x^<span class="number">17</span> + <span class="number">30097</span>*x^<span class="number">16</span> - <span class="number">21731</span>*x^<span class="number">15</span> + <span class="number">17390</span>*x^<span class="number">14</span> + <span class="number">10991</span>*x^<span class="number">13</span> - <span class="number">5384</span>*x^<span class="number">12</span> + <span class="number">15960</span>*x^<span class="number">11</span> + <span class="number">24268</span>*x^<span class="number">10</span> - <span class="number">29867</span>*x^<span class="number">9</span> + <span class="number">22532</span>*x^<span class="number">8</span> + <span class="number">10133</span>*x^<span class="number">7</span> - <span class="number">26576</span>*x^<span class="number">6</span> - <span class="number">5742</span>*x^<span class="number">5</span> - <span class="number">16252</span>*x^<span class="number">4</span> + <span class="number">13019</span>*x^<span class="number">3</span> - <span class="number">25984</span>*x^<span class="number">2</span> + <span class="number">14004</span>*x + <span class="number">22500</span></span><br><span class="line">c = R(c)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">balance_mod</span>(<span class="params">f, q</span>):</span><br><span class="line">    g = <span class="built_in">list</span>(((f[i] + q // <span class="number">2</span>) % q) - q // <span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n))</span><br><span class="line">    <span class="keyword">return</span> R(g)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">invert_mod_prime</span>(<span class="params">f, p</span>):</span><br><span class="line">    T = R.base().change_ring(Integers(p)).quotient(x ^ n - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> R(<span class="number">1</span> / T(f))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dec</span>(<span class="params">c, prikey</span>):</span><br><span class="line">    f, fp = prikey</span><br><span class="line">    a = balance_mod(c * f, q)</span><br><span class="line">    <span class="keyword">return</span> balance_mod(a * fp, p)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">crack</span>(<span class="params">pubkey, c</span>):</span><br><span class="line">    A = Matrix(ZZ, <span class="number">2</span> * n, <span class="number">2</span> * n)</span><br><span class="line">    hp = inverse(p, q) * pubkey</span><br><span class="line">    hp_list = <span class="built_in">list</span>(hp)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        A[i, i] = q</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n, <span class="number">2</span> * n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            A[i, j] = hp_list[(j - i) % n]</span><br><span class="line">        A[i, i] = <span class="number">1</span></span><br><span class="line">    AL = A.BKZ()</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> AL:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            f = R(row[n:].<span class="built_in">list</span>())</span><br><span class="line">            fp = invert_mod_prime(f, p)</span><br><span class="line">            <span class="keyword">return</span> dec(c, (f, fp))</span><br><span class="line">            <span class="keyword">break</span> <span class="comment"># may failed with shortest vector(return more if failed)</span></span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        </span><br><span class="line">m = crack(pubkey, c)</span><br><span class="line"></span><br><span class="line">m = m.<span class="built_in">list</span>()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(m)):</span><br><span class="line">    m[i] += <span class="number">1</span></span><br><span class="line">    m[i] = <span class="built_in">str</span>(m[i])</span><br><span class="line">str1 = <span class="string">&quot;&quot;</span>.join(m[::-<span class="number">1</span>])</span><br><span class="line">temp = <span class="built_in">int</span>(str1,<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(temp))</span><br></pre></td></tr></table></figure>
<p>(可能需要跑几分钟)</p>
<p>flag:</p>
<font size="4" color="red">cnss{NTRU_w1th_un5afe_par4}</font>

<p><br></p>
<p><br></p>
<p><br></p>
<h2 id="MidLattice"><a href="#MidLattice" class="headerlink" title="MidLattice"></a>MidLattice</h2><p>题目描述：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">看上去像gcd，但是有区别</span><br></pre></td></tr></table></figure>
<p>题目：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line">pbit = <span class="number">500</span></span><br><span class="line">qbit = <span class="number">550</span></span><br><span class="line">rbit = <span class="number">200</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_sample</span>():</span><br><span class="line">    x_list  = []</span><br><span class="line">    p = getPrime(pbit)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">120</span>):</span><br><span class="line">        q = getPrime(qbit)</span><br><span class="line">        r = getPrime(rbit)</span><br><span class="line">        x_list.append(q*p + <span class="number">2</span>*r)</span><br><span class="line">    <span class="keyword">return</span> x_list,p</span><br><span class="line">sample,p = get_sample()</span><br><span class="line">flag = <span class="string">&#x27;cnss&#123;&#x27;</span>+hashlib.sha256(long_to_bytes(p)).hexdigest()+<span class="string">&#x27;&#125;&#x27;</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;output.txt&quot;</span>, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    file.write(<span class="built_in">str</span>(sample))</span><br></pre></td></tr></table></figure>
<p>以及一个output.txt</p>
<p>题目描述的很明确了，agcd问题(近似公约数问题)，也与格相关，不进行展开。</p>
<p><br></p>
<p>exp.ipynb：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> permutations</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"></span><br><span class="line">P_bits = <span class="number">500</span></span><br><span class="line">Q_bits = <span class="number">550</span></span><br><span class="line">R_bits = <span class="number">200</span></span><br><span class="line">e = <span class="number">0x1337</span></span><br><span class="line">N = <span class="comment">#自行代入</span></span><br><span class="line">X = <span class="number">2</span>**R_bits</span><br><span class="line">m = <span class="built_in">len</span>(N)</span><br><span class="line"></span><br><span class="line">PR = PolynomialRing(ZZ, names=[<span class="built_in">str</span>(<span class="string">&#x27;x%d&#x27;</span> % i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">1</span> + m)])</span><br><span class="line"></span><br><span class="line">h = <span class="number">3</span></span><br><span class="line">u = <span class="number">1</span></span><br><span class="line">variables = PR.gens()</span><br><span class="line"></span><br><span class="line">gg = []</span><br><span class="line">monomials = [variables[<span class="number">0</span>]**<span class="number">0</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">    gg.append(N[i] - variables[i])</span><br><span class="line">    monomials.append(variables[i])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(monomials), <span class="built_in">len</span>(gg))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;monomials:&#x27;</span>, monomials)</span><br><span class="line"></span><br><span class="line">B = Matrix(ZZ, <span class="built_in">len</span>(gg), <span class="built_in">len</span>(monomials))</span><br><span class="line"><span class="keyword">for</span> ii <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(gg)):</span><br><span class="line">    <span class="keyword">for</span> jj <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(monomials)):</span><br><span class="line">        <span class="keyword">if</span> monomials[jj] <span class="keyword">in</span> gg[ii].monomials():</span><br><span class="line">            B[ii, jj] = gg[ii].monomial_coefficient(monomials[jj]) * monomials[jj]([X] * m)</span><br><span class="line"></span><br><span class="line">B = B.LLL()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;-&#x27;</span> * <span class="number">32</span>)</span><br><span class="line"></span><br><span class="line">new_pol = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(gg)):</span><br><span class="line">    tmp_pol = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(monomials)):</span><br><span class="line">        tmp_pol += monomials[j](variables) * B[i, j] / monomials[j]([X] * m)</span><br><span class="line">    new_pol.append(tmp_pol)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(new_pol) &gt; <span class="number">0</span>:</span><br><span class="line">    Ideal = ideal(new_pol[:m-<span class="number">1</span>])</span><br><span class="line">    GB = Ideal.groebner_basis()</span><br><span class="line">    function_variables = var([<span class="built_in">str</span>(<span class="string">&#x27;y%d&#x27;</span> % i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">1</span> + m)])</span><br><span class="line">    res = solve([pol(function_variables) <span class="keyword">for</span> pol <span class="keyword">in</span> GB], function_variables)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;got %d basis&#x27;</span> % <span class="built_in">len</span>(GB))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;solved result:&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(res)</span><br><span class="line">    PRRR.&lt; x, y&gt; = PolynomialRing(QQ)</span><br><span class="line">    q = <span class="built_in">abs</span>(PRRR(res[<span class="number">0</span>][<span class="number">0</span>](x, y)).coefficients()[<span class="number">0</span>].denominator())</span><br><span class="line">    p = N[-<span class="number">1</span>] // q</span><br><span class="line"></span><br><span class="line">    flag = <span class="string">&#x27;cnss&#123;&#x27;</span>+hashlib.sha256(long_to_bytes(p)).hexdigest()+<span class="string">&#x27;&#125;&#x27;</span></span><br><span class="line">    <span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure>
<p>也需要跑几分钟才出结果，能更精确地调整参数的话可能可以减少耗时。</p>
<p>flag:</p>
<font size="4" color="red">cnss{dde0cc3ac3539c66a74ed445a81c3f5b12938c286fa569a3b143b72369c708c9}</font>

<p><br></p>
<p><br></p>
<p><br></p>
<h2 id="铜匠的世界"><a href="#铜匠的世界" class="headerlink" title="铜匠的世界"></a>铜匠的世界</h2><p>题目描述：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">怎样在2^512个可能中找到唯一的答案呢？</span><br></pre></td></tr></table></figure>
<p>题目：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> isqrt</span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">m = bytes_to_long(flag)</span><br><span class="line">p, q = getPrime(<span class="number">512</span>), getPrime(<span class="number">512</span>)</span><br><span class="line">n = p * q</span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">c = <span class="built_in">pow</span>(m, e, n)</span><br><span class="line">hint = isqrt(p) ^ isqrt(q)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;n = &#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;c = &#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;hint = &#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">n = 85404423344841677974087657659736161235661371072424467828040714876602706438511794670195915251038316685200550396898521246532238184171610202260808362573973358649489859739377219665083353960986881177279315590581777896976153899765953910931555330824054172366095461986394627542626117519624886018101305667394230690241</span></span><br><span class="line"><span class="string">c = 19771222413844352631385715488753476758377273736688852768996964594019231638669697870409256892886494956719082541038530128231778575768552216334354854019126139003782852207071549956953446472517410158388833668611141062328959917017080292879996106665465487753670322759387144032463518586362415629216383494479440197516</span></span><br><span class="line"><span class="string">hint = 34903932064178830653499046348212332783401351910283782992020948402621276719605</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<p>如果给的是p^q，题目是容易的，只需要按照RSA Ⅱ类似的思路进行深搜即可。而给的是isqrt(p) ^ isqrt(q)，很容易会有思路如下：</p>
<ul>
<li>对n开根，得到isqrt(p*q) </li>
<li>将isqrt(p*q) 看作n，将isqrt(p) ^ isqrt(q)看作p^q，转化成上面给定p^q的问题求解</li>
</ul>
<p>看上去没什么问题，可是实际操作就会发现存在两点问题：</p>
<ul>
<li>由于一些低位误差，有一些可能正确的根号p、q高位被舍弃。</li>
<li>即使得到了正确的isqrt(p)与isqrt(q)，各自平方后与真正的p、q还有至少256比特的差距，即使是用coppersmith也完全满足不了使用条件。</li>
</ul>
<p>因此不能再使用RSA Ⅱ中的返回条件进行按位查找了。此时搜索题目，发现了佬的类似的题目思路：</p>
<p><a href="https://blog.maple3142.net/2023/06/12/seetf-2023-writeups/#shard">https://blog.maple3142.net/2023/06/12/seetf-2023-writeups/#shard</a></p>
<p>这样子查找成功后，还需要对低位进行一定程度的爆破后才能使用coppersmith，并且参数要卡的比较死，比如epsilon取0.03虽然快一些，但是跑不出结果，因此只能取0.01甚至更小，但这个就会耗费很长时间。遗憾的是我也没有想出更好的办法。</p>
<p><br></p>
<p>exp_step1.ipynb：(求出可能的p高位)：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> getPrime</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.Padding <span class="keyword">import</span> pad</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">from</span> secrets <span class="keyword">import</span> randbelow</span><br><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> sha256</span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> iroot</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> re <span class="keyword">import</span> findall</span><br><span class="line"><span class="keyword">from</span> subprocess <span class="keyword">import</span> check_output</span><br><span class="line"><span class="keyword">from</span> binteger <span class="keyword">import</span> Bin</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">small_roots</span>(<span class="params">self, X=<span class="literal">None</span>, beta=<span class="number">1.0</span>, epsilon=<span class="literal">None</span>, **kwds</span>):</span><br><span class="line">    <span class="keyword">from</span> sage.misc.verbose <span class="keyword">import</span> verbose</span><br><span class="line">    <span class="keyword">from</span> sage.matrix.constructor <span class="keyword">import</span> Matrix</span><br><span class="line">    <span class="keyword">from</span> sage.rings.real_mpfr <span class="keyword">import</span> RR</span><br><span class="line"></span><br><span class="line">    N = self.parent().characteristic()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> self.is_monic():</span><br><span class="line">        <span class="keyword">raise</span> ArithmeticError(<span class="string">&quot;Polynomial must be monic.&quot;</span>)</span><br><span class="line"></span><br><span class="line">    beta = RR(beta)</span><br><span class="line">    <span class="keyword">if</span> beta &lt;= <span class="number">0.0</span> <span class="keyword">or</span> beta &gt; <span class="number">1.0</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&quot;0.0 &lt; beta &lt;= 1.0 not satisfied.&quot;</span>)</span><br><span class="line"></span><br><span class="line">    f = self.change_ring(ZZ)</span><br><span class="line"></span><br><span class="line">    P, (x,) = f.parent().objgens()</span><br><span class="line"></span><br><span class="line">    delta = f.degree()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> epsilon <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        epsilon = beta / <span class="number">8</span></span><br><span class="line">    verbose(<span class="string">&quot;epsilon = %f&quot;</span> % epsilon, level=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    m = <span class="built_in">max</span>(beta**<span class="number">2</span> / (delta * epsilon), <span class="number">7</span> * beta / delta).ceil()</span><br><span class="line">    verbose(<span class="string">&quot;m = %d&quot;</span> % m, level=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    t = <span class="built_in">int</span>((delta * m * (<span class="number">1</span> / beta - <span class="number">1</span>)).floor())</span><br><span class="line">    verbose(<span class="string">&quot;t = %d&quot;</span> % t, level=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> X <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        X = (<span class="number">0.5</span> * N ** (beta**<span class="number">2</span> / delta - epsilon)).ceil()</span><br><span class="line">    verbose(<span class="string">&quot;X = %s&quot;</span> % X, level=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># we could do this much faster, but this is a cheap step</span></span><br><span class="line">    <span class="comment"># compared to LLL</span></span><br><span class="line">    g = [x**j * N ** (m - i) * f**i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m) <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(delta)]</span><br><span class="line">    g.extend([x**i * f**m <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(t)])  <span class="comment"># h</span></span><br><span class="line"></span><br><span class="line">    B = Matrix(ZZ, <span class="built_in">len</span>(g), delta * m + <span class="built_in">max</span>(delta, t))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(B.nrows()):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(g[i].degree() + <span class="number">1</span>):</span><br><span class="line">            B[i, j] = g[i][j] * X**j</span><br><span class="line"></span><br><span class="line">    f = <span class="built_in">sum</span>([ZZ(B[<span class="number">0</span>, i] // X**i) * x**i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(B.ncols())])</span><br><span class="line">    R = f.roots()</span><br><span class="line"></span><br><span class="line">    ZmodN = self.base_ring()</span><br><span class="line">    roots = <span class="built_in">set</span>([ZmodN(r) <span class="keyword">for</span> r, m <span class="keyword">in</span> R <span class="keyword">if</span> <span class="built_in">abs</span>(r) &lt;= X])</span><br><span class="line">    Nbeta = N**beta</span><br><span class="line">    <span class="keyword">return</span> [root <span class="keyword">for</span> root <span class="keyword">in</span> roots <span class="keyword">if</span> N.gcd(ZZ(self(root))) &gt;= Nbeta]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pq = <span class="number">85404423344841677974087657659736161235661371072424467828040714876602706438511794670195915251038316685200550396898521246532238184171610202260808362573973358649489859739377219665083353960986881177279315590581777896976153899765953910931555330824054172366095461986394627542626117519624886018101305667394230690241</span></span><br><span class="line">c = <span class="number">19771222413844352631385715488753476758377273736688852768996964594019231638669697870409256892886494956719082541038530128231778575768552216334354854019126139003782852207071549956953446472517410158388833668611141062328959917017080292879996106665465487753670322759387144032463518586362415629216383494479440197516</span></span><br><span class="line">hint = <span class="number">34903932064178830653499046348212332783401351910283782992020948402621276719605</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">spv, i</span>):</span><br><span class="line">    <span class="keyword">if</span> i &gt;= <span class="number">256</span>:</span><br><span class="line">        <span class="keyword">yield</span> Bin(spv, <span class="number">256</span>), Bin(Bin(spv).<span class="built_in">int</span> ^^ hint, <span class="number">256</span>)</span><br><span class="line">    <span class="keyword">if</span> i &gt;= <span class="number">256</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">for</span> b <span class="keyword">in</span> (<span class="number">1</span>, <span class="number">0</span>):</span><br><span class="line">        spv[i] = b</span><br><span class="line">        tsp = Bin(spv).<span class="built_in">int</span></span><br><span class="line">        tsq = tsp ^^ hint</span><br><span class="line">        p = tsp**<span class="number">2</span></span><br><span class="line">        q = tsq**<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> <span class="number">0</span> &lt;= (pq - p * q) &lt;= <span class="number">2</span> ** (<span class="number">1024</span> - i + <span class="number">1</span>) <span class="keyword">and</span> <span class="number">0</span> &lt;= (</span><br><span class="line">            iroot(pq,<span class="number">2</span>)[<span class="number">0</span>] - tsp * tsq</span><br><span class="line">        ) &lt;= <span class="number">2</span> ** (<span class="number">512</span> - i + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">from</span> dfs(spv[:], i + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">spv = [<span class="number">0</span>] * <span class="number">256</span></span><br><span class="line">results = []</span><br><span class="line"><span class="keyword">for</span> spc, sqc <span class="keyword">in</span> dfs(spv, <span class="number">0</span>):</span><br><span class="line">    d = pq - spc.<span class="built_in">int</span>**<span class="number">2</span> * sqc.<span class="built_in">int</span>**<span class="number">2</span></span><br><span class="line">    results.append((d, spc.<span class="built_in">int</span>, sqc.<span class="built_in">int</span>))</span><br><span class="line"><span class="keyword">for</span> i, (_, spci, sqci) <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">sorted</span>(results)):</span><br><span class="line">    <span class="number">1</span></span><br><span class="line">    <span class="comment">#print((spci - (iroot(pq,2)[0] // sqci)).bit_length())</span></span><br><span class="line"><span class="built_in">print</span>(results)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">copp_factor</span>(<span class="params">sp, leak=<span class="number">5</span></span>):</span><br><span class="line">    <span class="keyword">for</span> tb <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span> &lt;&lt; leak):</span><br><span class="line">        <span class="comment">#print(&quot;copp&quot;, tb, int(time.time()))</span></span><br><span class="line">        shift = <span class="number">256</span> - leak + <span class="number">1</span></span><br><span class="line">        P = Zmod(pq)[<span class="string">&quot;x&quot;</span>]</span><br><span class="line">        x = P.gen()</span><br><span class="line">        f = sp.<span class="built_in">int</span>**<span class="number">2</span> + (x &lt;&lt; shift) + <span class="number">2</span>*tb + <span class="number">1</span></span><br><span class="line">        f = f.monic()</span><br><span class="line">        X = <span class="number">2</span> ** (<span class="number">256</span> - leak - <span class="number">1</span>)</span><br><span class="line">        beta = <span class="number">0.499</span></span><br><span class="line">        eps = <span class="number">0.01</span></span><br><span class="line">        rs = f.small_roots(X=X, beta=beta, epsilon=eps)</span><br><span class="line">        <span class="comment">#rs = small_roots(f, X=X, beta=beta, epsilon=eps)</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(rs):</span><br><span class="line">            <span class="built_in">print</span>(sp.<span class="built_in">int</span>**<span class="number">2</span> + (tb &lt;&lt; shift) + <span class="built_in">int</span>(rs[<span class="number">0</span>]))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, (_, spci, _) <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">sorted</span>(results)):</span><br><span class="line">    copp_factor(Bin(spci, <span class="number">256</span>))</span><br></pre></td></tr></table></figure>
<p>将运行结果填充至下面脚本中的sqrtplist中</p>
<p><br></p>
<p>exp_step2.ipynb：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> iroot</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"><span class="comment">#coppersmith</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">small_roots</span>(<span class="params">f, bounds, m=<span class="number">1</span>, d=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> d:</span><br><span class="line">        d = f.degree()</span><br><span class="line">    R = f.base_ring()</span><br><span class="line">    N = R.cardinality()</span><br><span class="line">    f /= f.coefficients().pop(<span class="number">0</span>)</span><br><span class="line">    f = f.change_ring(ZZ)</span><br><span class="line">    G = <span class="type">Sequence</span>([], f.parent())</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m + <span class="number">1</span>):</span><br><span class="line">        base = N ^ (m - i) * f ^ i</span><br><span class="line">        <span class="keyword">for</span> shifts <span class="keyword">in</span> itertools.product(<span class="built_in">range</span>(d), repeat=f.nvariables()):</span><br><span class="line">            g = base * prod(<span class="built_in">map</span>(power, f.variables(), shifts))</span><br><span class="line">            G.append(g)</span><br><span class="line">    B, monomials = G.coefficient_matrix()</span><br><span class="line">    monomials = vector(monomials)</span><br><span class="line">    factors = [monomial(*bounds) <span class="keyword">for</span> monomial <span class="keyword">in</span> monomials]</span><br><span class="line">    <span class="keyword">for</span> i, factor <span class="keyword">in</span> <span class="built_in">enumerate</span>(factors):</span><br><span class="line">        B.rescale_col(i, factor)</span><br><span class="line">    B = B.dense_matrix().LLL()</span><br><span class="line">    B = B.change_ring(QQ)</span><br><span class="line">    <span class="keyword">for</span> i, factor <span class="keyword">in</span> <span class="built_in">enumerate</span>(factors):</span><br><span class="line">        B.rescale_col(i, <span class="number">1</span> / factor)</span><br><span class="line">    H = <span class="type">Sequence</span>([], f.parent().change_ring(QQ))</span><br><span class="line">    <span class="keyword">for</span> h <span class="keyword">in</span> <span class="built_in">filter</span>(<span class="literal">None</span>, B * monomials):</span><br><span class="line">        H.append(h)</span><br><span class="line">        I = H.ideal()</span><br><span class="line">        <span class="keyword">if</span> I.dimension() == -<span class="number">1</span>:</span><br><span class="line">            H.pop()</span><br><span class="line">        <span class="keyword">elif</span> I.dimension() == <span class="number">0</span>:</span><br><span class="line">            roots = []</span><br><span class="line">            <span class="keyword">for</span> root <span class="keyword">in</span> I.variety(ring=ZZ):</span><br><span class="line">                root = <span class="built_in">tuple</span>(R(root[var]) <span class="keyword">for</span> var <span class="keyword">in</span> f.variables())</span><br><span class="line">                roots.append(root)</span><br><span class="line">            <span class="keyword">return</span> roots</span><br><span class="line">    <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">N = <span class="number">85404423344841677974087657659736161235661371072424467828040714876602706438511794670195915251038316685200550396898521246532238184171610202260808362573973358649489859739377219665083353960986881177279315590581777896976153899765953910931555330824054172366095461986394627542626117519624886018101305667394230690241</span></span><br><span class="line">c = <span class="number">19771222413844352631385715488753476758377273736688852768996964594019231638669697870409256892886494956719082541038530128231778575768552216334354854019126139003782852207071549956953446472517410158388833668611141062328959917017080292879996106665465487753670322759387144032463518586362415629216383494479440197516</span></span><br><span class="line"></span><br><span class="line">sqrtplist = <span class="comment">#自行代入</span></span><br><span class="line"></span><br><span class="line">leak = <span class="number">6</span></span><br><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(sqrtplist)):</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line">    sp = sqrtplist[i][<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> tb <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span> &lt;&lt; leak):</span><br><span class="line">        <span class="comment">#print(&quot;copp&quot;, tb, int(time.time()))</span></span><br><span class="line">        shift = <span class="number">256</span> - leak</span><br><span class="line">        PR.&lt;x&gt; = PolynomialRing(Zmod(N))</span><br><span class="line">        f = sp**<span class="number">2</span> + (tb &lt;&lt; shift) + x</span><br><span class="line">        f = f.monic()</span><br><span class="line">        X = <span class="number">2</span> ** (<span class="number">256</span> - leak)</span><br><span class="line">        beta = <span class="number">0.499</span></span><br><span class="line">        eps = <span class="number">0.01</span></span><br><span class="line">        res = f.small_roots(X=X, beta=beta, epsilon=eps)</span><br><span class="line">        <span class="keyword">if</span>(res!=[]):</span><br><span class="line">            <span class="built_in">print</span>(res)</span><br><span class="line">            <span class="built_in">print</span>(sp**<span class="number">2</span> + (tb &lt;&lt; shift) + res[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">p = <span class="number">6756521617869105417915102754795944450583448652752246233837766079298009351893501307888859133738834804209006551446537605217981998432259279870915861077557549</span></span><br><span class="line">q = N//p</span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">phi = (p-<span class="number">1</span>)*(q-<span class="number">1</span>)</span><br><span class="line">d = inverse(e,phi)</span><br><span class="line">m = <span class="built_in">pow</span>(c,d,N)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m))</span><br></pre></td></tr></table></figure>
<p>跑出结果可能需要6个小时到10个小时不等。如果你有更好的方式欢迎在评论区留言！</p>
<p>flag:</p>
<font size="4" color="red">cnss{We hav3 n0 0ther ch0ice but c0ppersm1th.}</font>

<p><br></p>
<p><br></p>
<p><br></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>题目质量确实很不错，每道题目考察的知识点很有针对性，准备好好借鉴参考(<del>开偷</del>)。</p>
]]></content>
      <categories>
        <category>wp-crypto</category>
      </categories>
  </entry>
  <entry>
    <title>NSSCTF-2nd-wp-crypto</title>
    <url>/post/39588.html</url>
    <content><![CDATA[<p>这次crypto题目总体难度不大，重点是对一些基础知识的理解运用。</p>
<span id="more"></span>
<h2 id="EzRSA"><a href="#EzRSA" class="headerlink" title="EzRSA"></a>EzRSA</h2><p>题目:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag</span><br><span class="line">m = bytes_to_long(flag)</span><br><span class="line"><span class="keyword">assert</span> m.bit_length()&lt;<span class="number">200</span></span><br><span class="line">p = getPrime(<span class="number">512</span>)</span><br><span class="line">q = getPrime(<span class="number">512</span>)</span><br><span class="line">n = p*q</span><br><span class="line">e = <span class="number">3</span></span><br><span class="line">c = <span class="built_in">pow</span>(m, e, n)</span><br><span class="line">kbits = <span class="number">103</span></span><br><span class="line">m = (m &gt;&gt; kbits) &lt;&lt; kbits</span><br><span class="line">Mod = getPrime(<span class="number">1024</span>)</span><br><span class="line">hint1 = (<span class="number">2021</span>-<span class="number">2023</span>*m) % Mod</span><br><span class="line">hint2 = <span class="built_in">pow</span>(<span class="number">2</span>, <span class="number">2023</span>, Mod)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;n =&#x27;</span>,n)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;c =&#x27;</span>,c)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;hint1 =&#x27;</span>,hint1)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;hint2 =&#x27;</span>,hint2)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">n = ...</span></span><br><span class="line"><span class="string">c = ...</span></span><br><span class="line"><span class="string">hint1 = ...</span></span><br><span class="line"><span class="string">hint2 = ...</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>有以下信息:</p>
<ul>
<li>m.bit_length()&lt;200 , 说明明文较小</li>
<li>kbits = 103 , m = (m &gt;&gt; kbits) &lt;&lt; kbits , 隐藏了明文低位</li>
<li>hint1 = (2021-2023*m) % Mod</li>
<li>hint2 = pow(2, 2023, Mod)</li>
</ul>
<p>种种都指向coppersmith , 首先看hint2，</p>
<script type="math/tex; mode=display">
hint2  \equiv  2^{2023}  mod(Mod)</script><p>利用同余关系,</p>
<script type="math/tex; mode=display">
2^{2023} - hint2 = k*Mod</script><p>得到Mod的k倍,因此可以利用k*Mod建立环，解出hint1中的小根m，解得m高位后已知高位攻击即可。</p>
<p><br></p>
<p>exp.ipynb:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">n = ...</span><br><span class="line">c = ...</span><br><span class="line">hint1 = ...</span><br><span class="line">hint2 = ...</span><br><span class="line">e = <span class="number">3</span></span><br><span class="line">kM = <span class="number">2</span>**<span class="number">2023</span>-hint2</span><br><span class="line"></span><br><span class="line">PR.&lt;x&gt; = PolynomialRing(Zmod(kM))</span><br><span class="line">f = <span class="number">2023</span>*x + hint1 - <span class="number">2021</span></span><br><span class="line">f = f.monic()</span><br><span class="line">roots = f.small_roots(X=<span class="number">2</span>^<span class="number">200</span>,beta=<span class="number">0.4</span>)</span><br><span class="line"><span class="keyword">if</span> roots:</span><br><span class="line">    mhigh = roots[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">mhigh = <span class="number">1746716778150027565782467891299010283212636160</span></span><br><span class="line">PR.&lt;y&gt; = PolynomialRing(Zmod(n))</span><br><span class="line">f = (mhigh + y)^<span class="number">3</span> - c</span><br><span class="line">f = f.monic()</span><br><span class="line">roots = f.small_roots(X=<span class="number">2</span>^<span class="number">104</span>,beta=<span class="number">0.4</span>)</span><br><span class="line"><span class="keyword">if</span> roots:</span><br><span class="line">    m = mhigh + roots[<span class="number">0</span>]</span><br><span class="line">    <span class="built_in">print</span>(m)</span><br><span class="line">m = <span class="number">1746716778150037336346788439252154990602710653</span></span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m))</span><br></pre></td></tr></table></figure>
<p>得到flag:</p>
<font size="4" color="red">NSSCTF{Rea1_Si9n3n}</font>

<p><br></p>
<p>(赛中的时候，这题解数比funnyencrypt还多，当时就感觉有点诡异。赛后才发现因为明密文都很小，所以直接开三次根就可以了。。)</p>
<p><br></p>
<p><br></p>
<p><br></p>
<h2 id="FunnyEncrypt"><a href="#FunnyEncrypt" class="headerlink" title="FunnyEncrypt"></a>FunnyEncrypt</h2><p>题目:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">✧✡✭</span><br><span class="line">✡✮ ✣✴✯ ✤✶✬✬✱ ✬✤ ✱✦✢✥✮✯✧✧, ✴✬✷✯ ✡✧ ✣✴✯ ✶✡✰✴✣. ✡✣ ❂✢✡✮✰✧ ✩✬✸✤✬✢✣, ✤✦✡✣✴, ✦✮✱ ✩✬✮✤✡✱✯✮✩✯. ✡✣ ✰✡✲✯✧ ✳✧ ✰✳✡✱✦✮✩✯ ★✴✯✮ ★✯ ✦✢✯ ✶✬✧✣, ✦✮✱ ✰✡✲✯✧ ✧✳✷✷✬✢✣ ★✴✯✮ ★✯ ✦✢✯ ✦✤✢✦✡✱. ✦✮✱ ✣✴✯ ✸✬✸✯✮✣ ★✯ ✰✡✲✯ ✳✷ ✴✬✷✯, ★✯ ✰✡✲✯ ✳✷ ✬✳✢ ✶✡✲✯✧. ✣✴✯ ★✬✢✶✱ ★✯ ✶✡✲✯ ✡✮ ✡✧ ✱✡✧✡✮✣✯✰✢✦✣✡✮✰ ✡✮✣✬ ✦ ✷✶✦✩✯ ✬✤ ✸✦✶✡✩✯ ✦✮✱ ✴✦✣✢✯✱, ★✴✯✢✯ ★✯ ✮✯✯✱ ✴✬✷✯ ✦✮✱ ✤✡✮✱ ✡✣ ✴✦✢✱✯✢. ✡✮ ✣✴✡✧ ★✬✢✶✱ ✬✤ ✤✯✦✢, ✴✬✷✯ ✣✬ ✤✡✮✱ ❂✯✣✣✯✢, ❂✳✣ ✯✦✧✡✯✢ ✧✦✡✱ ✣✴✦✮ ✱✬✮✯, ✣✴✯ ✸✬✢✯ ✸✯✦✮✡✮✰✤✳✶ ✶✡✤✯ ✬✤ ✤✦✡✣✴ ★✡✶✶ ✸✦✥✯ ✶✡✤✯ ✸✯✦✮✡✮✰✤✳✶.</span><br><span class="line">✧✬✸✯✣✡✸✯✧ ★✯ ✣✴✡✮✥ ✬✤ ✱✢✯✦✸✧ ✦✧ ✤✦✮✣✦✧✡✯✧ - ✡✣&#x27;✧ ✯✦✧✵ ✣✬ ✱✬ ★✴✯✮ ✵✬✳ ✴✦✲✯ ✸✬✮✯✵, ✢✯✮✣, ✦✮✱ ★✬✢✥. ❂✳✣ ✵✬✳ ✩✦✮&#x27;✣ ✷✢✯✷✦✢✯ ✵✬✳✢✧✯✶✤ ✦✮✱ ✫✳✸✷ ✬✤✤ ✣✴✯ ✩✶✡✤✤: ✵✬✳ ✧✴✬✳✶✱ ✰✢✬★ ✵✬✳✢ ★✡✮✰✧ ✤✡✢✧✣. ✦ ✶✡✣✣✶✯ ❂✡✣ ✣✬★✦✢✱ ✣✴✯ ✱✢✯✦✸. ✧✣✯✷ ❂✵ ✧✣✯✷. ✣✦✥✯ ✦ ✧✣✯✷ ✤✬✢★✦✢✱. ✦✤✣✯✢ ✦✶✶, ✡✣&#x27;✧ ✵✬✳✢ ✸✡✧✧✡✬✮.</span><br><span class="line">✥✯✯✷ ✤✦✡✣✴ ✦✮✱ ✴✬✷✯ ✤✬✢ ✣✴✯ ✤✳✣✳✢✯. ✸✦✥✯ ✵✬✳✢ ✸✬✧✣ ✧✡✮✩✯✢✯ ✱✢✯✦✸✧, ✦✮✱ ★✴✯✮ ✣✴✯ ✬✷✷✬✢✣✳✮✡✣✡✯✧ ✩✬✸✯, ✣✴✯✵ ★✡✶✶ ✤✡✰✴✣ ✤✬✢ ✣✴✯✸. ✡✣ ✸✦✵ ✣✦✥✯ ✦ ✧✯✦✧✬✮ ✬✢ ✸✬✢✯, ❂✳✣ ✣✴✯ ✯✮✱✡✮✰ ★✡✶✶ ✮✬✣ ✩✴✦✮✰✯. ✦✸❂✡✣✡✬✮, ❂✯✧✣, ❂✯✩✬✸✯ ✦ ✢✯✦✶✡✣✵. ✦✮ ✳✮✩✯✢✣✦✡✮ ✤✳✣✳✢✯, ✬✮✶✵ ✬✮✯ ✧✣✯✷ ✦✣ ✦ ✣✡✸✯, ✣✴✯ ✴✬✷✯ ✩✦✮ ✢✯✦✶✡✪✯ ✣✴✯ ✱✢✯✦✸ ✬✤ ✣✴✯ ✴✡✰✴✯✧✣. ★✯ ✸✳✧✣ ✣✢✯✦✧✳✢✯ ✣✴✯ ✱✢✯✦✸, ✣✬ ✷✢✬✣✯✩✣ ✡✣ ✦ ✧✯✦✧✬✮, ✶✯✣ ✡✣ ✡✮ ✣✴✯ ✴✯✦✢✣ ❋✳✡✯✣✶✵ ✰✯✢✸✡✮✦✶.</span><br><span class="line">✬✮✶✵ ★✴✯✮ ✵✬✳ ✳✮✱✯✢✧✣✦✮✱ ✣✴✯ ✣✢✳✯ ✸✯✦✮✡✮✰ ✬✤ ✶✡✤✯ ✩✦✮ ✵✬✳ ✶✡✲✯ ✣✢✳✶✵. ❂✡✣✣✯✢✧★✯✯✣ ✦✧ ✶✡✤✯ ✡✧, ✡✣&#x27;✧ ✧✣✡✶✶ ★✬✮✱✯✢✤✳✶, ✦✮✱ ✡✣&#x27;✧ ✤✦✧✩✡✮✦✣✡✮✰ ✯✲✯✮ ✡✮ ✣✢✦✰✯✱✵. ✡✤ ✵✬✳&#x27;✢✯ ✫✳✧✣ ✦✶✡✲✯, ✣✢✵ ✴✦✢✱✯✢ ✦✮✱ ✣✢✵ ✣✬ ✶✡✲✯ ★✬✮✱✯✢✤✳✶✶✵.</span><br><span class="line">✡ ❂✯✶✡✯✲✯ ✣✴✯✢✯ ✡✧ ✦ ✷✯✢✧✬✮ ★✴✬ ❂✢✡✮✰✧ ✧✳✮✧✴✡✮✯ ✡✮✣✬ ✵✬✳✢ ✶✡✤✯. ✣✴✦✣ ✷✯✢✧✬✮ ✸✦✵ ✴✦✲✯ ✯✮✬✳✰✴ ✣✬ ✧✷✢✯✦✱ ✦✢✬✳✮✱. ❂✳✣ ✡✤ ✵✬✳ ✢✯✦✶✶✵ ✴✦✲✯ ✣✬ ★✦✡✣ ✤✬✢ ✧✬✸✯✬✮✯ ✣✬ ❂✢✡✮✰ ✵✬✳ ✣✴✯ ✧✳✮ ✦✮✱ ✰✡✲✯ ✵✬✳ ✦ ✰✬✬✱ ✤✯✯✶✡✮✰, ✣✴✯✮ ✵✬✳ ✸✦✵ ✴✦✲✯ ✣✬ ★✦✡✣ ✦ ✶✬✮✰ ✣✡✸✯.</span><br><span class="line">✡✮ ✦ ★✬✢✱,✡ ✴✬✷✯ ✵✬✳ ★✡✶✶ ✶✡✥✯ ✩✢✵✷✣✬✰✢✦✷✴✵.✣✴✡✧ ✡✧ ✵✬✳✢ ✤✶✦✰:✮✧✧✩✣✤&#123;✩✢✵✷✣✬_✡✧_✧✬_✡✮✣✯✢✯✧✣✡✮✰_★✴✵_✱✬✮&#x27;✣_✵✬✳_✫✬✡✮_✳✧&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>见过的图形加密中并没有类似这个的，不过翻看一下马上就能发现文件尾部的这一串：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">✮✧✧✩✣✤&#123;✩✢✵✷✣✬_✡✧_✧✬_✡✮✣✯✢✯✧✣✡✮✰_★✴✵_✱✬✮&#x27;✣_✵✬✳_✫✬✡✮_✳✧&#125;</span><br></pre></td></tr></table></figure>
<p>前缀肯定是nssctf，是对的上的，猜测是简单的替换密码，写个脚本后交给quipqiup即可</p>
<p>exp.py:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">c = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">✧✡✭</span></span><br><span class="line"><span class="string">✡✮ ✣✴✯ ✤✶✬✬✱ ✬✤ ✱✦✢✥✮✯✧✧, ✴✬✷✯ ✡✧ ✣✴✯ ✶✡✰✴✣. ✡✣ ❂✢✡✮✰✧ ✩✬✸✤✬✢✣, ✤✦✡✣✴, ✦✮✱ ✩✬✮✤✡✱✯✮✩✯. ✡✣ ✰✡✲✯✧ ✳✧ ✰✳✡✱✦✮✩✯ ★✴✯✮ ★✯ ✦✢✯ ✶✬✧✣, ✦✮✱ ✰✡✲✯✧ ✧✳✷✷✬✢✣ ★✴✯✮ ★✯ ✦✢✯ ✦✤✢✦✡✱. ✦✮✱ ✣✴✯ ✸✬✸✯✮✣ ★✯ ✰✡✲✯ ✳✷ ✴✬✷✯, ★✯ ✰✡✲✯ ✳✷ ✬✳✢ ✶✡✲✯✧. ✣✴✯ ★✬✢✶✱ ★✯ ✶✡✲✯ ✡✮ ✡✧ ✱✡✧✡✮✣✯✰✢✦✣✡✮✰ ✡✮✣✬ ✦ ✷✶✦✩✯ ✬✤ ✸✦✶✡✩✯ ✦✮✱ ✴✦✣✢✯✱, ★✴✯✢✯ ★✯ ✮✯✯✱ ✴✬✷✯ ✦✮✱ ✤✡✮✱ ✡✣ ✴✦✢✱✯✢. ✡✮ ✣✴✡✧ ★✬✢✶✱ ✬✤ ✤✯✦✢, ✴✬✷✯ ✣✬ ✤✡✮✱ ❂✯✣✣✯✢, ❂✳✣ ✯✦✧✡✯✢ ✧✦✡✱ ✣✴✦✮ ✱✬✮✯, ✣✴✯ ✸✬✢✯ ✸✯✦✮✡✮✰✤✳✶ ✶✡✤✯ ✬✤ ✤✦✡✣✴ ★✡✶✶ ✸✦✥✯ ✶✡✤✯ ✸✯✦✮✡✮✰✤✳✶.</span></span><br><span class="line"><span class="string">✧✬✸✯✣✡✸✯✧ ★✯ ✣✴✡✮✥ ✬✤ ✱✢✯✦✸✧ ✦✧ ✤✦✮✣✦✧✡✯✧ - ✡✣&#x27;✧ ✯✦✧✵ ✣✬ ✱✬ ★✴✯✮ ✵✬✳ ✴✦✲✯ ✸✬✮✯✵, ✢✯✮✣, ✦✮✱ ★✬✢✥. ❂✳✣ ✵✬✳ ✩✦✮&#x27;✣ ✷✢✯✷✦✢✯ ✵✬✳✢✧✯✶✤ ✦✮✱ ✫✳✸✷ ✬✤✤ ✣✴✯ ✩✶✡✤✤: ✵✬✳ ✧✴✬✳✶✱ ✰✢✬★ ✵✬✳✢ ★✡✮✰✧ ✤✡✢✧✣. ✦ ✶✡✣✣✶✯ ❂✡✣ ✣✬★✦✢✱ ✣✴✯ ✱✢✯✦✸. ✧✣✯✷ ❂✵ ✧✣✯✷. ✣✦✥✯ ✦ ✧✣✯✷ ✤✬✢★✦✢✱. ✦✤✣✯✢ ✦✶✶, ✡✣&#x27;✧ ✵✬✳✢ ✸✡✧✧✡✬✮.</span></span><br><span class="line"><span class="string">✥✯✯✷ ✤✦✡✣✴ ✦✮✱ ✴✬✷✯ ✤✬✢ ✣✴✯ ✤✳✣✳✢✯. ✸✦✥✯ ✵✬✳✢ ✸✬✧✣ ✧✡✮✩✯✢✯ ✱✢✯✦✸✧, ✦✮✱ ★✴✯✮ ✣✴✯ ✬✷✷✬✢✣✳✮✡✣✡✯✧ ✩✬✸✯, ✣✴✯✵ ★✡✶✶ ✤✡✰✴✣ ✤✬✢ ✣✴✯✸. ✡✣ ✸✦✵ ✣✦✥✯ ✦ ✧✯✦✧✬✮ ✬✢ ✸✬✢✯, ❂✳✣ ✣✴✯ ✯✮✱✡✮✰ ★✡✶✶ ✮✬✣ ✩✴✦✮✰✯. ✦✸❂✡✣✡✬✮, ❂✯✧✣, ❂✯✩✬✸✯ ✦ ✢✯✦✶✡✣✵. ✦✮ ✳✮✩✯✢✣✦✡✮ ✤✳✣✳✢✯, ✬✮✶✵ ✬✮✯ ✧✣✯✷ ✦✣ ✦ ✣✡✸✯, ✣✴✯ ✴✬✷✯ ✩✦✮ ✢✯✦✶✡✪✯ ✣✴✯ ✱✢✯✦✸ ✬✤ ✣✴✯ ✴✡✰✴✯✧✣. ★✯ ✸✳✧✣ ✣✢✯✦✧✳✢✯ ✣✴✯ ✱✢✯✦✸, ✣✬ ✷✢✬✣✯✩✣ ✡✣ ✦ ✧✯✦✧✬✮, ✶✯✣ ✡✣ ✡✮ ✣✴✯ ✴✯✦✢✣ ❋✳✡✯✣✶✵ ✰✯✢✸✡✮✦✶.</span></span><br><span class="line"><span class="string">✬✮✶✵ ★✴✯✮ ✵✬✳ ✳✮✱✯✢✧✣✦✮✱ ✣✴✯ ✣✢✳✯ ✸✯✦✮✡✮✰ ✬✤ ✶✡✤✯ ✩✦✮ ✵✬✳ ✶✡✲✯ ✣✢✳✶✵. ❂✡✣✣✯✢✧★✯✯✣ ✦✧ ✶✡✤✯ ✡✧, ✡✣&#x27;✧ ✧✣✡✶✶ ★✬✮✱✯✢✤✳✶, ✦✮✱ ✡✣&#x27;✧ ✤✦✧✩✡✮✦✣✡✮✰ ✯✲✯✮ ✡✮ ✣✢✦✰✯✱✵. ✡✤ ✵✬✳&#x27;✢✯ ✫✳✧✣ ✦✶✡✲✯, ✣✢✵ ✴✦✢✱✯✢ ✦✮✱ ✣✢✵ ✣✬ ✶✡✲✯ ★✬✮✱✯✢✤✳✶✶✵.</span></span><br><span class="line"><span class="string">✡ ❂✯✶✡✯✲✯ ✣✴✯✢✯ ✡✧ ✦ ✷✯✢✧✬✮ ★✴✬ ❂✢✡✮✰✧ ✧✳✮✧✴✡✮✯ ✡✮✣✬ ✵✬✳✢ ✶✡✤✯. ✣✴✦✣ ✷✯✢✧✬✮ ✸✦✵ ✴✦✲✯ ✯✮✬✳✰✴ ✣✬ ✧✷✢✯✦✱ ✦✢✬✳✮✱. ❂✳✣ ✡✤ ✵✬✳ ✢✯✦✶✶✵ ✴✦✲✯ ✣✬ ★✦✡✣ ✤✬✢ ✧✬✸✯✬✮✯ ✣✬ ❂✢✡✮✰ ✵✬✳ ✣✴✯ ✧✳✮ ✦✮✱ ✰✡✲✯ ✵✬✳ ✦ ✰✬✬✱ ✤✯✯✶✡✮✰, ✣✴✯✮ ✵✬✳ ✸✦✵ ✴✦✲✯ ✣✬ ★✦✡✣ ✦ ✶✬✮✰ ✣✡✸✯.</span></span><br><span class="line"><span class="string">✡✮ ✦ ★✬✢✱,✡ ✴✬✷✯ ✵✬✳ ★✡✶✶ ✶✡✥✯ ✩✢✵✷✣✬✰✢✦✷✴✵.✣✴✡✧ ✡✧ ✵✬✳✢ ✤✶✦✰:✮✧✧✩✣✤&#123;✩✢✵✷✣✬_✡✧_✧✬_✡✮✣✯✢✯✧✣✡✮✰_★✴✵_✱✬✮&#x27;✣_✵✬✳_✫✬✡✮_✳✧&#125;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">table = <span class="string">&quot;abcdefghijklmnopqrstuvwxyz&#123;&#125; _-,.&#x27;:&quot;</span></span><br><span class="line">list1 = [<span class="string">&#x27;✧&#x27;</span>, <span class="string">&#x27;✡&#x27;</span>, <span class="string">&#x27;✭&#x27;</span>, <span class="string">&#x27;✮&#x27;</span>, <span class="string">&#x27;✣&#x27;</span>, <span class="string">&#x27;✴&#x27;</span>, <span class="string">&#x27;✯&#x27;</span>, <span class="string">&#x27;✤&#x27;</span>, <span class="string">&#x27;✶&#x27;</span>, <span class="string">&#x27;✬&#x27;</span>, <span class="string">&#x27;✱&#x27;</span>, <span class="string">&#x27;✦&#x27;</span>, <span class="string">&#x27;✢&#x27;</span>, <span class="string">&#x27;✥&#x27;</span>, <span class="string">&#x27;✷&#x27;</span>, <span class="string">&#x27;✰&#x27;</span>, <span class="string">&#x27;❂&#x27;</span>, <span class="string">&#x27;✩&#x27;</span>, <span class="string">&#x27;✸&#x27;</span>, <span class="string">&#x27;✲&#x27;</span>, <span class="string">&#x27;✳&#x27;</span>, <span class="string">&#x27;★&#x27;</span>, <span class="string">&#x27;✵&#x27;</span>, <span class="string">&#x27;✫&#x27;</span>, <span class="string">&#x27;✪&#x27;</span>, <span class="string">&#x27;❋&#x27;</span>] </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(list1))</span><br><span class="line"></span><br><span class="line">cfinal = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(c)):</span><br><span class="line">    <span class="keyword">if</span>(c[i] <span class="keyword">not</span> <span class="keyword">in</span> table):</span><br><span class="line">        <span class="keyword">if</span>(c[i] == <span class="string">&quot;\n&quot;</span>):</span><br><span class="line">            cfinal.append(c[i])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ind = list1.index(c[i])</span><br><span class="line">            cfinal.append(table[ind])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        cfinal.append(c[i])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&quot;</span>.join(cfinal))</span><br><span class="line"></span><br><span class="line"><span class="comment">#quipqiup</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">six</span></span><br><span class="line"><span class="string">in the flood of darkness, hope is the light. it brings comfort, faith, and confidence. it gives us guidance when we are lost, and gives support when we are afraid. and the moment we give up hope, we give up our lives. the world we live in is disintegrating into a place of malice and hatred, where we need hope and find it harder. in this world of fear, hope to find better, but easier said than done, the more meaningful life of faith will make life meaningful.</span></span><br><span class="line"><span class="string">sometimes we think of dreams as fantasies - it&#x27;s easy to do when you have money, rent, and work. but you can&#x27;t prepare yourself </span></span><br><span class="line"><span class="string">and jump off the cliff: you should grow your wings first. a little bit toward the dream. step by step. take a step forward. after all, it&#x27;s your mission.</span></span><br><span class="line"><span class="string">keep faith and hope for the future. make your most sincere dreams, and when the opportunities come, they will fight for them. it may take a season or more, but the ending will not change. ambition, best, become a reality. an uncertain future, only one step at a time, the hope can realize the dream of the highest. we must treasure the dream, to protect it a season, let it in the heart quietly germinal.</span></span><br><span class="line"><span class="string">only when you understand the true meaning of life can you live truly. bittersweet as life is, it&#x27;s still wonderful, and it&#x27;s fascinating even in tragedy. if you&#x27;re just alive, try harder and try to live wonderfully.</span></span><br><span class="line"><span class="string">i believe there is a person who brings sunshine into your life. that person may have enough to spread around. but if you really </span></span><br><span class="line"><span class="string">have to wait for someone to bring you the sun and give you a good feeling, then you may have to wait a long time.</span></span><br><span class="line"><span class="string">in a word,i hope you will like cryptography.this is your flag:nssctf&#123;crypto_is_so_interesting_why_don&#x27;t_you_join_us&#125;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<p>得到flag:</p>
<font size="4" color="red">NSSCTF{crypto_is_so_interesting_why_don't_you_join_us}</font>

<p>(前缀居然要大写，这就有点坑了。。)</p>
<p><br></p>
<p><br></p>
<p><br></p>
<h2 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h2><p>题目：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line">length = <span class="built_in">len</span>(flag)</span><br><span class="line">flag1 = flag[:length//<span class="number">2</span>]</span><br><span class="line">flag2 = flag[length//<span class="number">2</span>:]</span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line"></span><br><span class="line">m1 = bytes_to_long(flag1)</span><br><span class="line">p = getPrime(<span class="number">512</span>)</span><br><span class="line">q = getPrime(<span class="number">512</span>)</span><br><span class="line">n = p*q</span><br><span class="line">phi = (p-<span class="number">1</span>)*(q-<span class="number">1</span>)</span><br><span class="line">d = gmpy2.invert(e,phi)</span><br><span class="line"></span><br><span class="line">p1 = gmpy2.invert(p,q)</span><br><span class="line">q1 = gmpy2.invert(q,p)</span><br><span class="line">c = <span class="built_in">pow</span>(m1,e,n)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;p1=&quot;</span>,p1)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;q1=&quot;</span>,q1)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;c=&quot;</span>,c)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;phi=&quot;</span>,phi)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">p1= ...</span></span><br><span class="line"><span class="string">q1= ...</span></span><br><span class="line"><span class="string">c= ...</span></span><br><span class="line"><span class="string">phi= ...</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">m2 = bytes_to_long(flag2)</span><br><span class="line">p = getPrime(<span class="number">1024</span>)</span><br><span class="line">q = getPrime(<span class="number">1024</span>)</span><br><span class="line">n = p * q</span><br><span class="line">c = <span class="built_in">pow</span>(m2, e, n)</span><br><span class="line">hint = <span class="built_in">pow</span>(<span class="number">2023</span> * p + <span class="number">114514</span>, q, n)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;n=&quot;</span>,n)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;c=&quot;</span>,c)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hint=&quot;</span>,hint)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">n= ...</span></span><br><span class="line"><span class="string">c= ...</span></span><br><span class="line"><span class="string">hint= ...</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<p>题目将flag分为两部分分别进行加密，分开来说：</p>
<ul>
<li>第一部分</li>
</ul>
<p>给了p关于q的逆元及q关于p的逆元，hitconctf 2019 quals出过这个题目，具体推导过程参考<a href="[AiDai|HITCON CTF 2019 Quals-Writeup (aidaip.github.io">这一篇</a>](<a href="https://aidaip.github.io/ctf/2019/10/16/HITCON-CTF-2019-Quals-Writeup.html">https://aidaip.github.io/ctf/2019/10/16/HITCON-CTF-2019-Quals-Writeup.html</a>))</p>
<ul>
<li>第二部分</li>
</ul>
<p>已知：</p>
<script type="math/tex; mode=display">
hint \equiv (2023*p + 114514)^q  (mod n)</script><p>这种题目显然是构造出p或q的倍数，从而与n求gcd得到分解的。对于这个等式，很容易就能想到利用同余性质先化为一下两个等式：</p>
<script type="math/tex; mode=display">
hint \equiv (2023*p + 114514)^q  (mod p)</script><script type="math/tex; mode=display">
hint \equiv (2023*p + 114514)^q  (mod q)</script><p>乍一看应该是第二个等式更加好用，因为可以利用费马小定理消去指数，变形为:</p>
<script type="math/tex; mode=display">
hint \equiv 2023*p + 114514  (mod q)</script><p>但是这里就卡壳了，因为即使利用同余性质把模等式转化为等式，得到的依然含有p，q两个因子，没有办法与n求gcd。</p>
<p>所以考虑利用另一个等式，由于指数q没有办法消掉了，所以只能利用二项式定理展开。又由于mod p的关系，模等式正好只剩下了最后一项，即：</p>
<script type="math/tex; mode=display">
hint \equiv 114514^q  (mod p)</script><p>怎么利用这个等式呢？这个时候需要敏锐一点察觉到费马小定理(也许刚刚拆分出来的另一个式子的变形就是给我们的提示)，由费马小定理我们知道：</p>
<script type="math/tex; mode=display">
a \equiv a^p  (mod p)</script><p>把 $114514^q$ 看作a，就得到：</p>
<script type="math/tex; mode=display">
(114514^q) \equiv (114514^q)^p \equiv 114514^n (mod p)</script><p>所以有：</p>
<script type="math/tex; mode=display">
hint \equiv 114514^n  (mod p)</script><script type="math/tex; mode=display">
hint = 114514^n + k*p</script><p>也就是说，将$(hint - 114514^n)$与n求gcd，即可得到p，进而求解RSA</p>
<p><br></p>
<p>exp.py:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#1</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gcd</span>(<span class="params">a, b</span>):</span><br><span class="line">  <span class="keyword">while</span>(b): </span><br><span class="line">    a,b = b, a % b </span><br><span class="line">  <span class="keyword">return</span> a </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mysqrt</span>(<span class="params">d</span>):</span><br><span class="line">  st = <span class="number">1</span></span><br><span class="line">  en = <span class="number">10</span>**<span class="number">1300</span></span><br><span class="line">  <span class="keyword">while</span> st&lt;=en:</span><br><span class="line">    mid = (st+en)//<span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> mid*mid == d: <span class="keyword">return</span> mid</span><br><span class="line">    <span class="keyword">if</span> mid*mid &lt; d: st=mid+<span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>: en=mid-<span class="number">1</span></span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">egcd</span>(<span class="params">a1, a2</span>):</span><br><span class="line">    x1, x2 = <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">    y1, y2 = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> a2:</span><br><span class="line">        q = a1 // a2</span><br><span class="line">        a1, a2 = a2, a1 - q * a2</span><br><span class="line">        x1, x2 = x2, x1 - q * x2</span><br><span class="line">        y1, y2 = y2, y1 - q * y2</span><br><span class="line">    <span class="keyword">return</span> (x1, y1, a1)</span><br><span class="line"></span><br><span class="line">flag = <span class="string">&quot;&quot;</span></span><br><span class="line">ipmq= ...</span><br><span class="line">iqmp= ...</span><br><span class="line">phi= ...</span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">enc = ...</span><br><span class="line">d = inverse(e,phi)</span><br><span class="line">gg = gcd(iqmp-<span class="number">1</span>,ipmq-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">c = phi // gg</span><br><span class="line">a = (ipmq-<span class="number">1</span>)//gg</span><br><span class="line">b = (iqmp-<span class="number">1</span>)//gg</span><br><span class="line"><span class="comment"># p*a + q*b = c</span></span><br><span class="line">pmod = inverse(a, b)*c%b</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100000</span>):</span><br><span class="line">    p = pmod + j*b</span><br><span class="line">    <span class="keyword">if</span> p &gt; (<span class="number">1</span>&lt;&lt;<span class="number">1024</span>): <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> isPrime(p): <span class="keyword">continue</span></span><br><span class="line">    q = (c-p*a)//b</span><br><span class="line">    <span class="keyword">assert</span>(p*a+q*b==c)</span><br><span class="line">    <span class="keyword">if</span> (iqmp*q-<span class="number">1</span>)%p == <span class="number">0</span> <span class="keyword">and</span> (ipmq*p-<span class="number">1</span>)%q == <span class="number">0</span>:</span><br><span class="line">        M = <span class="built_in">pow</span>(enc,d,p*q)</span><br><span class="line">        flag += <span class="built_in">str</span>(long_to_bytes(M))[<span class="number">2</span>:-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2</span></span><br><span class="line">n= ...</span><br><span class="line">c= ...</span><br><span class="line">hint= ...</span><br><span class="line">h2 = <span class="built_in">pow</span>(<span class="number">114514</span>,n,n)</span><br><span class="line">p = GCD(n,hint-h2)</span><br><span class="line">q = n//p</span><br><span class="line">phi = (p-<span class="number">1</span>)*(q-<span class="number">1</span>)</span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">d = inverse(e,phi)</span><br><span class="line">m = <span class="built_in">pow</span>(c,d,n)</span><br><span class="line">flag += <span class="built_in">str</span>(long_to_bytes(m))[<span class="number">2</span>:-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure>
<p>得到flag:</p>
<font size="4" color="red">NSSCTF{e713afa4-fcd8-419f-a1a6-959449b4df5a}</font>

<p><br></p>
<p><br></p>
<p><br></p>
<h2 id="LatticeLCG"><a href="#LatticeLCG" class="headerlink" title="LatticeLCG"></a>LatticeLCG</h2><p>题目：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">flag = <span class="string">b&#x27;NSSCTF&#123;******************************&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line">a = getPrime(<span class="number">512</span>)</span><br><span class="line">seed = getPrime(<span class="number">512</span>)</span><br><span class="line">b = bytes_to_long(flag)</span><br><span class="line">n = getPrime(<span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line">e1 = <span class="number">2333</span></span><br><span class="line">e2 = <span class="number">23333</span></span><br><span class="line">c1 = <span class="built_in">pow</span>(a,e1,n)</span><br><span class="line">c2 = <span class="built_in">pow</span>(a,e2,n)</span><br><span class="line"></span><br><span class="line">output = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    seed = (a*seed+b)%n</span><br><span class="line">    output.append(seed)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;c1 = &quot;</span>,c1)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;c2 = &quot;</span>,c2)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;output1 = &quot;</span>,output[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;output2 = &quot;</span>,output[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">e = [getPrime(<span class="number">128</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>)]</span><br><span class="line">out = []</span><br><span class="line">m = getPrime(<span class="number">64</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> e:</span><br><span class="line">    out.append(<span class="built_in">pow</span>(m,i,n))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;e=&quot;</span>,e)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;out=&quot;</span>,out)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">c1 = ...</span></span><br><span class="line"><span class="string">c2 = ...</span></span><br><span class="line"><span class="string">output1 = ...</span></span><br><span class="line"><span class="string">output2 = ...</span></span><br><span class="line"><span class="string">e= []</span></span><br><span class="line"><span class="string">out= []</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<p>卡了很久，搜了很多格相关问题也没有搜到类似的，打算放弃这个题去睡觉的时候，突然恍然大悟。这里好好阐述一下我的思路，希望能帮助到一些和我一样刚刚接触格的ctfer。</p>
<p>首先，题目很明显的分成了三个部分：</p>
<ul>
<li>共模攻击</li>
<li>LCG求参数</li>
<li>Lattice</li>
</ul>
<p>首先要明确求解顺序。flag以LCG中参数b的形式存在，因此LCG应该是题目的最后一步。并且要想求解出这个LCG的b，是需要知道a与n的值的，在第一部共模攻击中显然是已知n求解a。所以就明确了如下的解题顺序：</p>
<ol>
<li>Lattice求解模数n</li>
<li>共模攻击求解a</li>
<li>LCG恢复参数b，得到flag</li>
</ol>
<p>后面两个步骤非常容易，主要问题就在第一步：<strong>为什么要利用格求解n？</strong> <strong>怎么用格求解n？</strong>下面是我对这个问题的分析：</p>
<p>先来看看给了些什么条件：一个64bit的小量m，依次产生20个128bit的素数对其进行类似RSA的加密，并且给了我们加密指数的列表以及密文的列表。题目满足两个经典条件：<strong>存在小量</strong> ，<strong>提供多个方程组参数</strong>，这样的问题在很多crypto题目中都是用格方法求解的，所以要想到利用格方法(题目的名字虽然说得很明白，但是如果没有，看到这种形式也应该联想到这个方法)</p>
<p>注意到m不变，模数n也不变，同时加密指数互素，这其实很像共模攻击的情景，只是n未知。回想一下在已知模数n的情况下共模攻击的实施方法，不难产生下面这个解题思路：</p>
<p>取20个方程的前三个如下：</p>
<script type="math/tex; mode=display">
out1 \equiv m^{e1} \; (mod\;  n)</script><script type="math/tex; mode=display">
out2 \equiv m^{e2} \; (mod\;  n)</script><script type="math/tex; mode=display">
out3 \equiv m^{e3} \; (mod\;  n)</script><p>因为e1，e2互素，所以存在a，b，使得：</p>
<script type="math/tex; mode=display">
a*e1+b*e2 = 1</script><p>所以可以得到：</p>
<script type="math/tex; mode=display">
out1^{a}*out2^{b}\equiv m^{a*e1+b*e2} \equiv m \quad (mod \;n)</script><p>这有什么用呢？我们同样也对2、3两式，1、3两式进行这样的操作，结合上面这个式子能得到三组模等式：</p>
<script type="math/tex; mode=display">
out1^{a}*out2^{b} \equiv m \quad (mod \;n)\qquad--1</script><script type="math/tex; mode=display">
out2^{c}*out3^{d} \equiv m \quad (mod \;n)\qquad--2</script><script type="math/tex; mode=display">
out1^{f}*out3^{g} \equiv m \quad (mod \;n)\qquad--3</script><p>1、2式作差，2、3式作差，就得到：</p>
<script type="math/tex; mode=display">
out1^{a}*out2^{b} -out2^{c}*out3^{d}\equiv 0 \quad (mod \;n)</script><script type="math/tex; mode=display">
out1^{f}*out3^{g} -out2^{c}*out3^{d}\equiv 0 \quad (mod \;n)</script><p>而现在等式左侧已经没有未知量了(a,b,c,d,f,g均能够通过扩展欧几里得求出)，那么就可以求解他们的gcd得到n。</p>
<p>可以说，想到这个思路的时候我为之一振，可惜实际操作的时候这个方法并不能实施，原因也很简单，我们进行的并非模幂运算，而是普通幂运算，<strong>并且a，b这些指数数量级很大(注意这一点)</strong>，所以是完全没有办法照这个思路解下去的。这时候我也没有想到怎么利用格，所以进度也停滞了，一卡卡到了晚上。</p>
<p>晚上我反复思考的时候，又想到了我刚刚说的那一点，也就是实施不了共模攻击的原因，在于<strong>指数的数量级很大，没有办法幂运算</strong>。我也突然联想到了Lattice中LLL算法的重要应用——求解最短向量。那么一切也就说得通了，之所以给20个素数作为加密指数，就是可以应用于格密码中，克服刚才共模攻击中两两组合时计算出的a，b过大的问题。所以构造格的思路就来了：</p>
<p>因为20个指数e均互素，所以一定存在a1，a2，a3…a20，使得</p>
<script type="math/tex; mode=display">
a1*e1+a2*e2+a3*e3+...a20*e20 = 1</script><p>所以可以列出等式：</p>
<script type="math/tex; mode=display">
\left[\begin{matrix}
a1 & a2 & a3 ... & a20
\end{matrix}\right] 

*
\left[\begin{matrix}
e1 & 1 & 0 & 0 ... & 0\\
e2 & 0 & 1 & 0 ... & 0\\
e3 & 0 & 0 & 1 ... & 0\\
...\\
e20 & 0 & 0 & 0 ... & 1\\
\end{matrix}\right]

=

\left[\begin{matrix}
1 & a1 & a2 ... & a20
\end{matrix}\right]</script><p>很明显，这个格符合我们的要求，我们只需要从规约出来的短向量中挑出两组，按理来说，我们只需要类似的进行刚才的共模攻击即可。</p>
<p>可是实际操作又遇到了问题，这样规约出来的向量组是这样的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[ <span class="number">45</span> -<span class="number">58</span>   <span class="number">5</span> -<span class="number">16</span>  <span class="number">12</span>  -<span class="number">7</span> -<span class="number">27</span>  <span class="number">19</span>   <span class="number">6</span>  <span class="number">14</span>  <span class="number">29</span> -<span class="number">23</span> -<span class="number">36</span>  <span class="number">44</span> -<span class="number">15</span>   <span class="number">1</span>   <span class="number">8</span>  <span class="number">14</span>  -<span class="number">7</span>  <span class="number">11</span>  -<span class="number">9</span>]</span><br><span class="line">[-<span class="number">14</span> -<span class="number">27</span>  <span class="number">20</span>   <span class="number">6</span> -<span class="number">40</span>  <span class="number">20</span> -<span class="number">34</span>  -<span class="number">2</span> -<span class="number">16</span>  <span class="number">51</span>  <span class="number">35</span> -<span class="number">23</span> -<span class="number">51</span>  <span class="number">13</span>   <span class="number">3</span> -<span class="number">21</span>   <span class="number">0</span>  <span class="number">17</span>  <span class="number">11</span>  -<span class="number">7</span>   <span class="number">1</span>]</span><br><span class="line">[ <span class="number">15</span> -<span class="number">36</span> -<span class="number">21</span> -<span class="number">13</span>   <span class="number">6</span>  -<span class="number">7</span>  -<span class="number">1</span> -<span class="number">59</span> -<span class="number">23</span>  <span class="number">42</span> -<span class="number">33</span>  <span class="number">15</span> -<span class="number">30</span>  -<span class="number">4</span>  <span class="number">39</span>  <span class="number">26</span>  <span class="number">41</span>   <span class="number">1</span>  <span class="number">19</span>  <span class="number">10</span>   <span class="number">9</span>]</span><br><span class="line">[-<span class="number">23</span>   <span class="number">4</span>  <span class="number">49</span> -<span class="number">19</span>  <span class="number">22</span>  -<span class="number">9</span>  <span class="number">24</span> -<span class="number">20</span> -<span class="number">20</span>   <span class="number">3</span> -<span class="number">24</span>   <span class="number">4</span> -<span class="number">43</span> -<span class="number">86</span>  <span class="number">40</span>  <span class="number">44</span>  -<span class="number">1</span>  -<span class="number">1</span>  <span class="number">26</span>  <span class="number">25</span>   <span class="number">1</span>]</span><br><span class="line">[ <span class="number">72</span>  <span class="number">15</span> -<span class="number">11</span> -<span class="number">19</span>  <span class="number">26</span> -<span class="number">31</span> -<span class="number">56</span> -<span class="number">25</span>   <span class="number">5</span>  <span class="number">33</span> -<span class="number">27</span> -<span class="number">23</span>  <span class="number">12</span>  <span class="number">22</span>  <span class="number">11</span>  -<span class="number">1</span>  <span class="number">21</span> -<span class="number">17</span>  <span class="number">51</span> -<span class="number">31</span>   <span class="number">9</span>]</span><br><span class="line">[-<span class="number">35</span> -<span class="number">73</span>  -<span class="number">8</span>  <span class="number">19</span> -<span class="number">29</span>  <span class="number">23</span>  -<span class="number">3</span>  <span class="number">20</span> -<span class="number">10</span>  <span class="number">18</span>  <span class="number">46</span>  <span class="number">29</span>  -<span class="number">9</span>  <span class="number">69</span> -<span class="number">30</span>   <span class="number">9</span> -<span class="number">64</span>  <span class="number">13</span>  <span class="number">10</span> -<span class="number">26</span>   <span class="number">3</span>]</span><br><span class="line">[ <span class="number">20</span>  <span class="number">46</span>  <span class="number">12</span>  -<span class="number">3</span>  <span class="number">28</span>  -<span class="number">1</span> -<span class="number">68</span>  <span class="number">15</span>   <span class="number">3</span> -<span class="number">21</span> -<span class="number">48</span> -<span class="number">20</span>  <span class="number">43</span>  <span class="number">54</span>   <span class="number">9</span>  <span class="number">14</span>  -<span class="number">5</span>   <span class="number">0</span> -<span class="number">44</span> -<span class="number">24</span>   <span class="number">8</span>]</span><br><span class="line">[ <span class="number">49</span>   <span class="number">0</span> -<span class="number">10</span>   <span class="number">0</span> -<span class="number">46</span> -<span class="number">47</span>  <span class="number">24</span>  -<span class="number">2</span>  <span class="number">13</span>  <span class="number">10</span>  -<span class="number">3</span>  <span class="number">48</span>  <span class="number">43</span> -<span class="number">28</span>  -<span class="number">3</span>  <span class="number">53</span> -<span class="number">15</span>  -<span class="number">6</span>  <span class="number">31</span> -<span class="number">23</span>  <span class="number">12</span>]</span><br><span class="line">[ -<span class="number">6</span>   <span class="number">0</span>   <span class="number">9</span>  <span class="number">42</span> -<span class="number">49</span> -<span class="number">38</span>   <span class="number">8</span>  <span class="number">12</span>   <span class="number">7</span>  <span class="number">39</span>  <span class="number">30</span> -<span class="number">26</span>  <span class="number">18</span>  <span class="number">37</span>  <span class="number">28</span> -<span class="number">28</span>   <span class="number">8</span>   <span class="number">2</span> -<span class="number">67</span> -<span class="number">21</span> -<span class="number">15</span>]</span><br><span class="line">[-<span class="number">56</span>  <span class="number">23</span>  <span class="number">22</span>  <span class="number">29</span>  -<span class="number">7</span> -<span class="number">19</span>  <span class="number">19</span>  -<span class="number">8</span>   <span class="number">6</span>  <span class="number">35</span>   <span class="number">4</span>  -<span class="number">8</span>  <span class="number">22</span>  -<span class="number">2</span> -<span class="number">44</span> -<span class="number">69</span>  <span class="number">16</span>  -<span class="number">8</span>  -<span class="number">7</span> -<span class="number">45</span>  <span class="number">21</span>]</span><br><span class="line">[-<span class="number">21</span>  <span class="number">16</span>  <span class="number">34</span> -<span class="number">39</span>  <span class="number">36</span>   <span class="number">1</span>  <span class="number">57</span> -<span class="number">30</span>  -<span class="number">2</span>  -<span class="number">2</span> -<span class="number">36</span>  -<span class="number">9</span>   <span class="number">9</span> -<span class="number">27</span>   <span class="number">8</span> -<span class="number">31</span> -<span class="number">31</span>  <span class="number">32</span>  <span class="number">12</span>  -<span class="number">2</span>  <span class="number">15</span>]</span><br><span class="line">[ -<span class="number">9</span>  -<span class="number">7</span>   <span class="number">6</span>  <span class="number">40</span>  <span class="number">32</span> -<span class="number">49</span> -<span class="number">26</span> -<span class="number">60</span>  <span class="number">17</span>   <span class="number">0</span> -<span class="number">13</span>   <span class="number">7</span>  <span class="number">25</span>  <span class="number">57</span> -<span class="number">19</span>  <span class="number">28</span>  -<span class="number">3</span> -<span class="number">34</span>  <span class="number">11</span> -<span class="number">12</span> -<span class="number">17</span>]</span><br><span class="line">[-<span class="number">30</span> -<span class="number">13</span>  <span class="number">28</span> -<span class="number">42</span>   <span class="number">8</span> -<span class="number">46</span>  <span class="number">56</span>  <span class="number">33</span> -<span class="number">56</span> -<span class="number">40</span> -<span class="number">24</span>   <span class="number">4</span>  <span class="number">10</span>  <span class="number">15</span>  <span class="number">46</span>  <span class="number">50</span> -<span class="number">13</span>  <span class="number">18</span> -<span class="number">21</span>  <span class="number">17</span>  <span class="number">16</span>]</span><br><span class="line">[-<span class="number">17</span> -<span class="number">11</span>  -<span class="number">5</span>  <span class="number">29</span>  <span class="number">14</span>   <span class="number">6</span> -<span class="number">13</span>   <span class="number">4</span>  <span class="number">42</span> -<span class="number">69</span>  <span class="number">30</span>   <span class="number">9</span>   <span class="number">3</span> -<span class="number">37</span>   <span class="number">5</span>   <span class="number">7</span> -<span class="number">17</span>  <span class="number">50</span>   <span class="number">6</span>  <span class="number">14</span> -<span class="number">38</span>]</span><br><span class="line">[ <span class="number">53</span> -<span class="number">12</span>  <span class="number">16</span>  <span class="number">36</span>   <span class="number">1</span>  <span class="number">38</span> -<span class="number">52</span>  <span class="number">25</span> -<span class="number">10</span> -<span class="number">41</span>  -<span class="number">3</span> -<span class="number">37</span>   <span class="number">6</span> -<span class="number">12</span>   <span class="number">1</span>  -<span class="number">4</span> -<span class="number">25</span>  <span class="number">41</span>   <span class="number">5</span>   <span class="number">1</span>  <span class="number">29</span>]</span><br><span class="line">[ -<span class="number">3</span>   <span class="number">1</span>  <span class="number">36</span>  <span class="number">22</span>   <span class="number">7</span>  -<span class="number">5</span> -<span class="number">10</span>  <span class="number">15</span> -<span class="number">10</span> -<span class="number">27</span>  <span class="number">35</span> -<span class="number">60</span> -<span class="number">36</span>   <span class="number">9</span> -<span class="number">57</span>  <span class="number">33</span> -<span class="number">21</span>  <span class="number">43</span>  <span class="number">28</span> -<span class="number">44</span>   <span class="number">8</span>]</span><br><span class="line">[ <span class="number">32</span> -<span class="number">26</span>  <span class="number">18</span>  -<span class="number">9</span>  -<span class="number">5</span>  <span class="number">37</span>  -<span class="number">8</span>   <span class="number">2</span> -<span class="number">36</span> -<span class="number">28</span>  <span class="number">43</span>  <span class="number">10</span> -<span class="number">32</span>  <span class="number">37</span> -<span class="number">24</span> -<span class="number">70</span>  <span class="number">22</span> -<span class="number">35</span>  <span class="number">49</span>  -<span class="number">2</span>  <span class="number">31</span>]</span><br><span class="line">[-<span class="number">33</span>  <span class="number">15</span> -<span class="number">25</span>   <span class="number">1</span> -<span class="number">40</span>   <span class="number">3</span>  -<span class="number">2</span> -<span class="number">32</span>  <span class="number">15</span>   <span class="number">9</span> -<span class="number">20</span> -<span class="number">27</span> -<span class="number">27</span>  <span class="number">35</span>  <span class="number">26</span>  -<span class="number">1</span> -<span class="number">45</span> -<span class="number">12</span>  <span class="number">45</span>  <span class="number">23</span>  <span class="number">36</span>]</span><br><span class="line">[-<span class="number">17</span>   <span class="number">0</span>  <span class="number">18</span> -<span class="number">20</span> -<span class="number">75</span>  -<span class="number">5</span>  <span class="number">55</span>  <span class="number">42</span>  <span class="number">16</span>   <span class="number">8</span> -<span class="number">45</span>   <span class="number">5</span> -<span class="number">24</span> -<span class="number">20</span> -<span class="number">50</span> -<span class="number">11</span>   <span class="number">0</span>  <span class="number">27</span>  <span class="number">40</span>  <span class="number">18</span>   <span class="number">8</span>]</span><br><span class="line">[ <span class="number">11</span>   <span class="number">5</span>  <span class="number">16</span>  <span class="number">37</span>  -<span class="number">2</span>  -<span class="number">6</span>  <span class="number">28</span>  <span class="number">19</span> -<span class="number">21</span>   <span class="number">5</span>  -<span class="number">8</span>  <span class="number">63</span>  -<span class="number">8</span> -<span class="number">21</span>  <span class="number">22</span> -<span class="number">23</span> -<span class="number">57</span>  <span class="number">13</span>  -<span class="number">5</span>  <span class="number">15</span> -<span class="number">39</span>]</span><br></pre></td></tr></table></figure>
<p>第一列并不是我们想要的1，说明第一列是1的向量对比起来长度并不小。再想一下规约的目的，其实很容易就能相同第一列是多少并不重要，重要的是<strong>短向量的第一列相同</strong>(这一点非常容易想通，没理解的话仔细想想)。而要让他们相同，最有效的办法就是让他们均为0，想到这一点后，就可以在格的第一列乘上一个大数K，从而有效的调整一下格，如下：</p>
<script type="math/tex; mode=display">
\left[\begin{matrix}
K*e1 & 1 & 0 & 0 ... & 0\\
K*e2 & 0 & 1 & 0 ... & 0\\
K*e3 & 0 & 0 & 1 ... & 0\\
...\\
K*e20 & 0 & 0 & 0 ... & 1\\
\end{matrix}\right]</script><p>这样一来，最短向量的第一列就不太可能不是0了(因为会对应的扩大K倍，显著地使规约向量变长)，我测试出取100左右即可，然后就可以求解最大公约数(此时还需注意两点小问题：一是规约出的短向量有负数，普通幂运算中会变成分数形式，通分至等式右侧即可；二是求得的公约数仍有可能是k倍的n，需要去除一些小因子)，最终得到n。</p>
<p><br></p>
<p>recovern.ipynb:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">e= []</span><br><span class="line">c= []</span><br><span class="line"></span><br><span class="line"><span class="comment">#step1</span></span><br><span class="line">L = Matrix(ZZ, <span class="number">20</span>, <span class="number">21</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>):</span><br><span class="line">    L[i,<span class="number">0</span>] = e[i]*<span class="number">1000</span></span><br><span class="line">    L[i,i+<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">L = L.LLL()</span><br><span class="line"></span><br><span class="line">alist1 = L[<span class="number">0</span>][<span class="number">1</span>:]</span><br><span class="line">k1nl = <span class="number">1</span></span><br><span class="line">k1nr = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>):</span><br><span class="line">    <span class="keyword">if</span>(alist1[i]&lt;<span class="number">0</span>):</span><br><span class="line">        k1nr *= c[i]**(-alist1[i])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        k1nl *= c[i]**alist1[i]</span><br><span class="line">k1n = k1nl-k1nr</span><br><span class="line"></span><br><span class="line">alist2 = L[<span class="number">1</span>][<span class="number">1</span>:]</span><br><span class="line">k2nl = <span class="number">1</span></span><br><span class="line">k2nr = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>):</span><br><span class="line">    <span class="keyword">if</span>(alist2[i]&lt;<span class="number">0</span>):</span><br><span class="line">        k2nr *= c[i]**(-alist2[i])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        k2nl *= c[i]**alist2[i]</span><br><span class="line">k2n = k2nl-k2nr</span><br><span class="line"></span><br><span class="line">n = gcd(k1n,k2n)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,<span class="number">10000</span>):</span><br><span class="line">    <span class="keyword">while</span>(n % i == <span class="number">0</span>):</span><br><span class="line">        n //= i</span><br><span class="line"></span><br><span class="line"><span class="comment">#检查一下n的长度是否为1024bit</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(<span class="built_in">bin</span>(n)[<span class="number">2</span>:]))</span><br><span class="line"><span class="built_in">print</span>(n)</span><br></pre></td></tr></table></figure>
<p>后两个问题也就迎刃而解，最终得到flag：</p>
<font size="4" color="red">NSSCTF{407f8832-6ffd-43bf-91a0-6900758cdff7}</font>

<p><br></p>
<p><br></p>
<p><br></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总的说来，对格的应用还不够灵活，还需要加深学习。</p>
<p>如果各位有不懂的地方或者发现了文中的问题，欢迎联系我，一起学习进步。</p>
]]></content>
      <categories>
        <category>wp-crypto</category>
      </categories>
  </entry>
  <entry>
    <title>misc趣题(一)</title>
    <url>/post/77e39860.html</url>
    <content><![CDATA[<p>在CNSS 2023的夏令营线上题中找到的一道misc题，看到标题有Crypto，感兴趣就去试了一试，发现确实是道比较有意思的题目，就在此记录一下，同时也开启 <strong>misc趣题</strong> 这一分类。</p>
<span id="more"></span>
<h2 id="🔑-Shino-的-Crypto-梦想"><a href="#🔑-Shino-的-Crypto-梦想" class="headerlink" title="🔑 Shino 的 Crypto 梦想"></a>🔑 Shino 的 Crypto 梦想</h2><p>题目来源：2023-CNSS-Summer</p>
<p>题目描述：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">刚刚接触网络安全不久的 Shino 有一个成为 Crypto 方向专家的梦想，所以他写了一个很安全的加密算法，你可以帮他看看吗？</span><br></pre></td></tr></table></figure>
<p>端口：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nc 47.108.140.140 11037</span><br></pre></td></tr></table></figure>
<p>Hint：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、你可能需要pwntools</span><br><span class="line">2、cnss&#123;a-zA-Z0-9_&#125;</span><br><span class="line">   保证&#125;只在 flag 结尾出现一次</span><br><span class="line">   flag 长度不大于 50</span><br></pre></td></tr></table></figure>
<p>题目：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> cipher, key</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Encoder</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.stream = self.randomBox(self._init_box(key))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">do_encrypt</span>(<span class="params">self, c</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">ord</span>(c) ^ <span class="built_in">next</span>(self.stream)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_init_box</span>(<span class="params">self, crypt_key</span>):</span><br><span class="line">        Box = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">256</span>))</span><br><span class="line">        key_length = <span class="built_in">len</span>(crypt_key)</span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">            index = <span class="built_in">ord</span>(crypt_key[(i % key_length)])</span><br><span class="line">            j = (j + Box[i] + index) % <span class="number">256</span></span><br><span class="line">            Box[i], Box[j] = Box[j], Box[i]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Box</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">randomBox</span>(<span class="params">self, S</span>):</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            i = i + <span class="number">1</span> &amp; <span class="number">255</span></span><br><span class="line">            j = j + S[i] &amp; <span class="number">255</span></span><br><span class="line">            S[i], S[j] = S[j], S[i]</span><br><span class="line">            <span class="keyword">yield</span> S[(S[i] + S[j] &amp; <span class="number">255</span>)]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">encoder = Encoder()</span><br><span class="line">flag = <span class="built_in">input</span>(<span class="string">&quot;input flag&gt;&gt; &quot;</span>)</span><br><span class="line">table = string.digits + string.ascii_letters + <span class="string">&quot;&#123;&#125;_&quot;</span></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line">correct = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> i &lt; <span class="built_in">len</span>(flag):</span><br><span class="line">    <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(flag) <span class="keyword">and</span> flag[i] <span class="keyword">not</span> <span class="keyword">in</span> table:</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> i &gt;= <span class="built_in">len</span>(flag):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> cipher[i] != encoder.do_encrypt(flag[i]):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Wrong flag!&quot;</span>)</span><br><span class="line">        exit(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        correct += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> correct == <span class="built_in">len</span>(cipher):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Correct flag!&quot;</span>)</span><br><span class="line">        exit(<span class="number">0</span>)</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Wrong flag!&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>首先，题目的加密算法是RC4，可以先检查一下有无变种，方法是自己随便使用一组明文和密钥，分别用该程序与在线网站加密，检查结果是否相同。这样操作之后可以发现，结果是完全一样的，这说明本题并没有对RC4进行魔改，也因此解题的思路也就很自然的从开始的解密码转变成了找漏洞。</p>
<p>而要找漏洞的程序段如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">encoder = Encoder()</span><br><span class="line">flag = <span class="built_in">input</span>(<span class="string">&quot;input flag&gt;&gt; &quot;</span>)</span><br><span class="line">table = string.digits + string.ascii_letters + <span class="string">&quot;&#123;&#125;_&quot;</span></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line">correct = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> i &lt; <span class="built_in">len</span>(flag):</span><br><span class="line">    <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(flag) <span class="keyword">and</span> flag[i] <span class="keyword">not</span> <span class="keyword">in</span> table:</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> i &gt;= <span class="built_in">len</span>(flag):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> cipher[i] != encoder.do_encrypt(flag[i]):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Wrong flag!&quot;</span>)</span><br><span class="line">        exit(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        correct += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> correct == <span class="built_in">len</span>(cipher):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Correct flag!&quot;</span>)</span><br><span class="line">        exit(<span class="number">0</span>)</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Wrong flag!&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>先大致理解程序内容：程序需要你输入一串flag值，并将flag值逐个进行RC4加密并检查是否与密文相等，当输入的flag串加密值与密文完全相等时，便通过了检查，程序输出”Correct flag!”。</p>
<p>所以，这么一大段其实就只实现了一个内容：检查你输入的flag和你实际要提交的flag是否相等！可以说，整个程序都是一个障眼法，其实不要这个RC4，直接用以下的代码检查也是一样的：(假设实际flag串名为secret)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">flag = <span class="built_in">input</span>(<span class="string">&quot;input flag&gt;&gt; &quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(flag == secret):</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;Correct flag!&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;Wrong flag!&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>这样就行了！所以用这么一大段来核查flag一定有问题。</p>
<p>仔细核查，果然，下面这段代码大有玄机：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> i &lt; <span class="built_in">len</span>(flag):</span><br><span class="line">    <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(flag) <span class="keyword">and</span> flag[i] <span class="keyword">not</span> <span class="keyword">in</span> table:</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> i &gt;= <span class="built_in">len</span>(flag):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> cipher[i] != encoder.do_encrypt(flag[i]):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Wrong flag!&quot;</span>)</span><br><span class="line">        exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>这段代码存在以下几个问题：</p>
<ul>
<li>输入的flag串中含有不在table中的项时，会一直跳过直至读到table中的字符为止，但是指数 i 会一直增加。</li>
<li>判断指数 i 过大，依靠的是输入的字符串长度，而不是实际的flag串。</li>
<li>将cipher[i]与encrypt(flag[i])进行比对时，并没有对cipher的指数进行检查。</li>
</ul>
<p>这体现了一个很重要的信息：</p>
<ul>
<li>如果你的输入是正常的错误flag串，他会打印的内容是”Wrong flag!”</li>
<li>如果你的输入是不正常的构造的字符串导致cipher[i]越界了，程序不会正常打印内容，而会报错！</li>
</ul>
<p>举个例子，构造如下两个串：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag = &quot;cnss&#123;1234567890abcdefgh&#125;&quot;</span><br><span class="line">flag = chr(0) * 50 + &quot;c&quot;</span><br></pre></td></tr></table></figure>
<p>那么，程序对第两个字符串的处理分别是：</p>
<p>由于第一个串字符均在table中，因此程序仅仅会将每个字符与正确flag进行比对，直到某个字符比对失败时，打印出”Wrong flag!”</p>
<p>而第二个串前五十个字符均是ASCII码为0的字符，是不在table中的，因此程序会先反复执行以下语句：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> i &lt; <span class="built_in">len</span>(flag) <span class="keyword">and</span> flag[i] <span class="keyword">not</span> <span class="keyword">in</span> table:</span><br><span class="line">    i += <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>直至第51个字符”c”，由于”c”在table中，因此会进行比对。此时i=51，而由题目知道，flag长度不大于50，因此这时执行这条语句进行比对时：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> cipher[i] != encoder.do_encrypt(flag[i]):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Wrong flag!&quot;</span>)</span><br><span class="line">    exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>cipher[i]是必定越界的！那么程序就会抛出一个异常，而不再是打印”Wrong flag!”了。</p>
<p>这有什么用呢？用处很大。首先我们就可以反复构造如下字符串，发送给靶机端来确定真实flag的正确长度：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">flag = <span class="built_in">chr</span>(<span class="number">0</span>) * <span class="number">49</span> + <span class="string">&quot;c&quot;</span></span><br><span class="line">flag = <span class="built_in">chr</span>(<span class="number">0</span>) * <span class="number">48</span> + <span class="string">&quot;c&quot;</span></span><br><span class="line">flag = <span class="built_in">chr</span>(<span class="number">0</span>) * <span class="number">47</span> + <span class="string">&quot;c&quot;</span></span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p>为什么这样就可以确定长度呢？我们假设flag的正确长度是30，那么发送下面字符串给靶机，靶机的回应都是“异常”而非错误，这是因为cipher数组的下标最多只能取到29，一旦涉及到cipher[30]甚至更多就会产生越界异常：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">flag = <span class="built_in">chr</span>(<span class="number">0</span>) * <span class="number">49</span> + <span class="string">&quot;c&quot;</span></span><br><span class="line">flag = <span class="built_in">chr</span>(<span class="number">0</span>) * <span class="number">48</span> + <span class="string">&quot;c&quot;</span></span><br><span class="line">flag = <span class="built_in">chr</span>(<span class="number">0</span>) * <span class="number">47</span> + <span class="string">&quot;c&quot;</span></span><br><span class="line">......</span><br><span class="line">flag = <span class="built_in">chr</span>(<span class="number">0</span>) * <span class="number">30</span> + <span class="string">&quot;c&quot;</span></span><br></pre></td></tr></table></figure>
<p>然而发送下一个flag串，也就是：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">flag = <span class="built_in">chr</span>(<span class="number">0</span>) * <span class="number">29</span> + <span class="string">&quot;c&quot;</span></span><br></pre></td></tr></table></figure>
<p>这时，由于没有越界，程序会回应”Wrong flag!”，而不再抛出异常了。</p>
<p>所以，由上述方式，我们就可以最终确定flag的真实长度是24，之后则可以反复构造下列字符串，并发送给靶机端来逐个核查字符是否正确：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> table:</span><br><span class="line">	flag = <span class="string">&quot;cnss&#123;&quot;</span> + i + <span class="built_in">chr</span>(<span class="number">0</span>)*<span class="number">100</span> + <span class="string">&quot;a&quot;</span></span><br></pre></td></tr></table></figure>
<p>道理也是相同的，如果i是错误字符，那么核查不通过，程序直接回应”Wrong flag!”，而如果是正确字符，程序则会继续向后读，一直到读到越界的”a”后，抛出越界异常。</p>
<p>得到这个字符为 “1” 后，将他加入”cnss{“串后，继续构造下面字符串：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> table:</span><br><span class="line">	flag = <span class="string">&quot;cnss&#123;1&quot;</span> + i + <span class="built_in">chr</span>(<span class="number">0</span>)*<span class="number">100</span> + <span class="string">&quot;a&quot;</span></span><br></pre></td></tr></table></figure>
<p>如此反复发送直至flag串已知的部分长度为24即可。</p>
<p>构造字符串并发送给靶机端需要用到pwntools，同时还有一些小细节需要注意，比如需要发送的是字节流而非字符串流。但是这些慢慢调试程序就好了。</p>
<p>exp.py：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">table = string.digits + string.ascii_letters + <span class="string">&quot;&#123;&#125;_&quot;</span></span><br><span class="line"></span><br><span class="line">init = <span class="string">b&#x27;cnss&#123;&#x27;</span></span><br><span class="line">has_find = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">if</span>(has_find == <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(table)):</span><br><span class="line">        r=remote(<span class="string">&quot;47.108.140.140&quot;</span>,<span class="number">11037</span>)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            r.sendline(init + long_to_bytes(<span class="built_in">ord</span>(table[i])) + <span class="string">b&#x27;\x00&#x27;</span>*<span class="number">100</span> + <span class="string">b&quot;a&quot;</span>)</span><br><span class="line">            temp = r.recvline()</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">b&quot;Correct&quot;</span> <span class="keyword">in</span> temp):</span><br><span class="line">                exit(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">len</span>(init) == <span class="number">23</span>):</span><br><span class="line">                has_find = <span class="number">1</span></span><br><span class="line">                r.close()</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            init += long_to_bytes(<span class="built_in">ord</span>(table[i]))</span><br><span class="line">            <span class="built_in">print</span>(init)</span><br><span class="line">            r.close()</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        r.close()</span><br><span class="line"><span class="built_in">print</span>(init + <span class="string">b&quot;&#125;&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>得到flag：</p>
<p><strong>cnss{1nd3X_0Ut_oF_r4nge}</strong></p>
<p><br></p>
<p>确实很有意思！</p>
]]></content>
      <categories>
        <category>misc趣题</category>
      </categories>
  </entry>
  <entry>
    <title>SICTF-2023-#Round2-wp-misc</title>
    <url>/post/ccf22797.html</url>
    <content><![CDATA[<p>浅做点misc娱乐娱乐</p>
<span id="more"></span>
<h3 id="签到-Welcome"><a href="#签到-Welcome" class="headerlink" title="[签到]Welcome"></a>[签到]Welcome</h3><p>题目描述：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">关注微信公众号并发送&quot;SICTF2023&quot;就可以获得flag辣！</span><br></pre></td></tr></table></figure>
<p>签到题，照着做即可。</p>
<p><img src="/post/ccf22797.htm/hexo\myblog\source\_posts\SICTF-2023-Round2-wp-misc\image-20230908162949748.png" alt="image-20230908162949748"></p>
<p>flag：</p>
<p><strong>SICTF{Welcome_to_SICTF2023_#Round2}</strong></p>
]]></content>
      <categories>
        <category>wp-misc</category>
      </categories>
  </entry>
</search>

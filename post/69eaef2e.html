<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon_small.ico">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="RnN18ZogmZl_dLVpxZ6y8kjKL73Mu9VLVEkw9d3qrq0" />
  <meta name="msvalidate.01" content="DC3050AD55F30DDF75AAB78517714910" />
  <meta name="baidu-site-verification" content="codeva-PPofu3dNxe" />

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-loading-bar.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"tangcuxiaojikuai.xyz","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="负责了第二届新生赛Crypto的出题工作，全部wp在此。这里不会放输出文件（有点长），可以在官方仓库中找到： CatCTF-2024&#x2F;Crypto at main · Cat-Training-Force&#x2F;CatCTF-2024 (github.com)">
<meta property="og:type" content="article">
<meta property="og:title" content="2024-同济大学第二届网络安全新生赛CatCTF-wp-crypto">
<meta property="og:url" content="https://tangcuxiaojikuai.xyz/post/69eaef2e.html">
<meta property="og:site_name" content="糖醋小鸡块的blog">
<meta property="og:description" content="负责了第二届新生赛Crypto的出题工作，全部wp在此。这里不会放输出文件（有点长），可以在官方仓库中找到： CatCTF-2024&#x2F;Crypto at main · Cat-Training-Force&#x2F;CatCTF-2024 (github.com)">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://tangcuxiaojikuai.xyz/post/69eaef2e/image-20241006213955287.png">
<meta property="article:published_time" content="2024-10-21T11:12:53.000Z">
<meta property="article:modified_time" content="2024-10-22T03:59:30.801Z">
<meta property="article:author" content="糖醋小鸡块">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://tangcuxiaojikuai.xyz/post/69eaef2e/image-20241006213955287.png">

<link rel="canonical" href="https://tangcuxiaojikuai.xyz/post/69eaef2e.html">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>2024-同济大学第二届网络安全新生赛CatCTF-wp-crypto | 糖醋小鸡块的blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">糖醋小鸡块的blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-友链">

    <a href="/links/" rel="section"><i class="fa fa-link fa-fw"></i>友链</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tangcuxiaojikuai.xyz/post/69eaef2e.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/image.png">
      <meta itemprop="name" content="糖醋小鸡块">
      <meta itemprop="description" content=""追风赶月莫停留，平芜尽处是春山"">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="糖醋小鸡块的blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          2024-同济大学第二届网络安全新生赛CatCTF-wp-crypto
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-10-21 19:12:53" itemprop="dateCreated datePublished" datetime="2024-10-21T19:12:53+08:00">2024-10-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-10-22 11:59:30" itemprop="dateModified" datetime="2024-10-22T11:59:30+08:00">2024-10-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/wp-crypto/" itemprop="url" rel="index"><span itemprop="name">wp-crypto</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/post/69eaef2e.html#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/post/69eaef2e.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>负责了第二届新生赛Crypto的出题工作，全部wp在此。这里不会放输出文件（有点长），可以在官方仓库中找到：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/Cat-Training-Force/CatCTF-2024/tree/main/Crypto">CatCTF-2024/Crypto at main · Cat-Training-Force/CatCTF-2024 (github.com)</a></p>
<span id="more"></span>
<h2 id="Week1"><a href="#Week1" class="headerlink" title="Week1"></a>Week1</h2><p>Week1主要是传统一点的密码题型。</p>
<p><br></p>
<h3 id="Signin-75-Solves-25-100-pts"><a href="#Signin-75-Solves-25-100-pts" class="headerlink" title="Signin(75 Solves, 25/100 pts)"></a>Signin(75 Solves, 25/100 pts)</h3><p>题目描述：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Bear heard sth like &#x27;Caesar&#x27;?</span><br></pre></td></tr></table></figure>
<p>题目：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6664776677697e583834714a62537536496c7b62666477667769623a33624934716762733777687551766272696246646876647580</span><br></pre></td></tr></table></figure>
<p>题目描述里明确指出是凯撒，所以先解一下十六进制可以发现和已知的flag头”catctf”ASCII码差了3，所以再移位回去就好。生成密文脚本为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&quot;</span>.join([<span class="built_in">hex</span>((flag[i] + <span class="number">3</span>) % <span class="number">256</span>)[<span class="number">2</span>:].zfill(<span class="number">2</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(flag))]))</span><br></pre></td></tr></table></figure>
<p>exp：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">c = <span class="string">&quot;6664776677697e583834714a62537536496c7b62666477667769623a33624934716762733777687551766272696246646876647580&quot;</span></span><br><span class="line">c = <span class="built_in">bytes</span>.fromhex(c)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&quot;</span>.join([<span class="built_in">chr</span>((c[i] - <span class="number">3</span>) % <span class="number">256</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(c))]).encode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#catctf&#123;U51nG_Pr3Fix_catctf_70_F1nd_p4terNs_of_Caesar&#125;</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p><br></p>
<h3 id="Double-AES-10-Solves-86-300-pts"><a href="#Double-AES-10-Solves-86-300-pts" class="headerlink" title="Double AES(10 Solves, 86/300 pts)"></a>Double AES(10 Solves, 86/300 pts)</h3><p>题目描述：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Bear accidentally got two ciphertexts of the same AES encryptor!</span><br></pre></td></tr></table></figure>
<p>题目：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.Padding <span class="keyword">import</span> pad</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag</span><br><span class="line"></span><br><span class="line">key, iv = flag[:<span class="number">16</span>].encode(), <span class="string">b&quot;CatCTF2024&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;c =&quot;</span>, AES.new(key=key,nonce=iv,mode=AES.MODE_CTR).encrypt(pad(flag.encode(),<span class="number">16</span>)) + AES.new(key=key,nonce=iv,mode=AES.MODE_CTR).encrypt(<span class="string">b&quot;&quot;</span>.join([pad(i.encode(),<span class="number">16</span>) <span class="keyword">for</span> i <span class="keyword">in</span> flag])))</span><br></pre></td></tr></table></figure>
<p>题目基于AES的CTR模式，用flag的前16个字节当作密钥，用”CatCTF2024”当作iv，然后分别加密：</p>
<ul>
<li>整体pad到十六字节整数倍的flag串</li>
<li>逐字节pad到十六字节整数倍的flag串</li>
</ul>
<p>题目将两个密文连接起来给出，要求还原flag。</p>
<p>首先我们要把两个密文分离开才行，为此我们需要确定flag长度，而确定flag长度的依据是密文长度。由于有pad的存在，密文以16字节为一组，其分组数量为：</p>
<script type="math/tex; mode=display">
\lceil\frac{len(flag)}{16}\rceil + len(flag)</script><blockquote>
<p>这里其实并不准确，因为如果flag长度恰为16的整数倍的话pad会多一个分组</p>
</blockquote>
<p>我们可以小范围遍历一下flag可能的字节数，判断其满不满足上面的式子，就可以确定下来flag的长度为49，从而分离两部分密文。</p>
<p>分离密文之后下一步就是恢复flag，为此需要了解一下CTR加密模式，以下是一个简单示意图：</p>
<p><img src="/post/69eaef2e/image-20241006213955287.png" alt="image-20241006213955287"></p>
<p>可以看出CTR模式加密步骤是：</p>
<ul>
<li>加密当前Counter</li>
<li>将加密的Counter与当前分组明文异或，得到当前分组密文</li>
<li>Counter加一，用于下一分组加密</li>
</ul>
<p>而由于加密两部分密文的密钥和起始Counter都一样，所以说他们异或的是同一个密钥流。而我们知道flag头，也就知道了第二部分密文第一个分组的明文是：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">b&quot;c&quot;</span> + <span class="string">b&quot;\x0f&quot;</span>*<span class="number">15</span></span><br></pre></td></tr></table></figure>
<p>将该明文与第一组密文异或就得到了第一组的密钥流，再与第一部分密文的第一组异或就得到了明文，而这个明文是key，就可以解得所有密文了。</p>
<p>exp：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> xor</span><br><span class="line"></span><br><span class="line">c = <span class="string">b&#x27;\xbf\xa2\xe1P\x10\xcf4\x1a\x82\xd7M\xda\xd7?W\x8e!\xc2\xe0S\x93y\xbf\xaf\xe0l\xfdM\x0f\xb7\xac\xc0\x17\xd8\xa0+E\x97z\x95izN^\x84]yd\xdf\x8f\xcb\&#x27;\x17\x16m\xb0/5Z\xf6O\x97D\x03\xbf\xcc\x9a&lt;k\xa6@@\xb8\xb1,\xb2\x87h\x17\xd3\x1f\x8d\x818\xc34\xc2\xd5\xd8P\xb4rr\xfb\xc6\x90!\xe6\x9fG\x01\xeb*\xd8\x1f*#\x1d\xc4\x11\x1dX\xc1\x8f\xcb\&#x27;\x17\x16m\xb0/5Z\xf6O\x97D\x03^\xa1E\t\x87\x90\xc9\xc5\x95&#123;0K\x93g\xf8\r7\x9af\xa4X\x81\x0bF\x08\xf9\xe3\x01\xdf\&#x27;\xf7\x03I]\xb4T\x16H4(|\xb4 \xd3\x1f\x8b\xbe!\xefM\x11\x9cw\t$\t\x97\xc8\xf9\xe4\xcf\xe9\x91\xfa\x968s\xf8=\xbd\xf2k\xe6\x1f\xf6\xbeS\xcfH\xd6\x89_\xea\xc8\x7f8\xef?\xab\x07y\xdf\xc1\xf4\x1c\xb3\xe3\x18\x96\xbbR?\xe8\xfe\xc5[p\xe9\xa3\x91\xc3\xce\x86\xb2\xbc\xe4\t)J\x04\x86GC_y\xf7\x1b\xeb\xd7\x1c\x9al\x94\x93Tm\x99\xaf,J\x97q\x13\xaf\xb3\xd0\xc6]\x1d\n-\xfc\xae\xde&quot;@\xff\xa6F\x96\xa5p\x1bZK\x82\x07\xe4XQh\xfa\x02\xcf\x06\x81\xbe\x12z\xe1V\xa1\xab\x7f+\xf9l\xea\x02\x1d\x91\xadq\xd9\x93\xb5\x1c\x8a\x8b\xf5\xcb\x8e\x0b\xbf\x17qw\xecR\xf7\xef\xe8\x11\x96\xc2\x85\xd0.\x9f&amp;\x04\x7f\xeb:7\xbd\xaa\xb2|\x90\x16\x93\x81\xc1\x1b&gt;h\x80n\xd3\xe4H7\xa8h\x9cp\xf8Z\xd9\xe1\xddfO\xac\x1eK\x90O\x12\xf4h=\xf1^\xc3\x01Vs\xea\xe6\xa1\xaeg\xb6\&#x27;f\xf6\xc8.J2\xc9\x96\x96\xd2\x9b\x17\xc8\x97\x05IX#\xff?\xae\xd9\x18\x86^zD;\xb1\xa1\xb1?\x11\x1d\xb9a\xe9\xff+\x16\xbc\x9b\xb2\xe5\x1d\xa0\xb8(]&lt;aX\xb3\xc3\xfc\x1aU&quot;\xfb\x1c\x80T\x11.\xc2\xa5A\xb4\xa8\xcetj\x91J\xdd\xc7B\xcc v\xbb\x8e\xc5DR#\x89\xb3m\xb2\xbc\xfa\xb0\xd7\xe8\x99\xf8\xa3\xc8\x00\xf2W\xafT\x92\x86\xfd\xf4=\x1a\x84)\xd3\x12\x16\xb0\xf7\x00\xfd\x18\xaf3\xe9\xc1,\xe1u\xb6\xc2z\xffbu1\x9f\xe1\x16\xb0b\x1f\xea\x00\n\xa6\xc7\r \xde\xcd\xf7~V\x19\&#x27;\x05\xc2\xcd&gt;owY\xe9\xb2\xb4a\&#x27;\xb7\xf4+\x9d\x83\xd3\xd3`*]&gt;\xea|\xb96\&#x27;\xd7in\x9a\x1d\xf1\x92\x86\x19\xb3Q#E\x99\xe9\xe0\x902~V\x94L\xe5\xb6\xbb\xdc\x16p\xce|\xd6%\xb7\xac\xb25\x92&#123;%\xea\xa2\x0b\x0e\&#x27;)zv\x18\xcc-A\x0e\x88\xb3\xfd\x07\xe4\x8d\xe1E~\x97DWe\xf9.\xd2Q\xb8a\xa2\&#x27;\xccS\xa6j\x8e\xcd\xb0\x80\x19\x8f\xa3\x98\xf0&amp;Bq\x98\xe6dz\xc6V\x0e*\x8b6t\x8fF\xe6\xcc\x98P\xbe\xb5\xd0\x86\xd4\x17\xb3Iq\x08\x12&lt;\xf6\xda\x7f\x8da\x8c\xe87\x02D\\@\x928\xcb\xc1O\x0fd\xe0\xfa\xa2\x8a;&amp;\x14\x16g\x8f\xf6Ik\xae\x8fl,\xe0\xa1b\xfej\xdc\xc7$\x99\x95\xed\x0c$\x15\xa5n\xdeG\x02\x18&amp;t&quot;\xf8D\xb7T\xad=\x9cN`\x1e\xc3\xa3\x88\xde\x04[\\\x04)\x00\xcb\xb4+\x84T\xc5\x95\x04\t$\x1c\xa3sc\x17pppi\xd0\&#x27;\x1f3\x1d\xac\xf1\x98qU \x85\x01\x94\x80\x98\ri\x82\x1c\xf1nX\xa2&amp;e\xd2B\x90\xc5\xee\x0bf_\xc6\xb9\xbaf\x1c\x11\x9c\x04\x07\xcc\x1d#&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="number">0</span>):</span><br><span class="line">    <span class="keyword">for</span> length <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>,<span class="number">100</span>):</span><br><span class="line">        <span class="keyword">if</span>((length//<span class="number">16</span>)+<span class="number">1</span> + length == <span class="built_in">len</span>(c)//<span class="number">16</span>):</span><br><span class="line">            <span class="built_in">print</span>(length)</span><br><span class="line"></span><br><span class="line"><span class="comment">#length = 49 -&gt; padding to 64</span></span><br><span class="line">c1 = c[:<span class="number">64</span>]</span><br><span class="line">c2 = c[<span class="number">64</span>:]</span><br><span class="line">iv = <span class="string">b&quot;CatCTF2024&quot;</span></span><br><span class="line">prefix = <span class="string">b&quot;c&quot;</span>+<span class="string">b&quot;\x0f&quot;</span>*<span class="number">15</span></span><br><span class="line">key = xor(c1[:<span class="number">16</span>], xor(prefix,c2[:<span class="number">16</span>]))</span><br><span class="line"></span><br><span class="line">flag = AES.new(key=key,nonce=iv,mode=AES.MODE_CTR).decrypt(c1)</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#catctf&#123;U5ing_XOR_@nd_Bru73F0rCe_B10cKs_By_bLOCk3&#125;</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p><br></p>
<h3 id="Decision0-11-Solves-83-300-pts"><a href="#Decision0-11-Solves-83-300-pts" class="headerlink" title="Decision0(11 Solves, 83/300 pts)"></a>Decision0(11 Solves, 83/300 pts)</h3><p>题目描述：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">why I call this Decision0? Maybe you will know next week.</span><br></pre></td></tr></table></figure>
<p>题目：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag</span><br><span class="line"></span><br><span class="line">flag_bin = <span class="built_in">bin</span>(bytes_to_long(flag))[<span class="number">2</span>:].zfill(<span class="built_in">len</span>(flag)*<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">F0</span>():</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line">        E = random_matrix(Zmod(n), <span class="number">4</span>, <span class="number">4</span>)</span><br><span class="line">        <span class="keyword">if</span>(E.rank() == <span class="number">4</span>):</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> (E * Matrix(Zmod(n), <span class="number">4</span>, <span class="number">4</span>, [randint(<span class="number">0</span>,<span class="number">3</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">16</span>)]) * E^(-<span class="number">1</span>)).<span class="built_in">list</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">F1</span>():</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line">        T = random_matrix(Zmod(n), <span class="number">4</span>, <span class="number">4</span>)</span><br><span class="line">        <span class="keyword">if</span>(T.rank() == <span class="number">4</span>):</span><br><span class="line">            <span class="keyword">return</span> T.<span class="built_in">list</span>()</span><br><span class="line"></span><br><span class="line">n = <span class="number">65537</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;output =&quot;</span>, [F0() <span class="keyword">if</span> i == <span class="string">&quot;0&quot;</span> <span class="keyword">else</span> F1() <span class="keyword">for</span> i <span class="keyword">in</span> flag_bin])</span><br></pre></td></tr></table></figure>
<p>题目是一个按flag比特的decision：</p>
<ul>
<li><p>若当前bit为0，则输出：</p>
<script type="math/tex; mode=display">
C_0 = EAE^{-1} \quad(mod\;65537)</script><p>其中E为模65537下的随机满秩矩阵，A为由0-3的小值组成的矩阵。</p>
</li>
<li><p>若当前bit为1，则输出：</p>
<script type="math/tex; mode=display">
C_1 = T \quad(mod\;65537)</script><p>T为模65537下的随机满秩矩阵。</p>
</li>
</ul>
<h4 id="det"><a href="#det" class="headerlink" title="det"></a>det</h4><p>解题思路也很简单，若当前bit为1，那么C1的行列式也可以看作是模65537下的随机值。而如果当前bit为0，则有：</p>
<script type="math/tex; mode=display">
|C_0| = |EAE^{-1}| = |A| \quad(mod\;65537)</script><p>由于A由一些小值组成，所以其行列式在整数意义下较小，因此应该与65537的差值很小。通过此依据就可以对flag的每一bit做出decision。</p>
<h4 id="trace"><a href="#trace" class="headerlink" title="trace"></a>trace</h4><p>实际上，更进一步可以看出第一步的C和A是相似矩阵，所以其迹应该相等，因此计算C的迹，应该落在0-12以内，就可以做出decision。</p>
<h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>对于Decision类题目，有两个统一的优化在于：</p>
<ul>
<li>不用计算flag前后缀”catctf{}”对应的所有bit</li>
<li>不用计算每个字节的MSB，因为可见字符MSB一定是0</li>
</ul>
<p>这类优化对本题目效果不明显，但在单次bit判断耗时相对长时（如Decision3），能有效节省时间。</p>
<h4 id="完整exp"><a href="#完整exp" class="headerlink" title="完整exp"></a>完整exp</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">output = </span><br><span class="line">output = output[<span class="number">7</span>*<span class="number">8</span>:-<span class="number">8</span>]</span><br><span class="line">n = <span class="number">65537</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#################################################### det</span></span><br><span class="line">flag = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> bit <span class="keyword">in</span> trange(<span class="built_in">len</span>(output)):</span><br><span class="line">    <span class="keyword">if</span>(bit % <span class="number">8</span> == <span class="number">0</span>):</span><br><span class="line">        flag += <span class="string">&quot;0&quot;</span></span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">    M = Matrix(Zmod(n), <span class="number">4</span>, <span class="number">4</span>, output[bit])</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">min</span>(n-M.det(), M.det()) &lt; <span class="number">200</span>):</span><br><span class="line">        flag += <span class="string">&quot;0&quot;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        flag += <span class="string">&quot;1&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(bit % <span class="number">8</span> == <span class="number">7</span>):</span><br><span class="line">        <span class="built_in">print</span>(long_to_bytes(<span class="built_in">int</span>(flag,<span class="number">2</span>)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#################################################### trace</span></span><br><span class="line">flag = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> bit <span class="keyword">in</span> trange(<span class="built_in">len</span>(output)):</span><br><span class="line">    <span class="keyword">if</span>(bit % <span class="number">8</span> == <span class="number">0</span>):</span><br><span class="line">        flag += <span class="string">&quot;0&quot;</span></span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">    M = Matrix(Zmod(n), <span class="number">4</span>, <span class="number">4</span>, output[bit])</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">int</span>(M.trace()) &lt;= <span class="number">12</span>):</span><br><span class="line">        flag += <span class="string">&quot;0&quot;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        flag += <span class="string">&quot;1&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(bit % <span class="number">8</span> == <span class="number">7</span>):</span><br><span class="line">        <span class="built_in">print</span>(long_to_bytes(<span class="built_in">int</span>(flag,<span class="number">2</span>)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#catctf&#123;P@y_4tt3nT1on_70_Det&#125;</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p><br></p>
<h3 id="C0pper-4-Solves-157-300-pts"><a href="#C0pper-4-Solves-157-300-pts" class="headerlink" title="C0pper(4 Solves, 157/300 pts)"></a>C0pper(4 Solves, 157/300 pts)</h3><p>题目描述：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">What&#x27;s the meaning of copper?</span><br></pre></td></tr></table></figure>
<p>题目：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> os <span class="keyword">import</span> urandom</span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pad</span>(<span class="params">msg, length</span>):</span><br><span class="line">    <span class="keyword">return</span> msg + urandom(length - <span class="built_in">len</span>(msg))</span><br><span class="line"></span><br><span class="line">m1 = bytes_to_long(pad(flag[:<span class="built_in">len</span>(flag)//<span class="number">2</span>],<span class="number">128</span>))</span><br><span class="line">m2 = bytes_to_long(pad(flag[<span class="built_in">len</span>(flag)//<span class="number">2</span>:],<span class="number">128</span>))</span><br><span class="line">p,q = getPrime(<span class="number">512</span>),getPrime(<span class="number">512</span>)</span><br><span class="line">n = p*q</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;n =&quot;</span>,n)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;c1 =&quot;</span>,<span class="built_in">pow</span>(m1,<span class="number">3</span>,n))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;c2 =&quot;</span>,(<span class="built_in">pow</span>(m1,<span class="number">7</span>,n) + getPrime(<span class="number">128</span>)))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;c3 =&quot;</span>, <span class="built_in">pow</span>(m2,<span class="number">333</span>,n))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;c4 =&quot;</span>, <span class="built_in">pow</span>(m2,<span class="number">667</span>,n) + getPrime(<span class="number">128</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;c5 =&quot;</span>, <span class="built_in">pow</span>(m2,<span class="number">997</span>,n) + getPrime(<span class="number">128</span>))</span><br></pre></td></tr></table></figure>
<p>题目把flag分成前后两段，并随机padding后转为整数值m1、m2，之后生成RSA的私钥p、q及其乘积公钥n，然后给出五个密文(以下运算均在模n下进行)：</p>
<script type="math/tex; mode=display">
c_1 = m_1^3</script><script type="math/tex; mode=display">
c_2 = m_1^7 + e_1</script><script type="math/tex; mode=display">
c_3 = m_2^{333}</script><script type="math/tex; mode=display">
c_4 = m_2^{667} + e_2</script><script type="math/tex; mode=display">
c_5 = m_2^{997} + e_3</script><p>并给出n，要求还原m1、m2。其中e1、e2、e3都是128bit的素数，e是error的意思，也就是误差。</p>
<h4 id="无误差情况下的求解思路"><a href="#无误差情况下的求解思路" class="headerlink" title="无误差情况下的求解思路"></a>无误差情况下的求解思路</h4><p>给我们制造麻烦的主要在于未知的e1、e2、e3，我们可以先想一想如果没有这几个误差我们能怎样恢复flag。比如对于c1、c2来说，我们就有两个在模n下以m1为根的多项式：</p>
<script type="math/tex; mode=display">
f(x) = x^3 - c_1</script><script type="math/tex; mode=display">
g(x) = x^7 - c_1</script><p>虽然n的分解未知的话，模下方程是难解的，但是既然有两个以m1为公共根的多项式，我们就可以求两个多项式的gcd，就会有一个公因式为：</p>
<script type="math/tex; mode=display">
(x - m_1)</script><p>就可以还原出m1，m2也同理可以还原。</p>
<h4 id="有误差情况下的求解思路——coppersmith方法"><a href="#有误差情况下的求解思路——coppersmith方法" class="headerlink" title="有误差情况下的求解思路——coppersmith方法"></a>有误差情况下的求解思路——coppersmith方法</h4><p>而e1、e2、e3这些误差使得我们无法建立出这样的多项式组，但是我们可以注意到三个误差都仅有128bit，在模n下是比较小的，而正如题目名字一样，coppersmith提出了一种方法，这种方法可以求解分解未知的n下，多项式的小根。因此我们现在的任务变成了构建出以这些error为小根的多项式。</p>
<blockquote>
<p>coppersmith方法的详细原理涉及格密码学，需要一定基础，有兴趣的可以自行搜索资料了解</p>
</blockquote>
<p>入门的时候把这种方法当作黑盒调用即可，一般步骤为：</p>
<ul>
<li><p>由已知数据，在模n下建立出以小量为根的多项式</p>
</li>
<li><p>调用coppersmith方法求解小根，单元小根多项式的求解在sagemath中有内置函数，为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">small_roots(X,beta,epsilon)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>参数意义可以查阅sage文档了解</p>
</blockquote>
<p>而如果是多元小根多项式，也有一些通用构造，常用的几个可以在以下网址找到：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/defund/coppersmith">defund/coppersmith: Coppersmith’s method for multivariate polynomials (github.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/kionactf/coppersmith">kionactf/coppersmith: Coppersmith method (solving polynomial equation over composite modulus on small bounds) (github.com)</a></p>
<p>其中第二个对于一般构造来说求解效果更好，但是环境配置会比较麻烦。实际上第一个更为通用，并且对于绝大部分题目的小根上界来说都已经足够。</p>
</li>
<li><p>将小根代入原方程中，求解剩余未知量</p>
</li>
</ul>
<h4 id="求解m1"><a href="#求解m1" class="headerlink" title="求解m1"></a>求解m1</h4><p>那么对于m1，我们有：</p>
<script type="math/tex; mode=display">
c_1 = m_1^3</script><script type="math/tex; mode=display">
c_2 - e_1 = m_1^7</script><p>所以我们有：</p>
<script type="math/tex; mode=display">
c_1^7 = (c_2 - e_1)^3</script><p>由此，按上面的步骤，我们可以建立出一个以e1为小根的多项式：</p>
<script type="math/tex; mode=display">
f(x) = (c_2 - x)^3 - c_1^7</script><p>调用small_roots方法，就可以求出e1了。</p>
<p>得到e1之后，两个式子未知量就只剩下了m1，我们就又得到了两个以m1为公共根的多项式，因此求解多项式gcd即可得到m1。</p>
<h4 id="求解m2"><a href="#求解m2" class="headerlink" title="求解m2"></a>求解m2</h4><p>对于m2我们有三个式子：</p>
<script type="math/tex; mode=display">
c_3 = m_2^{333}</script><script type="math/tex; mode=display">
c_4 = m_2^{667} + e_2</script><script type="math/tex; mode=display">
c_5 = m_2^{997} + e_3</script><p>按照求解m1的思路，似乎可以如法炮制出以e2为根的多项式：</p>
<script type="math/tex; mode=display">
f(x) = (c_4 - x)^{333} - c_3^{667}</script><p>但是实际操作下会发现求解不出来e2了，这是什么原因呢？</p>
<p>看一下m1和m2两部分，最显著的区别在于两部分的指数差异很大，m1指数较小，其对应多项式的度就小，仅为3；而m2指数较大，如果照同样的方法构造多项式的话，其指数为333，就大很多了。</p>
<p>而coppersmith方法求解小根的能力与多项式的度有强相关性，指数越小越利于coppersmith的求解，而333这种数量级已经远远超过了其求解能力，因此用同样的构造求解不了了。</p>
<blockquote>
<p>多项式的度对于coppersmith小根上界为什么会有影响、究竟有什么影响，有兴趣的也可以自行翻阅资料</p>
</blockquote>
<p>所以我们需要想别的构造，而突破点在于m2与m1的另一个区别——m2给了三组数据，所以我们要把三组结合起来一起用。而观察一下又可以发现，三组数据的指数是有很直接的关系的：</p>
<script type="math/tex; mode=display">
667 = 2 \cdot 333 + 1</script><script type="math/tex; mode=display">
997 = 3 \cdot 333 - 2</script><p>因此我们不妨做一个简单的换元处理：</p>
<script type="math/tex; mode=display">
a = m_2^{333}</script><p>那么就有：</p>
<script type="math/tex; mode=display">
c_3 = a</script><script type="math/tex; mode=display">
c_4 = a^2m_2 + e_2</script><script type="math/tex; mode=display">
c_5 = a^3m_2^{-2} + e_3</script><p>而我们知道两个式子结合起来可以消掉一个未知量，而当前三个式子有：</p>
<script type="math/tex; mode=display">
a,m_2,e_2,e_3</script><p>共计四个未知量，那么用三个式子两两消元，就可以消去a、m2这两个未知量，从而得到一个含e2、e3且度较低的多项式。</p>
<blockquote>
<p>此处使用的方法为结式(resultant)消元法，有兴趣的可以自行查阅相关资料</p>
</blockquote>
<p>而这样的多项式就可以调刚才提过的多元coppersmith来求解e1、e2了，求出e1、e2之后仍然使用多项式gcd就可以得到m2。</p>
<h4 id="完整exp-1"><a href="#完整exp-1" class="headerlink" title="完整exp"></a>完整exp</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">small_roots</span>(<span class="params">f, bounds, m=<span class="number">1</span>, d=<span class="literal">None</span></span>):</span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> d:</span><br><span class="line">		d = f.degree()</span><br><span class="line"></span><br><span class="line">	R = f.base_ring()</span><br><span class="line">	N = R.cardinality()</span><br><span class="line">	</span><br><span class="line">	f /= f.coefficients().pop(<span class="number">0</span>)</span><br><span class="line">	f = f.change_ring(ZZ)</span><br><span class="line"></span><br><span class="line">	G = <span class="type">Sequence</span>([], f.parent())</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m+<span class="number">1</span>):</span><br><span class="line">		base = N^(m-i) * f^i</span><br><span class="line">		<span class="keyword">for</span> shifts <span class="keyword">in</span> itertools.product(<span class="built_in">range</span>(d), repeat=f.nvariables()):</span><br><span class="line">			g = base * prod(<span class="built_in">map</span>(power, f.variables(), shifts))</span><br><span class="line">			G.append(g)</span><br><span class="line"></span><br><span class="line">	B, monomials = G.coefficients_monomials()</span><br><span class="line">	monomials = vector(monomials)</span><br><span class="line"></span><br><span class="line">	factors = [monomial(*bounds) <span class="keyword">for</span> monomial <span class="keyword">in</span> monomials]</span><br><span class="line">	<span class="keyword">for</span> i, factor <span class="keyword">in</span> <span class="built_in">enumerate</span>(factors):</span><br><span class="line">		B.rescale_col(i, factor)</span><br><span class="line"></span><br><span class="line">	B = B.dense_matrix().LLL()</span><br><span class="line"></span><br><span class="line">	B = B.change_ring(QQ)</span><br><span class="line">	<span class="keyword">for</span> i, factor <span class="keyword">in</span> <span class="built_in">enumerate</span>(factors):</span><br><span class="line">		B.rescale_col(i, <span class="number">1</span>/factor)</span><br><span class="line"></span><br><span class="line">	H = <span class="type">Sequence</span>([], f.parent().change_ring(QQ))</span><br><span class="line">	<span class="keyword">for</span> h <span class="keyword">in</span> <span class="built_in">filter</span>(<span class="literal">None</span>, B*monomials):</span><br><span class="line">		H.append(h)</span><br><span class="line">		I = H.ideal()</span><br><span class="line">		<span class="keyword">if</span> I.dimension() == -<span class="number">1</span>:</span><br><span class="line">			H.pop()</span><br><span class="line">		<span class="keyword">elif</span> I.dimension() == <span class="number">0</span>:</span><br><span class="line">			roots = []</span><br><span class="line">			<span class="keyword">for</span> root <span class="keyword">in</span> I.variety(ring=ZZ):</span><br><span class="line">				root = <span class="built_in">tuple</span>(R(root[var]) <span class="keyword">for</span> var <span class="keyword">in</span> f.variables())</span><br><span class="line">				roots.append(root)</span><br><span class="line">			<span class="keyword">return</span> roots</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">########################################################### data</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">########################################################### part1 univariate coppersmith</span></span><br><span class="line">PR.&lt;x&gt; = PolynomialRing(Zmod(n))</span><br><span class="line">f = (c2 - x)^<span class="number">3</span> - c1^<span class="number">7</span></span><br><span class="line">f = f.monic()</span><br><span class="line">res = f.small_roots(X=<span class="number">2</span>^<span class="number">128</span>,beta=<span class="number">1</span>,epsilon=<span class="number">0.05</span>)</span><br><span class="line">a = <span class="built_in">int</span>(res[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gcd</span>(<span class="params">g1, g2</span>):</span><br><span class="line">    <span class="keyword">while</span> g2:</span><br><span class="line">        g1, g2 = g2, g1 % g2</span><br><span class="line">    <span class="keyword">return</span> g1.monic()</span><br><span class="line"></span><br><span class="line">PR.&lt;x&gt; = PolynomialRing(Zmod(n))</span><br><span class="line">f1 = x^<span class="number">3</span> - c1</span><br><span class="line">f2 = x^<span class="number">7</span> + a - c2</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(<span class="built_in">int</span>(-gcd(f1,f2)[<span class="number">0</span>])))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">########################################################### part2 bivariate coppersmith</span></span><br><span class="line">PR.&lt;t,m,a,b&gt; = PolynomialRing(Zmod(n))</span><br><span class="line">f1 = t - c3</span><br><span class="line">f2 = t^<span class="number">2</span>*m + a - c4</span><br><span class="line">f3 = t^<span class="number">3</span> + b*m^<span class="number">2</span> - c5*m^<span class="number">2</span></span><br><span class="line"></span><br><span class="line">g1 = f1.sylvester_matrix(f2,t).det()</span><br><span class="line">g2 = f1.sylvester_matrix(f3,t).det()</span><br><span class="line">h = g1.sylvester_matrix(g2,m).det()</span><br><span class="line"><span class="built_in">print</span>(h)</span><br><span class="line">PR.&lt;a,b&gt; = PolynomialRing(Zmod(n))</span><br><span class="line">F = </span><br><span class="line">res = small_roots(F, (<span class="number">2</span>^<span class="number">128</span>,<span class="number">2</span>^<span class="number">128</span>), m=<span class="number">4</span>,d=<span class="number">4</span>)</span><br><span class="line">a, b = <span class="built_in">int</span>(res[<span class="number">0</span>][<span class="number">0</span>]), <span class="built_in">int</span>(res[<span class="number">0</span>][<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gcd</span>(<span class="params">g1, g2</span>):</span><br><span class="line">    <span class="keyword">while</span> g2:</span><br><span class="line">        g1, g2 = g2, g1 % g2</span><br><span class="line">    <span class="keyword">return</span> g1.monic()</span><br><span class="line"></span><br><span class="line">PR.&lt;x&gt; = PolynomialRing(Zmod(n))</span><br><span class="line">f1 = x^<span class="number">333</span> - c3</span><br><span class="line">f2 = x^<span class="number">667</span> + a - c4</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(<span class="built_in">int</span>(-gcd(f1,f2)[<span class="number">0</span>])))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#catctf&#123;Un1vaRiate_c0pp3rSm1th_@nd_Biv4r1aTe_C0Pp3rSm1th_4ND_Fin@lLy_P0lyn0m1Als_GCD!&#125;</span></span><br></pre></td></tr></table></figure>
<p>还有一个比较简单的思路是找如下方程的小正整数解：</p>
<script type="math/tex; mode=display">
333x = 667y + 997z</script><p>简单遍历一下小整数会得到一组解：</p>
<script type="math/tex; mode=display">
(x,y,z) = (7,2,1)</script><p>所以就有多项式：</p>
<script type="math/tex; mode=display">
f(x,y) = (c_4 - x)^2(c_5 - y) - c_3^7</script><p>多元copper即可。</p>
<p><br></p>
<p><br></p>
<h3 id="Hash-game-16-Solves-76-300-pts"><a href="#Hash-game-16-Solves-76-300-pts" class="headerlink" title="Hash game(16 Solves, 76/300 pts)"></a>Hash game(16 Solves, 76/300 pts)</h3><p>题目描述：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Play a hash game with bear!</span><br></pre></td></tr></table></figure>
<p>题目：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">SHUFFLE</span>(<span class="params">t</span>):</span><br><span class="line">    temp = <span class="built_in">list</span>(t)</span><br><span class="line">    shuffle(temp)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(temp)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;c =&quot;</span>, [SHUFFLE(choice([md5, sha1, sha384, sha256, sha512])(flag[:i]).hexdigest() + <span class="string">&quot;&quot;</span>.join([choice(<span class="string">&quot;0123456789abcdef&quot;</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">36</span>)])) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(flag)+<span class="number">1</span>)])</span><br></pre></td></tr></table></figure>
<p>题目基于哈希，总共给出flag长度那么多次密文，第i次的加密步骤为：</p>
<ul>
<li><p>从md5, sha1, sha384, sha256, sha512中随机选择一个当作本次的哈希函数，记为hashi</p>
</li>
<li><p>将flag的前i个字符组成的串作为本次哈希对象，记为mi</p>
</li>
<li><p>随机选择36个十六进制字符当作扰动，记为ei</p>
</li>
<li><p>给出本次密文ci：</p>
<script type="math/tex; mode=display">
c_i = shuffle(hash_i(m_i) + e_i)</script><p>其中加号为字符串连接，shuffle的作用是随机打乱字符串顺序</p>
</li>
</ul>
<p>首先，对于每一个密文，我们要先判断出究竟其用的是哪一种哈希算法，而判断依据在于哈希值长度的不同。对于题目的五种算法来说，他们的哈希值长度分别为：</p>
<ul>
<li>md5：128bit</li>
<li>sha1：160bit</li>
<li>sha256：256bit</li>
<li>sha384：384bit</li>
<li>sha512：512bit</li>
</ul>
<p>而每个密文都会多出36个随机十六进制字符，因此十六进制长度减去36之后，就可以通过比特长度判断究竟是哪一种哈希算法了。</p>
<p>之后就是想办法还原flag，由于每一次哈希的对象是flag的前i个字符，因此第一次哈希对象就是flag的第一个字符，此时爆破空间很小，就是可见字符对应的ASCII码，也就是32-128内。</p>
<blockquote>
<p>不过既然知道flag头”catctf{“，可以从第八个字符开始上述过程</p>
</blockquote>
<p>此时我们可以用本次密文对应的哈希算法对这个小范围内所有字符逐个求哈希，但是由于每次密文做了如下处理：</p>
<ul>
<li>有36个随机十六进制字符扰动</li>
<li>打乱了顺序</li>
</ul>
<p>所以我们没办法直接通过对比哈希值是否相等，来判断当前究竟是哪个字符正确。然而，由于shuffle只会打乱顺序，不会改变哈希值每种十六进制字符的个数，因此对于正确的被哈希串来说，其一定会满足：</p>
<ul>
<li>哈希值的所有十六进制字符数量均小于等于对应密文十六进制字符数量</li>
</ul>
<p>由此我们就可以找到一些符合条件的字符串，在这些字符串的基础上，我们继续向后搜索，用DFS的思路逐步减小范围，最后就可以得到正确的flag串了。</p>
<p>exp：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">c = </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check_chr</span>(<span class="params">a, t1, t2</span>):</span><br><span class="line">    <span class="keyword">return</span> t1.count(a) &lt;= t2.count(a)   </span><br><span class="line"></span><br><span class="line">noise_num = <span class="number">36</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check_str</span>(<span class="params">msg, t</span>):</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">len</span>(t) == <span class="number">32</span> + noise_num):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">all</span>(check_chr(a, md5(msg.encode()).hexdigest(), t) <span class="keyword">for</span> a <span class="keyword">in</span> <span class="string">&quot;0123456789abcdef&quot;</span>)</span><br><span class="line">    <span class="keyword">elif</span>(<span class="built_in">len</span>(t) == <span class="number">40</span> + noise_num):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">all</span>(check_chr(a, sha1(msg.encode()).hexdigest(), t) <span class="keyword">for</span> a <span class="keyword">in</span> <span class="string">&quot;0123456789abcdef&quot;</span>)</span><br><span class="line">    <span class="keyword">elif</span>(<span class="built_in">len</span>(t) == <span class="number">64</span> + noise_num):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">all</span>(check_chr(a, sha256(msg.encode()).hexdigest(), t) <span class="keyword">for</span> a <span class="keyword">in</span> <span class="string">&quot;0123456789abcdef&quot;</span>)</span><br><span class="line">    <span class="keyword">elif</span>(<span class="built_in">len</span>(t) == <span class="number">96</span> + noise_num):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">all</span>(check_chr(a, sha384(msg.encode()).hexdigest(), t) <span class="keyword">for</span> a <span class="keyword">in</span> <span class="string">&quot;0123456789abcdef&quot;</span>)</span><br><span class="line">    <span class="keyword">elif</span>(<span class="built_in">len</span>(t) == <span class="number">128</span> + noise_num):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">all</span>(check_chr(a, sha512(msg.encode()).hexdigest(), t) <span class="keyword">for</span> a <span class="keyword">in</span> <span class="string">&quot;0123456789abcdef&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">flag</span>):</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">not</span> check_str(flag, c[<span class="built_in">len</span>(flag)-<span class="number">1</span>])):</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">len</span>(flag) == <span class="built_in">len</span>(c)):</span><br><span class="line">        <span class="built_in">print</span>(flag)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>,<span class="number">127</span>):</span><br><span class="line">        find(flag + <span class="built_in">chr</span>(i))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">find(<span class="string">&quot;c&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#catctf&#123;Just_p1@Y_A_S1mP1E_H@SH_g4Me_W17H_DFS_I_gu3ss!&#125;</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p><br></p>
<h3 id="Random-game-3-Solves-376-500-pts"><a href="#Random-game-3-Solves-376-500-pts" class="headerlink" title="Random game(3 Solves, 376/500 pts)"></a>Random game(3 Solves, 376/500 pts)</h3><p>题目描述：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Play a random game with bear!</span><br></pre></td></tr></table></figure>
<p>题目：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">gift = <span class="string">b&quot;&quot;</span>.join(long_to_bytes((<span class="built_in">pow</span>(getrandbits(<span class="number">4</span>), <span class="number">2</span>*i, <span class="number">17</span>) &amp; <span class="number">0xf</span>) ^ getrandbits(<span class="number">8</span>), <span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4567</span>))</span><br><span class="line">m = <span class="built_in">list</span>(flag)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2024</span>):</span><br><span class="line">    shuffle(m)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;gift =&quot;</span>, bytes_to_long(gift))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;c = &#x27;&quot;</span> +  <span class="string">&quot;&quot;</span>.join(<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">chr</span>,m))) + <span class="string">&quot;&#x27;&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>题目明显的分为了两个部分，一部分是getrandbits，一部分是shuffle。比较显然的解题步骤应该是：</p>
<ul>
<li>用gift实现伪随机数预测，从而确定shuffle如何进行</li>
<li>逆向shuffle还原flag</li>
</ul>
<p>本题wp也就分这两个部分展开。</p>
<h4 id="getrandbits部分"><a href="#getrandbits部分" class="headerlink" title="getrandbits部分"></a>getrandbits部分</h4><h5 id="MT19937的重要性质以及破解原理"><a href="#MT19937的重要性质以及破解原理" class="headerlink" title="MT19937的重要性质以及破解原理"></a>MT19937的重要性质以及破解原理</h5><p>python的random库中，几乎所有的函数都依赖于MT19937伪随机数生成，其具体原理及其他攻击方式可以参考：</p>
<p><a target="_blank" rel="noopener" href="https://xenny.wiki/posts/crypto/PRNG/MT19937.html">MT19937 分析 | Xenny 的博客</a></p>
<p><a target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/205861">浅析MT19937伪随机数生成算法-安全客 - 安全资讯平台 (anquanke.com)</a></p>
<p>我们这里不详细展开讲MT19937的详细算法内容，只需要了解该算法的几个性质，以及getrandbits实现的几个细节：</p>
<ul>
<li><p>MT19937生成随机数前，会初始化一个state，state由624个32bit的数字组成，<strong>有了这个state，就可以往后任意预测随机数，不仅仅是getrandbits，random库里的几乎所有函数都可以预测其行为</strong></p>
</li>
<li><p>往后所有getrandbits产生的数字，都是<strong>关于这个初始state模2下线性的</strong>，这是破解MT19937的核心。用数学化一点的表述就是：</p>
<ul>
<li><p>把初始state二进制展开成一个长19968(624x32)的向量，记为$\textbf{s}$，该向量由0、1组成</p>
</li>
<li><p>把getrandbits产生的任意位置的一个比特记为b</p>
</li>
<li><p>那么一定存在一个向量$\textbf{t}$，使得：</p>
<script type="math/tex; mode=display">
\textbf{t}\cdot \textbf{s} = b</script><p>这就是线性关系的含义。</p>
</li>
</ul>
</li>
<li><p>getrandbits是按照32bit为单位产生的，举几个例子就是：</p>
<ul>
<li>如果getrandbit(0)，会直接返回0，不会调用随机数生成</li>
<li>如果getrandbit(32k)，那么会连续产生k个32bit的数并拼接起来</li>
<li>如果getrandbits(t)，0&lt;t&lt;32，那么会先产生一个32bit的数字，然后截取其高t位作为本次随机数</li>
</ul>
</li>
</ul>
<p>以上就是做题需要了解的核心部分。</p>
<p>所以我们如果能拿到初始的state，就可以预测getrandbits的输出，乃至预测shuffle的行为。也就是说我们的目标是要求解那个长19968的01向量s，而求解依据就是刚才的线性关系式：</p>
<script type="math/tex; mode=display">
\textbf{s}\cdot \textbf{t} = b</script><p>其中b是getrandbits产生的某个位置的比特，如果我们能搜集到19968个这样的等式，那么我们就可以把他们拼接起来，构建出一个矩阵方程：</p>
<script type="math/tex; mode=display">
\textbf{s}_{1,19968}T_{19968,19968} = \textbf{b}_{1,19968}</script><p>如果T是满秩的，那么我们求解这个矩阵方程就可以得到s的唯一解，再把向量转回624个32bit的数字，也就得到了初始状态state。即使T不是满秩的，在模2下也可以简单遍历一下矩阵方程的解空间，其中就存在正确的s，所以依然可以获得state。</p>
<p>而为了解这个矩阵方程，我们需要有矩阵T和向量b，下面就开始针对题目讲解T和b的获取方式。</p>
<h5 id="获取b"><a href="#获取b" class="headerlink" title="获取b"></a>获取b</h5><p>正如刚才所说，b是getrandbits的输出比特组成的向量，这些比特位置可以任意分布，但是我们需要知道他的位置来确定其线性关系。</p>
<p>而我们能获得的getrandbits的输出结果都在gift中，他是：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gift = <span class="string">b&quot;&quot;</span>.join(long_to_bytes((<span class="built_in">pow</span>(getrandbits(<span class="number">4</span>), <span class="number">2</span>*i, <span class="number">17</span>) &amp; <span class="number">0xf</span>) ^ getrandbits(<span class="number">8</span>), <span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4567</span>))</span><br></pre></td></tr></table></figure>
<p>首先最直接可以获得的一些输出在于getrandbits(8)，我们可以发现每一轮给出的输出其实是getrandbits(8)异或一个4bit的数字，因此密文的高四位就是本次getrandbits(8)的高四位，如此一来我们就可以获得：</p>
<script type="math/tex; mode=display">
4567 \cdot 4 = 18268</script><p>这么多个输出比特。</p>
<p>这并不够，正如上一节所讲的，我们需要19968个比特才行，还差一千多个。而我们可以发现与getrandbits(8)异或的部分是：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="built_in">pow</span>(getrandbits(<span class="number">4</span>), <span class="number">2</span>*i, <span class="number">17</span>) &amp; <span class="number">0xf</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4567</span>)</span><br></pre></td></tr></table></figure>
<p>17是个素数，由费马小定理我们可以知道：</p>
<script type="math/tex; mode=display">
a^{16} = 1 \quad(mod\;17) \quad ,\quad a \in \{1,2,...,16\}</script><p>实际上，由二次剩余的欧拉准则我们能进一步知道：</p>
<script type="math/tex; mode=display">
a^{8} = 1 \quad(mod\;17) \quad ,\quad a \in QR_{17}</script><script type="math/tex; mode=display">
a^{8} = -1 = 16 \quad(mod\;17) \quad ,\quad a \in NR_{17}</script><p>此时前者结果是1，后者结果是0。而如果a=0，那么结果是0。也就是说，当i为4的整数倍时，本次的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="built_in">pow</span>(getrandbits(<span class="number">4</span>), <span class="number">2</span>*i, <span class="number">17</span>) &amp; <span class="number">0xf</span>)</span><br></pre></td></tr></table></figure>
<p>这个计算结果只能是0或1，这也代表着本次getrandbits(8)的高七位就是密文的高七位，所以我们总共能获得的比特数是：</p>
<script type="math/tex; mode=display">
4567 \cdot 4 + \lfloor \frac{4567}{4} \rfloor \cdot 3 = 21691</script><p>这远远超过了19968，因此我们就获得了足够的输出比特，只需要选择其中19968个来解线性方程即可。把他们组合起来就得到了向量b：</p>
<script type="math/tex; mode=display">
\textbf{b}_{1,19968}</script><blockquote>
<p>事实上把已知的全取上为好，这样可以让约束更多，从而压缩s的解空间</p>
</blockquote>
<h5 id="获取T"><a href="#获取T" class="headerlink" title="获取T"></a>获取T</h5><p>我们回顾一下我们需要解的矩阵方程：</p>
<script type="math/tex; mode=display">
\textbf{s} \cdot T = \textbf{b}</script><p>我们现在已经获取了b，只要能获取T，就可以解这个矩阵方程得到s了。</p>
<p>而T虽然我们暂时不知道，但是有一点可以确定：它是<strong>由MT19937本身算法得到的确定的线性关系</strong>，也就是说，我们如果拥有所有b的对应比特在MT19937产生的随机数流中的位置，那么其对应的T矩阵也是固定的。</p>
<p>我们的任务就是找到这个固定的T，而找的方式类似于黑盒调用。具体来说，如果我们取最开始的s为：</p>
<script type="math/tex; mode=display">
(1,0,0,...,0)</script><p>那么我们按照这个s设置初始state，然后调用getrandbits去生成我们已知位置对应的比特，得到b’，此时得到的b’其实就是T的第一行。同理，我们接下来继续令s为：</p>
<script type="math/tex; mode=display">
(0,1,0,...,0)</script><p>用这个s设置state，得到的b‘就是T的第二行。如法炮制我们就可以得到T的全部行。</p>
<p>有了T、b之后我们就可以解出初始state，有初始state之后我们可以将random的state设置为初始state，然后运行一遍gift，就来到了题目中shuffle前同样的状态。</p>
<h4 id="shuffle部分"><a href="#shuffle部分" class="headerlink" title="shuffle部分"></a>shuffle部分</h4><p>简单阅读一下random库的shuffle，源码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">shuffle</span>(<span class="params">self, x, random=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Shuffle list x in place, and return None.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Optional argument random is a 0-argument function returning a</span></span><br><span class="line"><span class="string">    random float in [0.0, 1.0); if it is the default None, the</span></span><br><span class="line"><span class="string">    standard random.random will be used.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> random <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        randbelow = self._randbelow</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">reversed</span>(<span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(x))):</span><br><span class="line">            <span class="comment"># pick an element in x[:i+1] with which to exchange x[i]</span></span><br><span class="line">            j = randbelow(i + <span class="number">1</span>)</span><br><span class="line">            x[i], x[j] = x[j], x[i]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        _warn(<span class="string">&#x27;The *random* parameter to shuffle() has been deprecated\n&#x27;</span></span><br><span class="line">                <span class="string">&#x27;since Python 3.9 and will be removed in a subsequent &#x27;</span></span><br><span class="line">                <span class="string">&#x27;version.&#x27;</span>,</span><br><span class="line">                DeprecationWarning, <span class="number">2</span>)</span><br><span class="line">        floor = _floor</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">reversed</span>(<span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(x))):</span><br><span class="line">            <span class="comment"># pick an element in x[:i+1] with which to exchange x[i]</span></span><br><span class="line">            j = floor(random() * (i + <span class="number">1</span>))</span><br><span class="line">            x[i], x[j] = x[j], x[i]</span><br></pre></td></tr></table></figure>
<p>可以看出，shuffle的实现原理是调用random库的randbelow函数来多次交换列表内的元素顺序，而我们现在拥有同样的初始状态，所以可以生成一个同样长度的列表，列表中的元素是索引。之后我们将这个列表shuffle2024次，就能看出flag对应的列表中的每个元素在经历2024次shuffle之后，究竟被交换到了什么样的位置，然后按对应索引将flag重新排序即可。</p>
<h4 id="完整exp-2"><a href="#完整exp-2" class="headerlink" title="完整exp"></a>完整exp</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">gift = </span><br><span class="line">c = <span class="string">&#x27;fUDs_|hUafdiE_eS)ecfna_rh|tu_ps(_1c&#125;_efs___nfdHyilsseUfgt_Fho3is&#123;3Lo_n_n1_u_uH||fFm_X&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">######################################################### part1 recover MT and get seed</span></span><br><span class="line">gift = long_to_bytes(gift)</span><br><span class="line">RNG = Random()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">construct_a_row</span>(<span class="params">RNG</span>):</span><br><span class="line">    row = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(gift)):</span><br><span class="line">        RNG.getrandbits(<span class="number">4</span>)</span><br><span class="line">        <span class="keyword">if</span>(i % <span class="number">4</span> == <span class="number">0</span>):</span><br><span class="line">            row += <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, (<span class="built_in">bin</span>(RNG.getrandbits(<span class="number">8</span>) &gt;&gt; <span class="number">1</span>)[<span class="number">2</span>:].zfill(<span class="number">7</span>))))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            row += <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, (<span class="built_in">bin</span>(RNG.getrandbits(<span class="number">8</span>) &gt;&gt; <span class="number">4</span>)[<span class="number">2</span>:].zfill(<span class="number">4</span>))))</span><br><span class="line">    <span class="keyword">return</span> row</span><br><span class="line"></span><br><span class="line">L = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> trange(<span class="number">19968</span>):</span><br><span class="line">    state = [<span class="number">0</span>]*<span class="number">624</span></span><br><span class="line">    temp = <span class="string">&quot;0&quot;</span>*i + <span class="string">&quot;1&quot;</span>*<span class="number">1</span> + <span class="string">&quot;0&quot;</span>*(<span class="number">19968</span>-<span class="number">1</span>-i)</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">624</span>):</span><br><span class="line">        state[j] = <span class="built_in">int</span>(temp[<span class="number">32</span>*j:<span class="number">32</span>*j+<span class="number">32</span>],<span class="number">2</span>)</span><br><span class="line">    RNG.setstate((<span class="number">3</span>,<span class="built_in">tuple</span>(state+[<span class="number">624</span>]),<span class="literal">None</span>))</span><br><span class="line">    L.append(construct_a_row(RNG))</span><br><span class="line"></span><br><span class="line">L = Matrix(GF(<span class="number">2</span>),L)</span><br><span class="line">R = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(gift)):</span><br><span class="line">    <span class="keyword">if</span>(i % <span class="number">4</span> == <span class="number">0</span>):</span><br><span class="line">        R += <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, (<span class="built_in">bin</span>(gift[i] &gt;&gt; <span class="number">1</span>)[<span class="number">2</span>:].zfill(<span class="number">7</span>))))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        R += <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, (<span class="built_in">bin</span>(gift[i] &gt;&gt; <span class="number">4</span>)[<span class="number">2</span>:].zfill(<span class="number">4</span>))))</span><br><span class="line"></span><br><span class="line">R = vector(GF(<span class="number">2</span>),R)</span><br><span class="line"></span><br><span class="line">s = L.solve_left(R)</span><br><span class="line">init = <span class="string">&quot;&quot;</span>.join(<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">str</span>,s)))</span><br><span class="line">state = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">624</span>):</span><br><span class="line">    state.append(<span class="built_in">int</span>(init[<span class="number">32</span>*i:<span class="number">32</span>*i+<span class="number">32</span>],<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">RNG1 = Random()</span><br><span class="line">RNG1.setstate((<span class="number">3</span>,<span class="built_in">tuple</span>(state+[<span class="number">624</span>]),<span class="literal">None</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">######################################################### part2 set seed and recover shuffle</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4567</span>):</span><br><span class="line">    RNG1.getrandbits(<span class="number">4</span>)</span><br><span class="line">    RNG1.getrandbits(<span class="number">8</span>)</span><br><span class="line">x = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(c))]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2024</span>):</span><br><span class="line">    RNG1.shuffle(x)</span><br><span class="line"></span><br><span class="line">flag = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(c)):</span><br><span class="line">    flag += c[x.index(i)]</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#catctf&#123;_Shuf|fl3_s|hUFf1e_UnsHUff|L3_unsH|ufF1E_&#125;</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p><br></p>
<h2 id="Week2"><a href="#Week2" class="headerlink" title="Week2"></a>Week2</h2><p>Week2为四道逐比特的Decision，方向稍微新一点，但是基本是考察这些新型方向的概念。</p>
<p><br></p>
<h3 id="Decision1-4-solves-241-400-pts"><a href="#Decision1-4-solves-241-400-pts" class="headerlink" title="Decision1(4 solves, 241/400 pts)"></a>Decision1(4 solves, 241/400 pts)</h3><p>题目描述：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Make your decision!</span><br></pre></td></tr></table></figure>
<p>题目：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag</span><br><span class="line"></span><br><span class="line">flag_bin = <span class="built_in">bin</span>(bytes_to_long(flag))[<span class="number">2</span>:].zfill(<span class="built_in">len</span>(flag)*<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">F0</span>():</span><br><span class="line">    f = <span class="keyword">lambda</span> x: <span class="built_in">sum</span>((poly[i])*<span class="built_in">pow</span>(x,i,n) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(poly))) % n</span><br><span class="line">    poly = [randint(<span class="number">0</span>,n) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>)]</span><br><span class="line">    <span class="keyword">return</span> [f(j) + getrandbits(<span class="number">1</span>) <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">40</span>)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">F1</span>():</span><br><span class="line">    <span class="keyword">return</span> [randint(<span class="number">1</span>,n) <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">40</span>)]</span><br><span class="line"></span><br><span class="line">n = <span class="number">65537</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;output =&quot;</span>, [F0() <span class="keyword">if</span> i == <span class="string">&quot;0&quot;</span> <span class="keyword">else</span> F1() <span class="keyword">for</span> i <span class="keyword">in</span> flag_bin])</span><br></pre></td></tr></table></figure>
<p>本题背景为格密码，其decision为：</p>
<ul>
<li><p>如果flag当前bit是1，则生成一个长度为40的模n下随机数组成的列表</p>
</li>
<li><p>如果flag当前bit是0，则：</p>
<ul>
<li><p>生成一个长度为20的模n下随机数列表poly，poly代表着一个模n下的多项式f：</p>
<script type="math/tex; mode=display">
f(x) = poly_0 + poly_1x^1 + poly_2x^2 + ... + poly_{19}x^{19}</script></li>
<li><p>用多项式f，生成一个长度为40的列表，列表中的元素为：</p>
<script type="math/tex; mode=display">
c_i = f(i) + e_i \quad , \quad i \in [0,39]</script></li>
</ul>
<p>其中ei取值为getrandbits(1)，也就是0或1。</p>
</li>
</ul>
<p>我们需要判断出output中的每个列表究竟是用哪种方式生成的，从而决定当前bit是0还是1。</p>
<h4 id="无误差情况下的求解——拉格朗日插值"><a href="#无误差情况下的求解——拉格朗日插值" class="headerlink" title="无误差情况下的求解——拉格朗日插值"></a>无误差情况下的求解——拉格朗日插值</h4><p>由于当前bit为1的样本是随机值组成的列表，因此我们的思路显然是通过某种方法，来判断当前bit的样本是不是F0产生的样本。而注意到F0产生的列表中的每个元素，其实是多项式f上带误差的点值，也就是带误差的因变量y，而我们同时又知道每个y对应的自变量x就是0-39，所以其实我们拥有的是带误差的多项式点对，如下：</p>
<script type="math/tex; mode=display">
(0,f(0)+e_0)</script><script type="math/tex; mode=display">
(1,f(1)+e_1)</script><script type="math/tex; mode=display">
...</script><script type="math/tex; mode=display">
(39,f(39)+e_{39})</script><p>而有多组多项式点对，恢复多项式的其中一个办法就是拉格朗日插值法。具体来说，如果没有误差，那么我们可以建立如下矩阵方程：</p>
<script type="math/tex; mode=display">
\left(\begin{matrix}
0&0^1&\cdots&0^{19}\\
1^0&1^1&\cdots&1^{19}\\
\vdots&\vdots&\ddots&\vdots\\
39^0&39^1&\cdots&39^{19}\\
\end{matrix}\right)_{40,20}
\left(\begin{matrix}
poly_0\\
poly_1\\
\vdots\\
poly_{19}\\
\end{matrix}\right)_{20,1}
=
\left(\begin{matrix}
f(0)\\
f(1)\\
\vdots\\
f(39)\\
\end{matrix}\right)_{40,1}</script><p>我们的未知数只有poly对应的向量，并且左边的方程数有40个，变量仅有20个。那么我们根据ci构建出这个矩阵方程，如果有解就说明存在这样的poly，当前bit就一定是0了。而由于方程是超定的，所以对于当前bit为1产生的随机列表来说，其几乎不可能有解，因此就可以做出判断。</p>
<h4 id="有误差情况下的求解——LWE样本判定"><a href="#有误差情况下的求解——LWE样本判定" class="headerlink" title="有误差情况下的求解——LWE样本判定"></a>有误差情况下的求解——LWE样本判定</h4><p>然而这样做的障碍在于本题的点值有1bit的随机误差ei，那么矩阵方程会变成：</p>
<script type="math/tex; mode=display">
\left(\begin{matrix}
0&0^1&\cdots&0^{19}\\
1^0&1^1&\cdots&1^{19}\\
\vdots&\vdots&\ddots&\vdots\\
39^0&39^1&\cdots&39^{19}\\
\end{matrix}\right)_{40,20}
\left(\begin{matrix}
poly_0\\
poly_1\\
\vdots\\
poly_{19}\\
\end{matrix}\right)_{20,1}
+
\left(\begin{matrix}
e_0\\
e_1\\
\vdots\\
e_{39}\\
\end{matrix}\right)_{40,1}
=
\left(\begin{matrix}
c_0\\
c_1\\
\vdots\\
c_{39}\\
\end{matrix}\right)_{40,1}</script><p>此时由于误差e向量的存在，我们解不了矩阵方程了，就需要考虑其他办法。此时如果我们把矩阵方程抽象出来就是：</p>
<script type="math/tex; mode=display">
Ax + e = b</script><p>其中我们知道的信息有：</p>
<ul>
<li>A、b的全部值</li>
<li>e是0、1组成的向量，在模n下是相当小的量</li>
</ul>
<p>这其实就是一个典型的LWE样本，有关LWE的详细介绍我之前有写过：</p>
<p><a href="https://tangcuxiaojikuai.xyz/post/758dd33a.html">LWE | 糖醋小鸡块的blog (tangcuxiaojikuai.xyz)</a></p>
<p>而判断一个样本是不是LWE样本，需要用到格密码的相关知识，而这一部分最常用到的有一个LLL函数。</p>
<h5 id="LLL"><a href="#LLL" class="headerlink" title="LLL"></a>LLL</h5><p>和coppersmith一样，LLL的原理在这里不展开，入门时主要先掌握把它当作一个工具调用即可。他能做到的功能是：</p>
<ul>
<li><p>输入一组线性基向量</p>
</li>
<li><p>输出这些基向量经线性组合后，得到的一些更短的基向量</p>
<blockquote>
<p>这里“更短”的含义可以理解为向量的长度更小，一定程度上也代表着向量中每个值都相对小</p>
</blockquote>
</li>
</ul>
<p>所以要用到LLL的题目的一般思路是：</p>
<ul>
<li>构造出题目对应的矩阵方程</li>
<li>找到方程中由小的未知量构成的向量，这就是需要的短向量</li>
<li>从矩阵方程中提取出经线性组合后，能够获得需要的短向量的基</li>
<li>对这组基向量调用LLL，得到需要的短向量</li>
</ul>
<p>我们接下来就照着这个步骤来完成一次解题。</p>
<h5 id="利用LLL解决LWE样本判定"><a href="#利用LLL解决LWE样本判定" class="headerlink" title="利用LLL解决LWE样本判定"></a>利用LLL解决LWE样本判定</h5><p>按照步骤，我们第一步需要构造出矩阵方程，这其实也就是带误差的拉格朗日插值方程：</p>
<script type="math/tex; mode=display">
\left(\begin{matrix}
0&0^1&\cdots&0^{19}\\
1^0&1^1&\cdots&1^{19}\\
\vdots&\vdots&\ddots&\vdots\\
39^0&39^1&\cdots&39^{19}\\
\end{matrix}\right)_{40,20}
\left(\begin{matrix}
poly_0\\
poly_1\\
\vdots\\
poly_{19}\\
\end{matrix}\right)_{20,1}
+
\left(\begin{matrix}
e_0\\
e_1\\
\vdots\\
e_{39}\\
\end{matrix}\right)_{40,1}
=
\left(\begin{matrix}
c_0\\
c_1\\
\vdots\\
c_{39}\\
\end{matrix}\right)_{40,1}</script><p>接下来我们需要找到小的未知量构成的向量，很显然就是0、1组成的向量e。</p>
<p>第三步尤为关键，我们需要提取出一组经线性组合后能获得短向量的格基，这一步看上去并不容易。而实际上，线性组合的方式就蕴藏在第一步的矩阵方程中，我们不妨将矩阵方程进行转置：</p>
<script type="math/tex; mode=display">
(poly_0,poly_1,...,poly_{19})
\left(\begin{matrix}
0&0^1&\cdots&0^{19}\\
1^0&1^1&\cdots&1^{19}\\
\vdots&\vdots&\ddots&\vdots\\
39^0&39^1&\cdots&39^{19}\\
\end{matrix}\right)^T
+
(e_0,e_1,...,e_{39})
=
(c_0,c_1,...,c_{19})</script><p>可以发现，其实poly列表的左乘，就是对该矩阵行向量进行线性组合，而整个运算是模n下的，所以我们可以构造出如下的一矩阵，其行向量就是我们要找的一组线性基：</p>
<script type="math/tex; mode=display">
L = 
\left(\begin{matrix}
1&&&&&0^0&1^0&\cdots&39^0\\
&1&&&&0^1&1^1&\cdots&39^1\\
&&\ddots&&&\vdots&\vdots&\ddots&\vdots\\
&&&1&&0^{19}&1^{19}&\cdots&39^{19}\\
&&&&1&-c_0&-c_1&\cdots&-c_{19}\\
&&&&&n&&&\\
&&&&&&n&&\\
&&&&&&&\ddots&\\
&&&&&&&&n\\
\end{matrix}\right)</script><p>而对这个矩阵做如下的线性组合的话，就可以得到短向量：</p>
<script type="math/tex; mode=display">
(poly_0,poly_1,...,poly_{19},1,k_0,k_1,...,k_{19})
L
=
(poly_0,poly_1,...,poly_{19},1,e_0,e_1,...,e_{19})</script><p>由于e较小，所以这样得到的目标向量就较短，因此我们对将矩阵L作为LLL的输入进行调用，就可以在LLL的输出向量中找到我们需要的这个向量了。</p>
<blockquote>
<p>事实上格基规约还需要进行一步操作叫配平（有时是为了规约出0而配大系数）。之所以要进行这个步骤，主要是因为LLL算法输出的基，会更倾向于向量中每个值数量级都相近的短向量</p>
<p>有更好的一种方式可以只规约出e，具体可以参考上面那篇LWE文章的primal attack2</p>
</blockquote>
<p>而如果当前bit是1，其密文是随机值组成的列表，当然就很难有这么凑巧的线性组合，可以使得LLL之后输出这样的短向量，因此就可以通过LLL的输出结果对当前bit做出判断了。</p>
<h4 id="完整exp-3"><a href="#完整exp-3" class="headerlink" title="完整exp"></a>完整exp</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#primal_attack2</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">primal_attack2</span>(<span class="params">A,b,m,n,p,esz</span>):</span><br><span class="line">    L = block_matrix(</span><br><span class="line">        [</span><br><span class="line">            [matrix(Zmod(p), A).T.echelon_form().change_ring(ZZ), <span class="number">0</span>],</span><br><span class="line">            [matrix.zero(m - n, n).augment(matrix.identity(m - n) * p), <span class="number">0</span>],</span><br><span class="line">            [matrix(ZZ, b), <span class="number">1</span>],</span><br><span class="line">        ]</span><br><span class="line">    )</span><br><span class="line">    <span class="comment">#print(L.dimensions())</span></span><br><span class="line">    Q = diagonal_matrix([<span class="number">1</span>]*m + [esz])</span><br><span class="line">    L *= Q</span><br><span class="line">    L = L.LLL()</span><br><span class="line">    L /= Q</span><br><span class="line">    res = L[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">all</span>(i <span class="keyword">in</span> [<span class="number">0</span>,<span class="number">1</span>,-<span class="number">1</span>] <span class="keyword">for</span> i <span class="keyword">in</span> res) <span class="keyword">and</span> <span class="built_in">abs</span>(res[-<span class="number">1</span>]) == <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">output = </span><br><span class="line">output = output[<span class="number">7</span>*<span class="number">8</span>:-<span class="number">8</span>]</span><br><span class="line">n = <span class="number">65537</span></span><br><span class="line">nums = <span class="number">40</span></span><br><span class="line"></span><br><span class="line">flag = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> bit <span class="keyword">in</span> trange(<span class="built_in">len</span>(output)):</span><br><span class="line">    <span class="keyword">if</span>(bit % <span class="number">8</span> == <span class="number">0</span>):</span><br><span class="line">        flag += <span class="string">&quot;0&quot;</span></span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">    A = Matrix(Zmod(n), <span class="number">0</span>, <span class="number">20</span>)</span><br><span class="line">    b = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(nums):</span><br><span class="line">        A = A.stack(vector(Zmod(n), [<span class="built_in">pow</span>(i,j,n) <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>)]))</span><br><span class="line">        b.append(output[bit][i])</span><br><span class="line">    A = Matrix(ZZ, A)</span><br><span class="line">    b = vector(ZZ, b)</span><br><span class="line">    check = primal_attack2(A,b,nums,<span class="number">20</span>,n,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(check == <span class="literal">True</span>):</span><br><span class="line">        flag += <span class="string">&quot;0&quot;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        flag += <span class="string">&quot;1&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(bit % <span class="number">8</span> == <span class="number">7</span>):</span><br><span class="line">        <span class="built_in">print</span>(long_to_bytes(<span class="built_in">int</span>(flag,<span class="number">2</span>)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#catctf&#123;l4gRanG3_@nD_LWE_s@mple!&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="非预期解"><a href="#非预期解" class="headerlink" title="非预期解"></a>非预期解</h4><p>事实上，由于多项式的度仅为19，因此在没有误差影响的情况下，利用拉格朗日插值方程，我们只需要20组数据就可以恢复多项式系数：</p>
<script type="math/tex; mode=display">
\left(\begin{matrix}
0&0^1&\cdots&0^{19}\\
1^0&1^1&\cdots&1^{19}\\
\vdots&\vdots&\ddots&\vdots\\
19^0&19^1&\cdots&19^{19}\\
\end{matrix}\right)
\left(\begin{matrix}
poly_0\\
poly_1\\
\vdots\\
poly_{19}\\
\end{matrix}\right)
=
\left(\begin{matrix}
c_0\\
c_1\\
\vdots\\
c_{19}\\
\end{matrix}\right)</script><p>然而实际上题目是有误差的，但是我们可以爆破这20比特的误差，从而恢复多项式系数：</p>
<script type="math/tex; mode=display">
\left(\begin{matrix}
0&0^1&\cdots&0^{19}\\
1^0&1^1&\cdots&1^{19}\\
\vdots&\vdots&\ddots&\vdots\\
19^0&19^1&\cdots&19^{19}\\
\end{matrix}\right)
\left(\begin{matrix}
poly_0\\
poly_1\\
\vdots\\
poly_{19}\\
\end{matrix}\right)
=
\left(\begin{matrix}
c_0\\
c_1\\
\vdots\\
c_{19}\\
\end{matrix}\right)
-
\left(\begin{matrix}
e_0\\
e_1\\
\vdots\\
e_{19}\\
\end{matrix}\right)</script><p>然后拿这多项式去计算后续值的函数值，检查误差是否仅有1比特即可。</p>
<p>exp：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">output = </span><br><span class="line">output = output[<span class="number">7</span>*<span class="number">8</span>:-<span class="number">8</span>]</span><br><span class="line">n = <span class="number">65537</span></span><br><span class="line">nums = <span class="number">20</span></span><br><span class="line"></span><br><span class="line">flag = <span class="string">&quot;&quot;</span></span><br><span class="line">f = <span class="keyword">lambda</span> x: <span class="built_in">sum</span>((poly[i])*<span class="built_in">pow</span>(x,i,n) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(poly))) % n</span><br><span class="line"><span class="keyword">for</span> bit <span class="keyword">in</span> trange(<span class="built_in">len</span>(output)):</span><br><span class="line">    <span class="keyword">if</span>(bit % <span class="number">8</span> == <span class="number">0</span>):</span><br><span class="line">        flag += <span class="string">&quot;0&quot;</span></span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">        </span><br><span class="line">    A = Matrix(Zmod(n), <span class="number">0</span>, <span class="number">20</span>)</span><br><span class="line">    b = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(nums):</span><br><span class="line">        A = A.stack(vector(Zmod(n), [<span class="built_in">pow</span>(i,j,n) <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>)]))</span><br><span class="line">        b.append(output[bit][i])</span><br><span class="line">    A = Matrix(Zmod(n), A)</span><br><span class="line">    b = vector(Zmod(n), b)</span><br><span class="line">    invA = A^(-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    Found = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> e <span class="keyword">in</span> product([<span class="number">0</span>,<span class="number">1</span>],repeat=nums):</span><br><span class="line">        e = vector(Zmod(n),e)</span><br><span class="line">        poly = (invA*(b-e)).<span class="built_in">list</span>()</span><br><span class="line"></span><br><span class="line">        <span class="comment">#check</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(<span class="built_in">int</span>(f(<span class="number">20</span>))-<span class="built_in">int</span>(output[bit][<span class="number">20</span>])) &lt;= <span class="number">1</span> <span class="keyword">and</span> <span class="built_in">abs</span>(<span class="built_in">int</span>(f(<span class="number">21</span>))-<span class="built_in">int</span>(output[bit][<span class="number">21</span>])) &lt;= <span class="number">1</span>):</span><br><span class="line">            Found = <span class="number">1</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(Found == <span class="number">1</span>):</span><br><span class="line">        flag += <span class="string">&quot;0&quot;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        flag += <span class="string">&quot;1&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(bit % <span class="number">8</span> == <span class="number">7</span>):</span><br><span class="line">        <span class="built_in">print</span>(long_to_bytes(<span class="built_in">int</span>(flag,<span class="number">2</span>)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#catctf&#123;l4gRanG3_@nD_LWE_s@mple!&#125;</span></span><br></pre></td></tr></table></figure>
<p>Decision1_revenge就是提高了维数的非预期修复版本，所以不单独写exp了。</p>
<p><br></p>
<p><br></p>
<h3 id="Decision2-3-solves-281-400-pts"><a href="#Decision2-3-solves-281-400-pts" class="headerlink" title="Decision2(3 solves, 281/400 pts)"></a>Decision2(3 solves, 281/400 pts)</h3><p>题目描述：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Make your decision again!</span><br></pre></td></tr></table></figure>
<p>题目：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag</span><br><span class="line"></span><br><span class="line">flag_bin = <span class="built_in">bin</span>(bytes_to_long(flag))[<span class="number">2</span>:].zfill(<span class="built_in">len</span>(flag)*<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">p = <span class="number">0x3cb868653d300b3fe80015554dd25db0fc01dcde95d4000000631bbd421715013955555555529c005c75d6c2ab00000000000ac79600d2abaaaaaaaaaaaaaa93eaf3ff000aaaaaaaaaaaaaaabeab000b</span></span><br><span class="line">E = EllipticCurve(GF(p), (<span class="number">0</span>, <span class="number">4</span>))</span><br><span class="line">n = E.order()</span><br><span class="line">primes = [<span class="number">67</span>, <span class="number">5563</span>, <span class="number">2099837</span>, <span class="number">773517157085353949</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">F0</span>():</span><br><span class="line">    r1 = choice(primes)</span><br><span class="line">    r2 = choice(primes)</span><br><span class="line">    <span class="keyword">return</span> ((n // r1^<span class="number">2</span>)*E.random_element()).weil_pairing((n // r1^<span class="number">2</span>)*E.random_element(),r1) * ((n // r2^<span class="number">2</span>)*E.random_element()).weil_pairing((n // r2^<span class="number">2</span>)*E.random_element(),r2) % p</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">F1</span>():</span><br><span class="line">    <span class="keyword">return</span> GF(p).random_element()^((p-<span class="number">1</span>) // prod(primes))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;output =&quot;</span>, [F0() <span class="keyword">if</span> i == <span class="string">&quot;0&quot;</span> <span class="keyword">else</span> F1() <span class="keyword">for</span> i <span class="keyword">in</span> flag_bin])</span><br></pre></td></tr></table></figure>
<p>本题背景为曲线配对，使用曲线为BLS12-638，其decision为：(以下运算均在模p下进行)</p>
<ul>
<li><p>如果flag当前bit是1，则返回的ci满足：</p>
<script type="math/tex; mode=display">
c_i = a^{\frac{p-1}{\prod{primes}}}</script><p>其中a是模p下的随机数</p>
</li>
<li><p>如果flag当前bit是0，则返回的ci满足：</p>
<script type="math/tex; mode=display">
c_i = e(P_1,P_2) \cdot e(Q_1,Q_2)</script><p>其中，P1、P2为题目给定曲线上的两个不同r1阶点，Q1、Q2为题目给定曲线上的两个不同r2阶点，r1、r2为从primes随机选择的两个值，e为weil pairing函数</p>
</li>
</ul>
<p>为了解决这个题目，首先需要简单了解一下双线性配对函数的一些性质。</p>
<h4 id="椭圆曲线上的双线性配对函数性质"><a href="#椭圆曲线上的双线性配对函数性质" class="headerlink" title="椭圆曲线上的双线性配对函数性质"></a>椭圆曲线上的双线性配对函数性质</h4><p>简单来说，双线性配对可以理解成一个函数，其输入为椭圆曲线上的两个点，输出为椭圆曲线所在的域上的一个值。如果把这个函数记为e，那么这个概念可以写为：</p>
<script type="math/tex; mode=display">
e : E_F \times E_F \rightarrow F</script><script type="math/tex; mode=display">
P \in E_F,Q \in E_F</script><script type="math/tex; mode=display">
e(P,Q) = a ,a\in F</script><p>其中F是椭圆曲线所在域。</p>
<p>双线性配对函数的一些重要性质如下：</p>
<ul>
<li><p>$e(aP,bQ) = e(P,Q)^{ab}$</p>
</li>
<li><p>$e(P,P) = 1$</p>
</li>
<li><p>对r-torsion中的点的配对，配对到的值均为曲线所在域的r次单位根</p>
<blockquote>
<p>此外还需要介绍一下torsion的概念，曲线上的r-torsion结构定义为所有满足$rP = O$的P点形成的集合，其中O点为曲线的单位元</p>
</blockquote>
</li>
</ul>
<p>而题目所用的weil pairing函数正是满足上述性质的一个双线性配对函数。</p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>flag当前bit为1的输出值能利用的点似乎并不多，因此我们还是主要关注flag当前bit为0的情况。由于P1、P2为曲线上的r1-torsion中的点，因此由上述性质可以知道，$e(P_1,P_2)$的结果是模p乘法群中的r1次单位根，也就是：</p>
<script type="math/tex; mode=display">
e^{r_1}(P_1,P_2) = 1</script><p>同理，对于r2-torsion中的Q1、Q2来说，就会有：</p>
<script type="math/tex; mode=display">
e^{r_2}(Q_1,Q_2) = 1</script><p>那么对于当前bit为0的输出来说，一定会有：</p>
<script type="math/tex; mode=display">
c_i^{r_1r_2} = (e(P_1,P_2) \cdot e(Q_1,Q_2))^{r_1r_2} = e^{r_1r_2}(P_1,P_2) \cdot  e^{r_1r_2}(Q_1,Q_2)) = 1</script><p>虽然我们并不知道r1、r2具体是primes中的哪两个值，但是我们可以遍历primes中所有两个因子的组合，那么对于当前bit为0的输出ci来说，一定存在一对r1、r2会满足上述等式。</p>
<blockquote>
<p>r1、r2可能相同，但是如此遍历依然可以满足上述等式，因为两个r1次单位根的乘积依然是r1次单位根</p>
</blockquote>
<p>而对于当前bit为1的输出，我们知道他是：</p>
<script type="math/tex; mode=display">
c_i = a^{\frac{p-1}{\prod{primes}}}</script><p>那么他经过上述遍历，得到的结果是：</p>
<script type="math/tex; mode=display">
c_i^{r_1r_2} = a^{\frac{p-1}{\prod{primes}}\cdot r_1r_2} = a^{\frac{p-1}{r_3r_4}}</script><p>r3、r4就是每次遍历中，primes剩下来的两个值，可以看出当且仅当a的阶为${\frac{p-1}{r_3r_4}}$的因子时上式才等于1，而这概率很小，因此就可以逐比特做出正确decision，进而还原flag。</p>
<h4 id="完整exp-4"><a href="#完整exp-4" class="headerlink" title="完整exp"></a>完整exp</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">output = </span><br><span class="line">output = output[<span class="number">7</span>*<span class="number">8</span>:-<span class="number">8</span>]</span><br><span class="line">p = <span class="number">0x3cb868653d300b3fe80015554dd25db0fc01dcde95d4000000631bbd421715013955555555529c005c75d6c2ab00000000000ac79600d2abaaaaaaaaaaaaaa93eaf3ff000aaaaaaaaaaaaaaabeab000b</span></span><br><span class="line">primes = [<span class="number">67</span>, <span class="number">5563</span>, <span class="number">2099837</span>, <span class="number">773517157085353949</span>]</span><br><span class="line"></span><br><span class="line">flag = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> bit <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(output)):</span><br><span class="line">    <span class="keyword">if</span>(bit % <span class="number">8</span> == <span class="number">0</span>):</span><br><span class="line">        flag += <span class="string">&quot;0&quot;</span></span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">    Found = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> combinations(primes, r=<span class="number">2</span>):</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">pow</span>(output[bit], prod(i), p) == <span class="number">1</span>):</span><br><span class="line">            Found = <span class="number">1</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(Found == <span class="number">1</span>):</span><br><span class="line">        flag += <span class="string">&quot;0&quot;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        flag += <span class="string">&quot;1&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(bit % <span class="number">8</span> == <span class="number">7</span>):</span><br><span class="line">        <span class="built_in">print</span>(long_to_bytes(<span class="built_in">int</span>(flag,<span class="number">2</span>)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#catctf&#123;M4p_70_Sp3c1al_Gr0uP&#125;</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p><br></p>
<h3 id="Decision3-3-solves-281-400-pts"><a href="#Decision3-3-solves-281-400-pts" class="headerlink" title="Decision3(3 solves, 281/400 pts)"></a>Decision3(3 solves, 281/400 pts)</h3><p>题目描述：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Make your decision aagain!</span><br></pre></td></tr></table></figure>
<p>题目：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag</span><br><span class="line"></span><br><span class="line">flag_bin = <span class="built_in">bin</span>(bytes_to_long(flag))[<span class="number">2</span>:].zfill(<span class="built_in">len</span>(flag)*<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">p = <span class="number">26734989077687468135677691953151</span></span><br><span class="line">F.&lt;i&gt; = GF(p^<span class="number">2</span>, modulus = x^<span class="number">2</span> + <span class="number">1</span>)</span><br><span class="line">E = EllipticCurve(j=F(<span class="number">1728</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">iter</span>():</span><br><span class="line">    <span class="keyword">global</span> E</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        P = E(<span class="number">0</span>).division_points(randint(<span class="number">2</span>,<span class="number">3</span>))[<span class="number">1</span>:]</span><br><span class="line">        shuffle(P)</span><br><span class="line">        phi = E.isogeny(P[<span class="number">0</span>])</span><br><span class="line">        E = phi.codomain()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">F0</span>():</span><br><span class="line">    <span class="built_in">iter</span>()</span><br><span class="line">    phi = E.isogeny(E(<span class="number">0</span>).division_points(<span class="number">2</span>)[<span class="number">1</span>])</span><br><span class="line">    E1 = phi.codomain()</span><br><span class="line">    <span class="keyword">return</span> (E.montgomery_model().a2() + getrandbits(<span class="number">13</span>), E1.montgomery_model().a2() + randint(<span class="number">0</span>,p))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">F1</span>():</span><br><span class="line">    <span class="built_in">iter</span>()</span><br><span class="line">    phi = E.isogeny(E(<span class="number">0</span>).division_points(<span class="number">3</span>)[<span class="number">1</span>])</span><br><span class="line">    E1 = phi.codomain()</span><br><span class="line">    <span class="keyword">return</span> (E.montgomery_model().a2() + getrandbits(<span class="number">13</span>), E1.montgomery_model().a2() + randint(<span class="number">0</span>,p))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;output =&quot;</span>, [F0() <span class="keyword">if</span> i == <span class="string">&quot;0&quot;</span> <span class="keyword">else</span> F1() <span class="keyword">for</span> i <span class="keyword">in</span> flag_bin])</span><br></pre></td></tr></table></figure>
<p>本题背景为曲线同源，先在一个给定的素数p下，生成一个二次扩域$GF(p^2)$下的超奇异椭圆曲线E，然后基于这个E开始进行后续步骤。</p>
<blockquote>
<p>有关isogeny的知识我也写过一篇文章记录，有兴趣的同学可以看这篇帮助入门：</p>
<p><a href="https://tangcuxiaojikuai.xyz/post/e06139e7.html">Isogeny | 糖醋小鸡块的blog (tangcuxiaojikuai.xyz)</a></p>
<p>当然，本题依然需要直接介绍其中一些概念，下方部分内容直接摘自上面这篇文章</p>
</blockquote>
<p>本题的decision为：</p>
<ul>
<li><p>不论当前bit为1还是0，都会先基于刚才的曲线先进行十次2-isogeny或者3-isogeny，从而同源到一条新曲线上，这一步是为了通过起始曲线直接确定当前曲线</p>
</li>
<li><p>如果flag当前bit是1，则进行一次3-isogeny，并且给出同源前后两条曲线Montgomery形式的a2，但是同源前的a2会有13bit误差，同源后的a2会有模p下的随机误差</p>
</li>
<li>如果flag当前bit是0，则进行一次2-isogeny，并且给出同源前后两条曲线Montgomery形式的a2，但是同源前的a2会有13bit误差，同源后的a2会有模p下的随机误差</li>
</ul>
<p>可以看出，我们主要是要判断出每一bit对应的同源究竟是2-isogeny还是3-isogeny，而其实不是2-isogeny就是3-isogeny，所以我们可以选择仅判断是否是2-isogeny，更为简单。</p>
<h4 id="一些基本概念"><a href="#一些基本概念" class="headerlink" title="一些基本概念"></a>一些基本概念</h4><h5 id="超奇异椭圆曲线"><a href="#超奇异椭圆曲线" class="headerlink" title="超奇异椭圆曲线"></a>超奇异椭圆曲线</h5><p>若曲线E定义在有限域$F_{p^r} (r \in Z^*)$下，若E的阶order满足：</p>
<script type="math/tex; mode=display">
order = 1 \quad(mod\;p)</script><p>则E是一条超奇异椭圆曲线。</p>
<h5 id="扩域"><a href="#扩域" class="headerlink" title="扩域"></a>扩域</h5><p>扩张的概念其实很简单。扩张也称作扩域，对于两个域来说，如果K是F的子域，F就是K的扩域或扩张。那么这里不妨选一个素数p，其为一个模4余3的大素数，则对于有限域$F_p$来说，他的二次扩张就是$F_{p^2}$。</p>
<p>而本题的同源就是在有限域$F_{p^2}$下工作的，这个有限域的大小是p^2，也就是说其中有p^2个元素。而这样一个有限域的元素有个最方便的表示方法，就是写成复数形式：</p>
<script type="math/tex; mode=display">
u + vi \quad (u,v \in F_p)</script><p>这样表示显然满足域的定义，因为首先它含有单位元1和零元0，并且满足：</p>
<ul>
<li>$(F_{p^2},+)$是阿贝尔群</li>
<li>$(F_{p^2}-\{0\},\times)$是阿贝尔群</li>
<li>乘法对加法满足分配律</li>
</ul>
<h5 id="曲线的Montgomery形式"><a href="#曲线的Montgomery形式" class="headerlink" title="曲线的Montgomery形式"></a>曲线的Montgomery形式</h5><p>对于蒙哥马利形的椭圆曲线来说，其曲线方程可以写成：</p>
<script type="math/tex; mode=display">
E: \quad \quad y^2 = x^3 + ax^2 + x</script><p>题目代码中的a2就是这个方程中的a，这是因为一条长Weierstrass形椭圆曲线的标准方程其实是：</p>
<script type="math/tex; mode=display">
y^2 + a_1xy + a_3y = x^3 + a_2x^2 + a_4x + a_6</script><p>而一般看到的是短Weierstrass形椭圆曲线，也就是：</p>
<script type="math/tex; mode=display">
y^2 = x^3 + ax + b</script><p>这是因为在域特征不为2或3时，所有长Weierstrass形曲线都可以转化成短Weierstrass形曲线。</p>
<h5 id="j不变量"><a href="#j不变量" class="headerlink" title="j不变量"></a>j不变量</h5><p>对于椭圆曲线来说，j不变量可以简单理解为一个判定两条椭圆曲线是否同构的值。也就是说，任何一个曲线都有自己独特的j不变量，而如果两条曲线的j不变量相等，则说明这两条曲线彼此同构。而由于同构的曲线本质上都可以看作同一条曲线，这也就说明，一个j不变量其实在同构意义上其实就唯一对应着一条曲线。</p>
<h5 id="曲线的Montgomery形式下，a与j不变量的关系"><a href="#曲线的Montgomery形式下，a与j不变量的关系" class="headerlink" title="曲线的Montgomery形式下，a与j不变量的关系"></a>曲线的Montgomery形式下，a与j不变量的关系</h5><p>曲线在Montgomery形式下，a与他的j不变量满足如下方程：</p>
<script type="math/tex; mode=display">
j(E) = \frac{256(a^2-3)^3}{a^2-4}</script><h5 id="modular-polynomial"><a href="#modular-polynomial" class="headerlink" title="modular polynomial"></a>modular polynomial</h5><p>有一个比较有用的东西叫做modular polynomial，他的独特作用在于，能够用一个多项式关联d-isogeny中互为邻居的两个j不变量。也就是说，如果知道了一个j不变量，那么可以将其代入对应度的modular polynomial去求根，得到的所有根就是所有作为他的邻居的j不变量。其对应的度较低的多项式形式都可以在如下网站找到：</p>
<p><a target="_blank" rel="noopener" href="https://math.mit.edu/~drew/ClassicalModPolys.html">Modular polynomials (mit.edu)</a></p>
<h4 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h4><h5 id="无误差情况下的求解"><a href="#无误差情况下的求解" class="headerlink" title="无误差情况下的求解"></a>无误差情况下的求解</h5><p>我们先假设我们得到的两条曲线的a2是无误差的。</p>
<p>我们从上面的预备知识知道，如果两条曲线是2-isogeny的邻居，那么他们的j不变量就会满足2-modular polynomial，也就是把两个j不变量代入下面的方程中，等式成立：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">f = (</span><br><span class="line">	X^<span class="number">3</span></span><br><span class="line">	+ Y^<span class="number">3</span></span><br><span class="line">	- X^<span class="number">2</span> * Y^<span class="number">2</span></span><br><span class="line">	+ <span class="number">1488</span> * X^<span class="number">2</span> * Y</span><br><span class="line">	+ <span class="number">1488</span> * X * Y^<span class="number">2</span></span><br><span class="line">	- <span class="number">162000</span> * X^<span class="number">2</span></span><br><span class="line">	- <span class="number">162000</span> * Y^<span class="number">2</span></span><br><span class="line">	+ <span class="number">40773375</span> * X * Y</span><br><span class="line">	+ <span class="number">8748000000</span> * X</span><br><span class="line">	+ <span class="number">8748000000</span> * Y</span><br><span class="line">	- <span class="number">157464000000000</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>而我们现在虽然不能直接得到两条曲线的j不变量，但是我们有两条曲线Montgomery形式下的a，因此可以通过下面的等式计算出j不变量来：</p>
<script type="math/tex; mode=display">
j(E) = \frac{256(a^2-3)^3}{a^2-4}</script><p>然后检查方程是否满足上面的2-modular polynomial，就可以判断当前bit是0还是1了。</p>
<h5 id="有误差情况下的求解"><a href="#有误差情况下的求解" class="headerlink" title="有误差情况下的求解"></a>有误差情况下的求解</h5><p>然而，我们得到的曲线Montgomery形式下的a是有误差的，但是这误差有个特点就是：</p>
<ul>
<li>第一个误差仅有13bit，在可以枚举的范围</li>
<li>两个误差都只涉及a的实部，虚部都是准确值</li>
</ul>
<p>由于第一个误差很小，因此我们考虑在2^13范围内枚举第一个误差，那么我们可以看做我们拥有第一条曲线准确的a，也就可以计算出第一条曲线准确的j不变量。</p>
<p>而由于supersingular的同源曲线只能是supersingular的，所以对枚举到的超奇异曲线的j不变量，我们就可以代入到2-modular polynomial方程中，然后求根求出第二条曲线的j不变量，进而求出第二条曲线的a，然后我们只需要对比求出的这个a的虚部是否与给出a的虚部完全相同，就可以判断当前的两条曲线是不是2-isogeny的邻居，从而判断当前bit是0还是1。</p>
<h4 id="完整exp-5"><a href="#完整exp-5" class="headerlink" title="完整exp"></a>完整exp</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = <span class="number">26734989077687468135677691953151</span></span><br><span class="line">F.&lt;i&gt; = GF(p^<span class="number">2</span>, modulus = x^<span class="number">2</span> + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check</span>(<span class="params">j1,a2</span>):</span><br><span class="line">    PR.&lt;Y&gt; = PolynomialRing(F)</span><br><span class="line">    X = j1</span><br><span class="line">    f = (</span><br><span class="line">            X^<span class="number">3</span></span><br><span class="line">            + Y^<span class="number">3</span></span><br><span class="line">            - X^<span class="number">2</span> * Y^<span class="number">2</span></span><br><span class="line">            + <span class="number">1488</span> * X^<span class="number">2</span> * Y</span><br><span class="line">            + <span class="number">1488</span> * X * Y^<span class="number">2</span></span><br><span class="line">            - <span class="number">162000</span> * X^<span class="number">2</span></span><br><span class="line">            - <span class="number">162000</span> * Y^<span class="number">2</span></span><br><span class="line">            + <span class="number">40773375</span> * X * Y</span><br><span class="line">            + <span class="number">8748000000</span> * X</span><br><span class="line">            + <span class="number">8748000000</span> * Y</span><br><span class="line">            - <span class="number">157464000000000</span></span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> f.roots():</span><br><span class="line">        PR1.&lt;a&gt; = PolynomialRing(F)</span><br><span class="line">        g = <span class="number">256</span>*(a^<span class="number">2</span>-<span class="number">3</span>)^<span class="number">3</span> - i[<span class="number">0</span>]*(a^<span class="number">2</span>-<span class="number">4</span>)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> g.roots():</span><br><span class="line">            <span class="keyword">if</span>((j[<span class="number">0</span>] - a2)[<span class="number">1</span>] == <span class="number">0</span>):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">output = </span><br><span class="line">output = output[<span class="number">7</span>*<span class="number">8</span>:-<span class="number">8</span>]</span><br><span class="line">flag = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> bit <span class="keyword">in</span> trange(<span class="built_in">len</span>(output)):</span><br><span class="line">    <span class="keyword">if</span>(bit % <span class="number">8</span> == <span class="number">0</span>):</span><br><span class="line">        flag += <span class="string">&quot;0&quot;</span></span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">    Found = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>^<span class="number">13</span>):</span><br><span class="line">        a = output[bit][<span class="number">0</span>] - i</span><br><span class="line">        J = F(<span class="number">256</span>*(a^<span class="number">2</span>-<span class="number">3</span>)^<span class="number">3</span>) / F(a^<span class="number">2</span>-<span class="number">4</span>)</span><br><span class="line">        <span class="keyword">if</span>(EllipticCurve(F,j=J).is_supersingular(proof=<span class="literal">False</span>)):</span><br><span class="line">            res = check(J, output[bit][<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">if</span>(res == <span class="literal">True</span>):</span><br><span class="line">                Found = <span class="number">1</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(Found == <span class="number">1</span>):</span><br><span class="line">        flag += <span class="string">&quot;0&quot;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        flag += <span class="string">&quot;1&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(bit % <span class="number">8</span> == <span class="number">7</span>):</span><br><span class="line">        <span class="built_in">print</span>(long_to_bytes(<span class="built_in">int</span>(flag,<span class="number">2</span>)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#catctf&#123;D1ffeRenT_M0duL@r_P0lynom1Al!&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="多进程编程"><a href="#多进程编程" class="headerlink" title="多进程编程"></a>多进程编程</h4><p>赛中和做了本题的<a target="_blank" rel="noopener" href="https://www.zhihu.com/people/flatter-old">@TRiv1al</a>交流了一下，我的exp大概需要四五十分钟，他的思路没有多大差别，然而他的exp却要跑十小时左右才行。排除一些实现上的细节问题的话，这个时间差异就只能是算力差异了。</p>
<p>而一个有效减少耗时的方式就是使用multiprocessing进行多进程编程，他的使用方法很简单，因此直接放exp：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = <span class="number">26734989077687468135677691953151</span></span><br><span class="line">F.&lt;i&gt; = GF(p^<span class="number">2</span>, modulus = x^<span class="number">2</span> + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check</span>(<span class="params">j1,a2</span>):</span><br><span class="line">    PR.&lt;Y&gt; = PolynomialRing(F)</span><br><span class="line">    X = j1</span><br><span class="line">    f = (</span><br><span class="line">            X^<span class="number">3</span></span><br><span class="line">            + Y^<span class="number">3</span></span><br><span class="line">            - X^<span class="number">2</span> * Y^<span class="number">2</span></span><br><span class="line">            + <span class="number">1488</span> * X^<span class="number">2</span> * Y</span><br><span class="line">            + <span class="number">1488</span> * X * Y^<span class="number">2</span></span><br><span class="line">            - <span class="number">162000</span> * X^<span class="number">2</span></span><br><span class="line">            - <span class="number">162000</span> * Y^<span class="number">2</span></span><br><span class="line">            + <span class="number">40773375</span> * X * Y</span><br><span class="line">            + <span class="number">8748000000</span> * X</span><br><span class="line">            + <span class="number">8748000000</span> * Y</span><br><span class="line">            - <span class="number">157464000000000</span></span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> f.roots():</span><br><span class="line">        PR1.&lt;a&gt; = PolynomialRing(F)</span><br><span class="line">        g = <span class="number">256</span>*(a^<span class="number">2</span>-<span class="number">3</span>)^<span class="number">3</span> - i[<span class="number">0</span>]*(a^<span class="number">2</span>-<span class="number">4</span>)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> g.roots():</span><br><span class="line">            <span class="keyword">if</span>((j[<span class="number">0</span>] - a2)[<span class="number">1</span>] == <span class="number">0</span>):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">attack</span>(<span class="params">tup</span>):</span><br><span class="line">    bit, i = tup</span><br><span class="line">    a = output[bit][<span class="number">0</span>] - i</span><br><span class="line">    J = F(<span class="number">256</span>*(a^<span class="number">2</span>-<span class="number">3</span>)^<span class="number">3</span>) / F(a^<span class="number">2</span>-<span class="number">4</span>)</span><br><span class="line">    <span class="keyword">if</span>(EllipticCurve(F,j=J).is_supersingular(proof=<span class="literal">False</span>)):</span><br><span class="line">        res = check(J, output[bit][<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">if</span>(res == <span class="literal">True</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">output = </span><br><span class="line">output = output[<span class="number">7</span>*<span class="number">8</span>:-<span class="number">8</span>]</span><br><span class="line">flag = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> bit <span class="keyword">in</span> trange(<span class="built_in">len</span>(output)):</span><br><span class="line">    <span class="keyword">if</span>(bit % <span class="number">8</span> == <span class="number">0</span>):</span><br><span class="line">        flag += <span class="string">&quot;0&quot;</span></span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">    Found = <span class="number">0</span></span><br><span class="line">    <span class="keyword">with</span> Pool(<span class="number">8</span>) <span class="keyword">as</span> pool:</span><br><span class="line">        r = <span class="built_in">list</span>(pool.imap(attack, [(bit,i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>^<span class="number">13</span>)]))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">True</span> <span class="keyword">in</span> r):</span><br><span class="line">        flag += <span class="string">&quot;0&quot;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        flag += <span class="string">&quot;1&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(bit % <span class="number">8</span> == <span class="number">7</span>):</span><br><span class="line">        <span class="built_in">print</span>(long_to_bytes(<span class="built_in">int</span>(flag,<span class="number">2</span>)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#catctf&#123;D1ffeRenT_M0duL@r_P0lynom1Al!&#125;</span></span><br></pre></td></tr></table></figure>
<p>这样子可以将时间缩短至十分钟左右。</p>
<p>注意这里Pool(8)并不代表着直接就可以将耗时缩短到单进程的1/8，因为这依然取决于你的CPU怎么样。但是一般来说使用多进程，对比起单进程肯定是有明显加速效果的。</p>
<p><br></p>
<p><br></p>
<h3 id="Decision4-3-solves-281-400-pts"><a href="#Decision4-3-solves-281-400-pts" class="headerlink" title="Decision4(3 solves, 281/400 pts)"></a>Decision4(3 solves, 281/400 pts)</h3><p>题目描述：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Make your decision aaagain! XD</span><br></pre></td></tr></table></figure>
<p>题目：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag</span><br><span class="line"></span><br><span class="line">flag_bin = <span class="built_in">bin</span>(bytes_to_long(flag))[<span class="number">2</span>:].zfill(<span class="built_in">len</span>(flag)*<span class="number">8</span>)</span><br><span class="line">        </span><br><span class="line">p = <span class="number">65537</span></span><br><span class="line">F = GF(p)</span><br><span class="line">n, k = <span class="number">40</span>, <span class="number">12</span></span><br><span class="line">C = codes.GeneralizedReedSolomonCode(F.<span class="built_in">list</span>()[:n], k)</span><br><span class="line">Co = C.encoder()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gen</span>():</span><br><span class="line">    temp = randint(<span class="number">0</span>,n)</span><br><span class="line">    <span class="keyword">return</span> matrix(Permutation([i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>)][temp:] + [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>)][:temp]))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">F0</span>():</span><br><span class="line">    err = [randint(<span class="number">1</span>,p-<span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k)] + [<span class="number">0</span>]*(n-k)</span><br><span class="line">    shuffle(err)</span><br><span class="line">    <span class="keyword">return</span> (gen() * Co.encode(vector(F,[randint(<span class="number">0</span>,p) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k)])) + gen() * vector(F,err)).<span class="built_in">list</span>()</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">F1</span>():</span><br><span class="line">    err = [randint(<span class="number">1</span>,p-<span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k-<span class="number">1</span>)] + [<span class="number">0</span>]*(n-k+<span class="number">1</span>)</span><br><span class="line">    shuffle(err)</span><br><span class="line">    <span class="keyword">return</span> (gen() * Co.encode(vector(F,[randint(<span class="number">0</span>,p) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k)])) + gen() * vector(F,err)).<span class="built_in">list</span>()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;output =&quot;</span>, [F0() <span class="keyword">if</span> i == <span class="string">&quot;0&quot;</span> <span class="keyword">else</span> F1() <span class="keyword">for</span> i <span class="keyword">in</span> flag_bin])</span><br></pre></td></tr></table></figure>
<p>本题背景为编码理论，采用的编码是模65537下的(40,12)-Generalized Reed Solomon Code，其decision为：</p>
<ul>
<li><p>如果flag当前bit是1，则生成一个GRS的码字M，并生成一个weight为k-1的误差e，然后按如下方式计算得到密文向量ci：</p>
<script type="math/tex; mode=display">
\textbf{c}_i = P_1M + P_2e</script><p>其中P1、P2是随机置换矩阵，共有40种可能性</p>
</li>
<li><p>如果flag当前bit是0，其余部分与1完全一样，只是误差e的weight变成k，同样给出ci：</p>
<script type="math/tex; mode=display">
\textbf{c}_i = P_1M + P_2e</script></li>
</ul>
<p>可以看出我们需要判断的内容，是误差e的weight究竟是多少。</p>
<p>GRS码的纠错能力为$\frac{n-k}{2}$，对于这个题目来说就是14，因此不论当前bit为0还是1，其误差e的weight都在纠错范围内，也就是可以进行纠错。而由于随机置换矩阵仅仅有40种可能性，因此我们小范围爆破，其中就存在正确的P1，那么我们可以左乘逆矩阵得到：</p>
<script type="math/tex; mode=display">
P_1^{-1}\textbf{c}_i = M + P_1^{-1}P_2e</script><p>而由于e是一个可解码范围内的error，置换的复合$P_1^{-1}P_2$也仍然是个置换，不会改变e的weight，所以置换后的$P_1^{-1}P_2e$仍然是一个可解码范围内的error，所以我们对$P_1^{-1}\textbf{c}_i$做GRS码的decode，就可以得到正确码字M，自然也就可以得到e的weight从而进行decision。</p>
<p>需要注意不仅正确的$P_1^{-1}$能够解码，一些错误的${P’}_1^{-1}$依然能够成功解码，它们对应的是另外的正确码字和error，但当且仅当当前bit为1时才可能有error的weight为k-1。</p>
<p>exp：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = <span class="number">65537</span></span><br><span class="line">F = GF(p)</span><br><span class="line">n, k = <span class="number">40</span>, <span class="number">12</span></span><br><span class="line">C = codes.GeneralizedReedSolomonCode(F.<span class="built_in">list</span>()[:n], k)</span><br><span class="line">Co = C.encoder()</span><br><span class="line">D = C.decoder()</span><br><span class="line"></span><br><span class="line">output = </span><br><span class="line">output = output[<span class="number">7</span>*<span class="number">8</span>:-<span class="number">8</span>]</span><br><span class="line"></span><br><span class="line">flag = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> bit <span class="keyword">in</span> trange(<span class="built_in">len</span>(output)):</span><br><span class="line">    <span class="keyword">if</span>(bit % <span class="number">8</span> == <span class="number">0</span>):</span><br><span class="line">        flag += <span class="string">&quot;0&quot;</span></span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">    Found = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> temp <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        P = Matrix(Zmod(p), matrix(Permutation([i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>)][temp:] + [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>)][:temp])))</span><br><span class="line">        codeword = P^(-<span class="number">1</span>) * vector(F,output[bit])</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            msg = D.decode_to_message(codeword).<span class="built_in">list</span>()</span><br><span class="line">            encodeword = Co.encode(vector(F,msg))</span><br><span class="line">            err = codeword - encodeword</span><br><span class="line">            <span class="keyword">if</span>(err.<span class="built_in">list</span>().count(<span class="number">0</span>) == n-k+<span class="number">1</span>):</span><br><span class="line">                Found = <span class="number">1</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(Found == <span class="number">1</span>):</span><br><span class="line">        flag += <span class="string">&quot;1&quot;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        flag += <span class="string">&quot;0&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(bit % <span class="number">8</span> == <span class="number">7</span>):</span><br><span class="line">        <span class="built_in">print</span>(long_to_bytes(<span class="built_in">int</span>(flag,<span class="number">2</span>)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#catctf&#123;S1mplest_C0d1ng_SySt3M!&#125;</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p><br></p>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>糖醋小鸡块
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://tangcuxiaojikuai.xyz/post/69eaef2e.html" title="2024-同济大学第二届网络安全新生赛CatCTF-wp-crypto">https://tangcuxiaojikuai.xyz/post/69eaef2e.html</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sacreative/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SACREATIVE</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/post/d783fbc0.html" rel="prev" title="2024-强网拟态-wp-crypto">
      <i class="fa fa-chevron-left"></i> 2024-强网拟态-wp-crypto
    </a></div>
      <div class="post-nav-item">
    <a href="/post/1dda48e6.html" rel="next" title="2024-SHCTF-week4-wp-crypto">
      2024-SHCTF-week4-wp-crypto <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Week1"><span class="nav-number">1.</span> <span class="nav-text">Week1</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Signin-75-Solves-25-100-pts"><span class="nav-number">1.1.</span> <span class="nav-text">Signin(75 Solves, 25&#x2F;100 pts)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Double-AES-10-Solves-86-300-pts"><span class="nav-number">1.2.</span> <span class="nav-text">Double AES(10 Solves, 86&#x2F;300 pts)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Decision0-11-Solves-83-300-pts"><span class="nav-number">1.3.</span> <span class="nav-text">Decision0(11 Solves, 83&#x2F;300 pts)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#det"><span class="nav-number">1.3.1.</span> <span class="nav-text">det</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#trace"><span class="nav-number">1.3.2.</span> <span class="nav-text">trace</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%98%E5%8C%96"><span class="nav-number">1.3.3.</span> <span class="nav-text">优化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%8C%E6%95%B4exp"><span class="nav-number">1.3.4.</span> <span class="nav-text">完整exp</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C0pper-4-Solves-157-300-pts"><span class="nav-number">1.4.</span> <span class="nav-text">C0pper(4 Solves, 157&#x2F;300 pts)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%A0%E8%AF%AF%E5%B7%AE%E6%83%85%E5%86%B5%E4%B8%8B%E7%9A%84%E6%B1%82%E8%A7%A3%E6%80%9D%E8%B7%AF"><span class="nav-number">1.4.1.</span> <span class="nav-text">无误差情况下的求解思路</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%89%E8%AF%AF%E5%B7%AE%E6%83%85%E5%86%B5%E4%B8%8B%E7%9A%84%E6%B1%82%E8%A7%A3%E6%80%9D%E8%B7%AF%E2%80%94%E2%80%94coppersmith%E6%96%B9%E6%B3%95"><span class="nav-number">1.4.2.</span> <span class="nav-text">有误差情况下的求解思路——coppersmith方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B1%82%E8%A7%A3m1"><span class="nav-number">1.4.3.</span> <span class="nav-text">求解m1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B1%82%E8%A7%A3m2"><span class="nav-number">1.4.4.</span> <span class="nav-text">求解m2</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%8C%E6%95%B4exp-1"><span class="nav-number">1.4.5.</span> <span class="nav-text">完整exp</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Hash-game-16-Solves-76-300-pts"><span class="nav-number">1.5.</span> <span class="nav-text">Hash game(16 Solves, 76&#x2F;300 pts)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Random-game-3-Solves-376-500-pts"><span class="nav-number">1.6.</span> <span class="nav-text">Random game(3 Solves, 376&#x2F;500 pts)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#getrandbits%E9%83%A8%E5%88%86"><span class="nav-number">1.6.1.</span> <span class="nav-text">getrandbits部分</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#MT19937%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7%E8%B4%A8%E4%BB%A5%E5%8F%8A%E7%A0%B4%E8%A7%A3%E5%8E%9F%E7%90%86"><span class="nav-number">1.6.1.1.</span> <span class="nav-text">MT19937的重要性质以及破解原理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96b"><span class="nav-number">1.6.1.2.</span> <span class="nav-text">获取b</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96T"><span class="nav-number">1.6.1.3.</span> <span class="nav-text">获取T</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#shuffle%E9%83%A8%E5%88%86"><span class="nav-number">1.6.2.</span> <span class="nav-text">shuffle部分</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%8C%E6%95%B4exp-2"><span class="nav-number">1.6.3.</span> <span class="nav-text">完整exp</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Week2"><span class="nav-number">2.</span> <span class="nav-text">Week2</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Decision1-4-solves-241-400-pts"><span class="nav-number">2.1.</span> <span class="nav-text">Decision1(4 solves, 241&#x2F;400 pts)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%A0%E8%AF%AF%E5%B7%AE%E6%83%85%E5%86%B5%E4%B8%8B%E7%9A%84%E6%B1%82%E8%A7%A3%E2%80%94%E2%80%94%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E6%8F%92%E5%80%BC"><span class="nav-number">2.1.1.</span> <span class="nav-text">无误差情况下的求解——拉格朗日插值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%89%E8%AF%AF%E5%B7%AE%E6%83%85%E5%86%B5%E4%B8%8B%E7%9A%84%E6%B1%82%E8%A7%A3%E2%80%94%E2%80%94LWE%E6%A0%B7%E6%9C%AC%E5%88%A4%E5%AE%9A"><span class="nav-number">2.1.2.</span> <span class="nav-text">有误差情况下的求解——LWE样本判定</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#LLL"><span class="nav-number">2.1.2.1.</span> <span class="nav-text">LLL</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%A9%E7%94%A8LLL%E8%A7%A3%E5%86%B3LWE%E6%A0%B7%E6%9C%AC%E5%88%A4%E5%AE%9A"><span class="nav-number">2.1.2.2.</span> <span class="nav-text">利用LLL解决LWE样本判定</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%8C%E6%95%B4exp-3"><span class="nav-number">2.1.3.</span> <span class="nav-text">完整exp</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%9E%E9%A2%84%E6%9C%9F%E8%A7%A3"><span class="nav-number">2.1.4.</span> <span class="nav-text">非预期解</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Decision2-3-solves-281-400-pts"><span class="nav-number">2.2.</span> <span class="nav-text">Decision2(3 solves, 281&#x2F;400 pts)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF%E4%B8%8A%E7%9A%84%E5%8F%8C%E7%BA%BF%E6%80%A7%E9%85%8D%E5%AF%B9%E5%87%BD%E6%95%B0%E6%80%A7%E8%B4%A8"><span class="nav-number">2.2.1.</span> <span class="nav-text">椭圆曲线上的双线性配对函数性质</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF"><span class="nav-number">2.2.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%8C%E6%95%B4exp-4"><span class="nav-number">2.2.3.</span> <span class="nav-text">完整exp</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Decision3-3-solves-281-400-pts"><span class="nav-number">2.3.</span> <span class="nav-text">Decision3(3 solves, 281&#x2F;400 pts)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%80%E4%BA%9B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">2.3.1.</span> <span class="nav-text">一些基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%B6%85%E5%A5%87%E5%BC%82%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF"><span class="nav-number">2.3.1.1.</span> <span class="nav-text">超奇异椭圆曲线</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%89%A9%E5%9F%9F"><span class="nav-number">2.3.1.2.</span> <span class="nav-text">扩域</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9B%B2%E7%BA%BF%E7%9A%84Montgomery%E5%BD%A2%E5%BC%8F"><span class="nav-number">2.3.1.3.</span> <span class="nav-text">曲线的Montgomery形式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#j%E4%B8%8D%E5%8F%98%E9%87%8F"><span class="nav-number">2.3.1.4.</span> <span class="nav-text">j不变量</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9B%B2%E7%BA%BF%E7%9A%84Montgomery%E5%BD%A2%E5%BC%8F%E4%B8%8B%EF%BC%8Ca%E4%B8%8Ej%E4%B8%8D%E5%8F%98%E9%87%8F%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">2.3.1.5.</span> <span class="nav-text">曲线的Montgomery形式下，a与j不变量的关系</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#modular-polynomial"><span class="nav-number">2.3.1.6.</span> <span class="nav-text">modular polynomial</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-1"><span class="nav-number">2.3.2.</span> <span class="nav-text">解题思路</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%97%A0%E8%AF%AF%E5%B7%AE%E6%83%85%E5%86%B5%E4%B8%8B%E7%9A%84%E6%B1%82%E8%A7%A3"><span class="nav-number">2.3.2.1.</span> <span class="nav-text">无误差情况下的求解</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%89%E8%AF%AF%E5%B7%AE%E6%83%85%E5%86%B5%E4%B8%8B%E7%9A%84%E6%B1%82%E8%A7%A3"><span class="nav-number">2.3.2.2.</span> <span class="nav-text">有误差情况下的求解</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%8C%E6%95%B4exp-5"><span class="nav-number">2.3.3.</span> <span class="nav-text">完整exp</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%BC%96%E7%A8%8B"><span class="nav-number">2.3.4.</span> <span class="nav-text">多进程编程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Decision4-3-solves-281-400-pts"><span class="nav-number">2.4.</span> <span class="nav-text">Decision4(3 solves, 281&#x2F;400 pts)</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="糖醋小鸡块"
      src="/images/image.png">
  <p class="site-author-name" itemprop="name">糖醋小鸡块</p>
  <div class="site-description" itemprop="description">"追风赶月莫停留，平芜尽处是春山"</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">100</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="/1142381085@qq.com" title="E-Mail → 1142381085@qq.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/u/6394335993" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;u&#x2F;6394335993" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">糖醋小鸡块</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  
  <script>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>
  <script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
  </script>




  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'UPEMA7DyYbIIEyOW72ohgytU-gzGzoHsz',
      appKey     : 'M7rXAfeP3JOslroay2n0Jv2R',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
<!-- 引入jQuery -->
<script type="text/javascript" src="//libs.baidu.com/jquery/1.8.3/jquery.min.js"></script>
<!-- 雪花特效2 -->
<script type="text/javascript" src="/js/snow2.js"></script>
